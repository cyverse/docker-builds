#!/usr/bin/env perl
######################################################
#         SOFTWARE COPYRIGHT NOTICE AGREEMENT        #
#  Copyright (C) {2015-2019}  {Nicolas Dierckxsens}  #
#              All Rights Reserved                   #
#         See file LICENSE for details.              #
######################################################
#           NOVOPlasty - The Organelle Assembler
#           nicolasdierckxsens@hotmail.com
use Getopt::Long;
use strict;

print "\n\n-----------------------------------------------";
print "\nNOVOPlasty: The Organelle Assembler\n";
print "Version 4.0\n";
print "Author: Nicolas Dierckxsens, (c) 2015-2020\n";
print "-----------------------------------------------\n\n";

BATCH:
my $left = '9';
my $right = '15';
my $insert_range = '1.8';
my $iterations = "1000000";
my $startprint = "1000000";
my $startprint2 = "1000000";
my $max_memory = "";
my $option = '1';
my $count_coverage = '0';
my $total_extensions = '0';
my $average_coverage_ext = "";
my $platform = "illumina";
my $variance_detection = "";
my $chromosome = "";
my $use_quality = "";
my %SNR_regions_hp; #CHECK
my $ref_skip_before = "";
my $ref_skip_before_back = "";
my $test_seed = "";
my $read_end = "";
my $read_end_b = "";
my %read_end;
my %read_end_b;
my %read_start;
my %read_start_b;
my $read_start = "";
my $read_start_b = "";
                                    my $testos = '0';
my $benchmark_time = "yes";
my $time_start_seed = "";
my $time_before_merge = "";
my $time_before_scan = "";
my $time_end_hash_scan = "";
my $time_collect_ext = "";
my $time_collect_ext_back = "";
my $time_back = "";

my $insert_size_correct = "yes";
my $overlap = "";
my $genome_range_low = "";
my $genome_range_high = "";
my $genome_range = "";
my $seed_input0 = "";
my $seed_input = "";  
my $insert_size = "";
my $project = "";
my $read_length = "";
my $type = "";
my $encrypt = "no";
my $paired = "";
my $print_log = "";
my $save_reads = "";
my %save_reads;
undef %save_reads;
my $bad_read = "";
my %contigs_id;
my %contigs_end;
undef %contigs_id;
undef %contigs_end;
my $contig_num = '1';
my $id = "";
my $id_match = "";
my $position = '0';
my $position_back = '0';
my $read_short_end2 = "";
my %read_short_end2;
my $read_short_start2 = "";
my %read_short_start2;
my $last_chance = "";
my %last_chance;
my $last_chance_back = "";
my %last_chance_back;

my %seed;
my %seed_old;
undef %seed;
undef %seed_old;
my $insert_range2 = $insert_range;
my %SNR_read;
my %SNR_read_back;
undef %SNR_read;
undef %SNR_read_back;
my $SNR_read = "";
my $SNR_read_back = "";
my $SNR_read2 = "";
my $SNR_read_back2 = "";
my $SNR_read_ahead = "";
my $SNR_read_back_ahead = "";
my %best_extension_prev;
my %best_extension_back_prev;
undef %best_extension_prev;
undef %best_extension_back_prev;
my %contig_gap_min;
my %contig_gap_max;
my %contig_count;
undef %contig_gap_min;
undef %contig_gap_max;
undef %contig_count;
my $contig_count = "";
my $progress_before = "";
my $contig_id2 = "";
my $contig_id1 = "";
my $contig_id3 = "";
my $contig_id4 = "";
my %seed_split;
undef %seed_split;
my $lastbit_contig_prev = "";
my $split_forward = "";
my $split_forward_tmp = "";
my %old_id;
my %old_id2;
my %old_rep;
my %old_rep_old;
undef %old_id;
undef %old_id2;
undef %old_rep;
undef %old_rep_old;
my %SNR_length;
my @insert_size;
my %regex;
my %regex_back;
my %regex1;
my %regexb;
my %regex2b;
undef %regex;
undef %regex_back;
undef %regex1;
undef %regexb;
undef %regex2b;
my %noback;
my %noforward;
undef %noback;
undef %noforward;
my %SNR;
my %SNR_back;
undef %SNR;
undef %SNR_back;
my $SNR_nucleo = "";
my $SNR_nucleo_back = "";
my $y ='1';
my %id_bad;
undef %id_bad;
my %position;
my %position_back;
undef %position;
undef %position_back;
my %bad_read;
undef %bad_read;
my %read_short_end_tmp;
my %read_short_start_tmp;
my %read_short_end_tmp2;
my %read_short_start_tmp2;
my %tree;
undef %tree;
my %contig_id2;
my %contig_id1;
my %contig_id3;
my %contig_id4;
undef %contig_id2;
undef %contig_id1;
undef %contig_id3;
undef %contig_id4;
my %hash;
my %hash2b;
my %hash2c;
undef %hash;
undef %hash2b;
undef %hash2c;
my %row;
undef %row;
my %before;
my %before_back;
my %first_before;
my %SNP_active;
my %first_before_back;
my %SNP_active_back;
my %nosecond;
my %repetitive_pair;
my %count_reads;
my %count_reads_all;
my $assembly_length = '1';
my $assembly_success = "";
my %seeds_check;
my %contigs;
undef %contigs;
my %variance_forward;
my %variance_back;
undef %variance_forward;
undef %variance_back;
my %last_ref_seq_forward;
my %last_ref_seq_back;
undef %last_ref_seq_forward;
undef %last_ref_seq_back;
my %large_variance_forward;
my %large_variance_back;
undef %large_variance_forward;
undef %large_variance_back;
my %large_variance_length_forward;
my %large_variance_length_back;
my %last_ref_pos_forward;
my %last_ref_pos_back;
undef %last_ref_pos_forward;
undef %last_ref_pos_back;
my %allele_percentage;
my %allele_percentage_back;
my %variance_all;
undef %variance_all;
my %variance_all_SNP;
undef %variance_all_SNP;
my %variance_all_SNP_seed;
undef %variance_all_SNP_seed;
my %variance_pos_to_nuc_to_freq;
undef %variance_pos_to_nuc_to_freq;
my %no_next_seed;
my %remove_extension_mismatch;
my %remove_extension_mismatch_tmp;
my %rep_return;
my %rep_return_back;
my %merged_match;
my %merged_match_pair;
my %merged_match_pair_back;
my %merged_match1;
my %merged_match2;
my %merged_match_back;
my %merged_match_back1;
my %merged_match_back2;
my %merged_match_pos;
my %merged_match_back_pos;

my $containX_short_end2 = "";
my $contain_dot_short_end2 = "";
my $containX_short_start2 = "";
my $contain_dot_short_start2 = "";
my $reads12 = "";
my $reads1 = "";
my $reads2 = "";
my $config;
my $read = "";
my $deletion = "";
my $deletion_back = "";
my $reference_guided = "";
my $reference_guided_back = "";
my $contig_read2 = "";
my $contig_read1 = "";
my $contig_read3 = "";
my $contig_read4 = "";
my $first_contig_start = "";
my $first_contig_start_reverse = "";
my $finish = "";
my $repetitive_detect = "";
my $repetitive_detect_back = "";
my $repetitive_detect2 = "";
my $repetitive_detect_back2 = "";
my $contig_end = "";
my $repetitive = "";
my $before_repetitive = "";
my $before_repetitive_short = "";
my $CP_check = "";
my $before_extension1 = "";
my $before_extension2 = "";
my $before_extension_back1 = "";
my $before_extension_back2 = "";
my $before = "";
my $before_back = "";
my $first_before = "";
my $SNP_active = "";
my $first_before_back = "";
my $SNP_active_back = "";
my $nosecond = "";
my $first_contig_id = "";
my $no_contig_id2 = "";
my $no_contig_id1 = "";
my $no_contig_id3 = "";
my $no_contig_id4 = "";
my $rep_detect2 = "";
my $hasL = "";
my $no_next_seed = "";
my $count_split = "";
my @firstSNP_max;
my %yuyu_option;
my %yuyu_option_back;
undef %yuyu_option;
undef %yuyu_option_back;
my $yuyu_option_A = "";
my $yuyu_option_C = "";
my $yuyu_option_T = "";
my $yuyu_option_G = "";
my $yuyu_option_A_back = "";
my $yuyu_option_C_back = "";
my $yuyu_option_T_back = "";
my $yuyu_option_G_back = "";
my $extensions_before = "";
my $before_shorter_skip = "";
my $before_shorter_skip_back = "";
my %before_shorter_skip;
my %before_shorter_skip_back;
undef %before_shorter_skip;
undef %before_shorter_skip_back;
my $SNR_next_seed = "";
my $jump_rep = "";
my $jump_rep_because_stuck = "";
my $jump_rep_back = "";
my %jump_rep;
my %jump_rep_because_stuck;
my %jump_rep_back;
undef %jump_rep;
undef %jump_rep_because_stuck;
undef %jump_rep_back;
my $count_stuck_in_rep = "";
my $AT_rich_before = "";
my $AT_rich_before_back = "";
my $cp_input = "";
my $reference = "";
my $merge_now = "";
my $best_extension_old1 = "";
my $best_extension_old2 = "";
my $best_extension_old3 = "";
my $best_extension_old4 = "";
my $count1b_tmp = "";
my $count2b_tmp = "";
my $count3b_tmp = "";
my $count4b_tmp = "";
my $overhang_check = "";
my %reference_next_seed;
undef %reference_next_seed;
my $reference_next_seed = "";
my $next_seed_ref = "";
my $last_150 = "";
my $first_150 = "";
my $best_extension_forward = "";
my $noback = "";
my $noforward = "";
my %no_large_variance_forward;
my %no_large_variance_back;
undef %no_large_variance_forward;
undef %no_large_variance_back;
my $no_large_variance_forward = "";
my $no_large_variance_back = "";
my %read_end_stuck;
my %read_start_stuck;
my %read_end_stuck_count;
my %read_start_stuck_count;
my %SNR_critical;
my %SNR_critical_pos;
my %SNR_critical_back;
my %SNR_critical_pos_back;
undef %read_end_stuck;
undef %read_start_stuck;
undef %read_end_stuck_count;
undef %read_start_stuck_count;
undef %SNR_critical;
undef %SNR_critical_pos;
undef %SNR_critical_back;
undef %SNR_critical_pos_back;
my $SNR_critical = "";
my $SNR_critical_back = "";
my $long_repeat_forward = "";
my $long_repeat_back = "";
my $batch_file;
my $get_more_matches = "";
my $get_more_matches_back = "";
my %hash_read_short_end;
my %hash_read_short_end_dot;
my %variance_no_hp;
undef %variance_no_hp;
my $stuck_in_rep_back = "";
my $stuck_in_rep_back_before = "";

my $heteroplasmy = "";;
my $hp_seed = "";
my $hp_seed2 = "";
my $hp_seed_assemble = "";
my %SNPs;
undef %SNPs;
my %noSNPs;
undef %noSNPs;
my %SNPs_indel;
my %accepted_SNPs;
my %accepted_SNPs_pair;
my %accepted_SNPs_back;
my %accepted_SNPs_pair_back;
my $hp_seed_assemble_last_chance_forward = "";
my $hp_seed_assemble_last_chance_back = "";
my $noforward_HP = "";
my $noback_HP = "";
my $PCR_free = "";
my $current_pos = '1';
my %linked_SNPs;
my %linked_SNPs_save;
my %not_linked_SNPs;
my %not_linked_SNPs_save;
my %linked_half_SNPs;
my %linked_half_SNPs_save;
my $hp_back = "";
my $HP_exclude = "";
my %HP_exclude;
my $NUMT = "";
my $NUMT_back = "";
my %NUMT;
my %NUMT_back;
my $first_NUMT = "";
my %NUMT_assembled;
my %circos_links;
my %circos_half_links;
my %circos_mutations;
undef %circos_links;
undef %circos_half_links;
undef %circos_mutations;
my $circos_links = "yes2";
my %hp_SNP_links;
my %hp_SNP_links_back;
my %hp_splits;
my $hp_splits = "";
my %hp_forward_data;
my %hp_forward_data2;
my %all_NUMT_SNPs;
my $prev_current_pos = "";
my $hp_cut_forward = "";
my $hp_cut_back = "";
my $last_SNP_hp = "";
my %variance_indels;
my $last_half_linked = "";
my $SNP_to_assemble = "";
my %SNP_to_assemble;
my $large_variance_tmp = "";
my $large_variance_tmp_back = "";
my $ref_check_forward = "";
my $ref_check_back = "";
my $first_without_LV = "";
my $first_without_LV_back = "";
my $save_seq_ref_forward = "";
my $save_seq_ref_back = "";
my %variance_all_homo;
my $need_longer_ext = "";
my $need_longer_ext_back = "";
my $no_quality = "";
my $no_quality_back = "";
my $last_chance_SNR = "";
my $last_chance_SNR_back = "";
my $no_hp_one_turn = "";
my $no_hp_one_turn2 = "";
my $no_hp_one_turn2_back = "";
my $split_hp_options = "";
my $pos_of_last_hp_split_option = "";
my $best_extension1_count = '0';
my $best_extension2_count = '0';
my %final_heteroplasmies;
undef %final_heteroplasmies;
my %final_NUMTs;
undef %final_NUMTs;
my %final_heteroplasmies_assemblies;
undef %final_heteroplasmies_assemblies;
my %final_NUMTs_assemblies;
undef %final_NUMTs_assemblies;
my %final_linked_SNPs;
my %final_linked_half_SNPs;
my %final_not_linked_SNPs;
undef %final_linked_SNPs;
undef %final_linked_half_SNPs;
undef %final_not_linked_SNPs;
my %final_linked_SNPs_NUMTs;
my %final_linked_half_SNPs_NUMTs;
my %final_not_linked_SNPs_NUMTs;
undef %final_linked_SNPs_NUMTs;
undef %final_linked_half_SNPs_NUMTs;
undef %final_not_linked_SNPs_NUMTs;
my %exlude_id_prev_nuc_hp;
undef %exlude_id_prev_nuc_hp;
my %exlude_id_prev_nuc_hp_back;
undef %exlude_id_prev_nuc_hp_back;
my %SNPs_prev;
undef %SNPs_prev;
my %old_nucs_alt;
undef %old_nucs_alt;
my %hp_indel_ratio;
undef %hp_indel_ratio;

my $resolve_split_manually = "";
my $extend_seed_directly = "";
my $SNR_go_last_chance = "";


GetOptions (
            "c=s" => \$config,
            ) or die "Incorrect usage!\n";

open(CONFIG, $config) or die "Error:Can't open the configuration file, please check the manual!\n\nUsage: perl NOVOPlasty4.0.pl -c config.txt\n";

while (my $line = <CONFIG>)
{
    $line =~ tr/\r//d;
    $line =~ s/\R/\012/;
    if ($line =~ m/.*Project name\s+\=\s+(.*?)(Type.*)*$/)
    {
        $project = $1;
        chomp $project;
        my $project_tmp = $project;
        my $ggg;
        if ($project =~ m/batch\:(.*)/)
        {
            my $batch_file_tmp = $1;
            if ($batch_file eq "")
            {
                $batch_file = $batch_file_tmp;
                print "Batch file detected...\n\n";
                open(BATCH, $batch_file) or die "Error: $!\nCan't open the batch file, please check the manual!\n";
                $ggg = "yes";
            }
            while (my $line = <BATCH>)
            {
                $project = $line;
                chomp $project;
                last;
            }
            if ($project eq $project_tmp || $project eq "")
            {
                goto EXIT;
            }
            elsif ($ggg ne "yes")
            {
                    print "\n\n------------------------------\n------------------------------\n";
                    print "        NEXT SAMPLE\n";
                    print "------------------------------\n------------------------------\n\n\n";
            }
        }
    }
    if ($line =~ m/.*Type\s+\=\s+(.*?)(Genome Range.*)*$/)
    {
        $type = $1;
        chomp $type;
        if ($type eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $type = $line;
                chomp $type;
                last;
            }
        }   
    }
    if ($line =~ m/.*Genome Range\s+\=\s+(.*?)(K-mer.*)*$/)
    {
        $genome_range = $1;
        chomp $genome_range;
        if ($genome_range eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $genome_range = $line;
                chomp $genome_range;
                last;
            }
        }
        my @words = split /-/, $genome_range;
        $genome_range_low = $words[0];
        $genome_range_high = $words[1];     
    }
    if ($line =~ m/.*K-mer\s+\=\s+(.*?)(Max memory.*)*$/)
    {
        $overlap = $1;
        chomp $overlap;
        if ($overlap eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $overlap = $line;
                chomp $overlap;
                last;
            }
        }
    }
    if ($line =~ m/.*Max memory\s+\=\s+(.*?)(Extended log.*)*$/)
    {
        $max_memory = $1;
        chomp $max_memory;
        if ($max_memory eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $max_memory = $line;
                chomp $max_memory;
                last;
            }
        }
    }
    if ($line =~ m/.*Extended log\s+\=\s+(.*?)(Save assembled reads.*)*$/)
    {
        $print_log = $1;
        chomp $print_log;
        if ($print_log eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $print_log = $line;
                chomp $print_log;
                last;
            }
        }
    }
    if ($line =~ m/.*Save assembled reads\s+\=\s+(.*?)(Seed Input.*)*$/)
    {
        $save_reads = $1;
        chomp $save_reads;
        if ($save_reads eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $save_reads = $line;
                chomp $save_reads;
                last;
            }
        }
    }
    if ($line =~ m/.*Seed Input\s+\=\s+(.*?)(Extend seed directly.*)*$/)
    {
        $seed_input0 = $1;
        chomp $seed_input0;
        if ($seed_input0 eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $seed_input0 = $line;
                chomp $seed_input0;
                last;
            }
        }
    }
    if ($line =~ m/.*Extend seed directly\s+\=\s+(.*?)(Reference sequence.*)*$/)
    {
        $extend_seed_directly = $1;
        chomp $extend_seed_directly;
        if ($extend_seed_directly eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $extend_seed_directly = $line;
                chomp $extend_seed_directly;
                last;
            }
        }
    }
    if ($line =~ m/.*Reference sequence\s+\=\s+(.*?)(Variance detection.*)*$/)
    {
        $reference = $1;
        chomp $reference;
        if ($reference eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $reference = $line;
                chomp $reference;
                last;
            }
        }
    }
    if ($line =~ m/.*Variance detection\s+\=\s+(.*?)(Chloroplast.*)*$/)
    {
        $variance_detection = $1;
        chomp $variance_detection;
        if ($variance_detection eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $variance_detection = $line;
                chomp $variance_detection;
                last;
            }
        }
    }
    if ($line =~ m/.*Chloroplast sequence\s+\=\s+(.*?)(Dataset 1:.*)*$/)
    {
        $cp_input = $1;
        chomp $cp_input;
        if ($cp_input eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $cp_input = $line;
                chomp $cp_input;
                last;
            }
        }
    }
    if ($line =~ m/.*Read Length\s+\=\s+(.*?)(Insert size.*)*$/)
    {
        $read_length = $1;
        chomp $read_length;
        if ($read_length eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $read_length = $line;
                chomp $read_length;
                last;
            }
        }
    }
    if ($line =~ m/.*Insert size\s+\=\s+(.*?)(Platform.*)*$/)
    {
        $insert_size = $1;
        chomp $insert_size;
        if ($insert_size eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $insert_size = $line;
                chomp $insert_size;
                last;
            }
        }
    }
    if ($line =~ m/.*Platform\s+\=\s+(.*?)(Single\/Paired.*)*$/)
    {
        $platform = $1;
        chomp $platform;
        if ($platform eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $platform = $line;
                chomp $platform;
                last;
            }
        }
    }
    if ($line =~ m/.*Single\/Paired\s+\=\s+(.*?)(Combined reads.*)*$/)
    {
        $paired = $1;
        chomp $paired;
        if ($paired eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $paired = $line;
                chomp $paired;
                last;
            }
        }
    }
    if ($line =~ m/.*Combined reads\s+\=\s+(.*?)(Forward reads.*)*$/)
    {
        $reads12 = $1;
        chomp $reads12;
        if ($reads12 eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $reads12 = $line;
                chomp $reads12;
                last;
            }
        }
    }
    if ($line =~ m/.*Forward reads\s+\=\s+(.*?)(Reverse reads.*)*$/)
    {
        $reads1 = $1;
        chomp $reads1;
        if ($reads1 eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $reads1 = $line;
                chomp $reads1;
                last;
            }
        }
    }
    if ($line =~ m/.*Reverse reads\s+\=\s+(.*?)(Heteroplasmy:.*)*$/)
    {
        $reads2 = $1;
        chomp $reads2;
        if ($reads2 eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $reads2 = $line;
                chomp $reads2;
                last;
            }
        }
    }
    if ($line =~ m/.*MAF\s+\=\s+(.*?)(HP exclude list.*)*$/)
    {
        $heteroplasmy = $1;
        chomp $heteroplasmy;
        if ($heteroplasmy eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $heteroplasmy = $line;
                chomp $heteroplasmy;
                last;
            }
        }
    }
    if ($line =~ m/.*HP exclude list\s+\=\s+(.*?)(PCR-free.*)*$/)
    {
        $HP_exclude = $1;
        chomp $HP_exclude;
        if ($HP_exclude eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $HP_exclude = $line;
                chomp $HP_exclude;
                last;
            }
        }
    }
    if ($line =~ m/.*PCR-free\s+\=\s+(.*?)(Optional:.*)*$/)
    {
        $PCR_free = $1;
        chomp $PCR_free;
        if ($PCR_free eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $PCR_free = $line;
                chomp $PCR_free;
                last;
            }
        }
    }
    if ($line =~ m/.*Insert size auto\s+\=\s+(.*?)(Use Quality Scores.*)*$/)
    {
        $insert_size_correct = $1;
        chomp $insert_size_correct;     
    }
    if ($line =~ m/.*Use Quality Scores\s+\=\s+(.*?)$/)
    {
        $use_quality = $1;
        chomp $use_quality;
        last;
    }
}

close CONFIG;

if ($print_log eq '1' || $print_log eq '2')
{
    $startprint2 = '0';
    $startprint = '10000000';
}

if ($platform eq "Ion")
{
    $platform = "ion";
}
if ($platform eq "Illumina")
{
    $platform = "illumina";
}
if ($paired eq "SE")
{
    $insert_size = $read_length*2;
    $insert_size_correct = "no";
}
if ($heteroplasmy eq "no")
{
    $heteroplasmy = "";
}
if ($variance_detection eq "no")
{
    $variance_detection = "";
}
if ($use_quality ne "yes")
{
    $use_quality = "";
}
if ($heteroplasmy ne "")
{
    $use_quality = "yes";
}
my $output_file4  = "log_".$project.".txt";
open(OUTPUT4, ">" .$output_file4) or die "\nCan't open file $output_file4, $!\n";


print "\nInput parameters from the configuration file:   *** Verify if everything is correct ***\n\n";
print "Project:\n";
print "-----------------------\n";
print "Project name          = ".$project."\n";
print "Type                  = ".$type."\n";
print "Genome range          = ".$genome_range."\n";
print "K-mer                 = ".$overlap."\n";
print "Max memory            = ".$max_memory."\n";
print "Extended log          = ".$print_log."\n";
print "Save assembled reads  = ".$save_reads."\n";
print "Seed Input            = ".$seed_input0."\n";
print "Extend seed directly  = ".$extend_seed_directly."\n";
print "Reference sequence    = ".$reference."\n";
print "Variance detection    = ".$variance_detection."\n";
print "Chloroplast sequence  = ".$cp_input."\n\n";

print "Dataset 1:\n";
print "-----------------------\n";
print "Read Length           = ".$read_length."\n";
print "Insert size           = ".$insert_size."\n";
print "Platform              = ".$platform."\n";
print "Single/Paired         = ".$paired."\n";
print "Combined reads        = ".$reads12."\n";
print "Forward reads         = ".$reads1."\n";
print "Reverse reads         = ".$reads2."\n\n";

print "Heteroplasmy:\n";
print "-----------------------\n";
print "Heteroplasmy          = ".$heteroplasmy."\n";
print "HP exclude list       = ".$HP_exclude."\n";
print "PCR-free              = ".$PCR_free."\n\n";

print "Optional:\n";
print "-----------------------\n";
print "Insert size auto      = ".$insert_size_correct."\n";
print "Use Quality Scores    = ".$use_quality."\n\n";

print OUTPUT4 "\n\n-----------------------------------------------";
print OUTPUT4 "\nNOVOPlasty: The Organelle Assembler\n";
print OUTPUT4 "Version 4.0\n";
print OUTPUT4 "Author: Nicolas Dierckxsens, (c) 2015-2020\n";
print OUTPUT4 "-----------------------------------------------\n\n";

print OUTPUT4 "\nInput parameters from the configuration file:   *** Verify if everything is correct ***\n\n";
print OUTPUT4 "Project:\n";
print OUTPUT4 "----------------------\n";
print OUTPUT4 "Project name          = ".$project."\n";
print OUTPUT4 "Type                  = ".$type."\n";
print OUTPUT4 "Genome range          = ".$genome_range."\n";
print OUTPUT4 "K-mer                 = ".$overlap."\n";
print OUTPUT4 "Max memory            = ".$max_memory."\n";
print OUTPUT4 "Extended log          = ".$print_log."\n";
print OUTPUT4 "Save assembled reads  = ".$save_reads."\n";
print OUTPUT4 "Seed Input            = ".$seed_input0."\n";
print OUTPUT4 "Extend seed directly  = ".$extend_seed_directly."\n";
print OUTPUT4 "Reference sequence    = ".$reference."\n";
print OUTPUT4 "Variance detection    = ".$variance_detection."\n";
print OUTPUT4 "Chloroplast sequence  = ".$cp_input."\n\n";

print OUTPUT4 "Dataset 1:\n";
print OUTPUT4 "----------------------\n";
print OUTPUT4 "Read Length           = ".$read_length."\n";
print OUTPUT4 "Insert size           = ".$insert_size."\n";
print OUTPUT4 "Platform              = ".$platform."\n";
print OUTPUT4 "Single/Paired         = ".$paired."\n";
print OUTPUT4 "Combined reads        = ".$reads12."\n";
print OUTPUT4 "Forward reads         = ".$reads1."\n";
print OUTPUT4 "Reverse reads         = ".$reads2."\n\n";

print OUTPUT4 "Heteroplasmy:\n";
print OUTPUT4 "-----------------------\n";
print OUTPUT4 "Heteroplasmy          = ".$heteroplasmy."\n";
print OUTPUT4 "HP exclude list       = ".$HP_exclude."\n";
print OUTPUT4 "PCR-free              = ".$PCR_free."\n\n";

print OUTPUT4 "Optional:\n";
print OUTPUT4 "----------------------\n";
print OUTPUT4 "Insert size auto      = ".$insert_size_correct."\n";
print OUTPUT4 "Use Quality Scores    = ".$use_quality."\n\n";

if ($platform ne "illumina" && $platform ne "ion")
{
    die "\nPlatform has to be 'illumina' or 'ion', please check the configuration file!\n";
}
if ($platform eq "ion" && ($variance_detection eq "yes" || $heteroplasmy ne ""))
{
    die "\nVariance or heteroplasmy detection can only be run with illumina data!\n";
}
if ($paired ne "PE" && $paired ne "SE")
{
    die "\nPaired has to be 'SE' or 'PE', please check the configuration file!\n";
}
if ($reads12 ne "" && $reads1 ne "")
{
    die "\nYou can't give a path for a combined dataset and a forward and reverse set!\n If you have both, only use the forward and reverse path in the config file\n";
}

if ($variance_detection eq "yes" && $reference eq "")
{
    die "\nWhen variance detection is on, you must give a reference sequence, please check the configuration file!\n";
}

if ($heteroplasmy ne "" && $variance_detection ne "")
{
    die "\nYou can't use variance and heteroplasmy detection at the same time!\n\nVariance detection should be used to compare with a reference other than itself.\n\nFor the heteroplasmy option you first need to assemble the organelle and then give this as a reference.\n";
}
if ($heteroplasmy ne "" && $heteroplasmy < '0.006')
{
    die "\nYou can't detect heteroplasmy with a frequency below 0.6% (0.006 as input).\n";
}
if ($heteroplasmy ne "" && $reference ne "")
{
    $seed_input0 = $reference;
}
if ($save_reads ne "yes" && $save_reads ne "1" && $save_reads ne "2" && $save_reads ne ""  && $save_reads ne "no")
{
    die "\n'Save assembled reads' has to be '1', '2' or empty, please check the configuration file!\n";
}
if ($max_memory =~ m/^\d*$/)
{
}
else
{
    die "\n'Max memory' can only be an integer, the amount is always in GB of RAM, don't add a unit!\n";
}
if ($save_reads eq "no")
{
    $save_reads = "";
}
if ($extend_seed_directly ne "yes" && $extend_seed_directly ne "" && $extend_seed_directly ne "no")
{
    die "\n'Extend seed directly option has to be 'yes' or 'no' or left empty!\n";
}
if ($extend_seed_directly eq "no")
{
    $extend_seed_directly = "";
}

my $USAGE = "\nUsage: perl NOVOPlasty4.0.pl -c config.txt";



sub build_partialb
{
    my $A = "";
    my $G = "";
    my $T = "";
    my $C = "";
    
    my ($str) = (@_);
    my @re;
    undef @re;
    my $v = length($str);
    my $m = '1';

    while ($m < $v) 
    {
        my $str9 = substr $str, $m+1;
        my $str6 = substr $str, 0, $m; 
        my $x = '0';
        my $y = length($str6);
        
        while ($x < $y) 
        {     
            my $str8 = substr $str6, $x+1;
            my $str7 = substr $str6, 0, $x;
            $A = $str7.".".$str8.".".$str9;
            push @re, $A;
            $x++;
        }
        $m++;
    }
    @re;
}
sub build_partialb_4dots
{
    my ($str) = (@_);
    my $str_old = $str;
    my @re;
    undef @re;
    my $x = '0';
    my $v = length($str);
    while ($x < $v-3) 
    {
        substr $str, $x, 1, ".";
        my $x2 = $x+1;
        my $str1 = $str;
        while ($x2 < $v-2)
        {
            substr $str, $x2, 1, ".";
            my $x3 = $x2+1;
            my $str2 = $str;
            while ($x3 < $v-1)
            {
                substr $str, $x3, 1, ".";
                my $x4 = $x3+1;
                my $str3 = $str;
                while ($x4 < $v)
                {
                    substr $str, $x4, 1, ".";
                    push @re, $str;
                    $str = $str3;
                    $x4++; 
                }
                $str = $str2;
                $x3++; 
            }
            $str = $str1;
            $x2++; 
        }
        $str = $str_old;
        $x++; 
    }
    @re;
}
sub build_partial2b
{
    my $A = "";
    my (%str) = (@_);
    my %re;
    undef %re;

    foreach my $str (keys %str) 
    {
        my $v = length($str)-1;
        my $m = '2';
    
        while ($m < $v) 
        {
            my $str9 = substr $str, $m+1;
            my $str6 = substr $str, 0, $m; 
            my $x = '0';
            my $y = length($str6);
            
            while ($x < $y) 
            {     
                my $str8 = substr $str6, $x+1;
                my $str7 = substr $str6, 0, $x;
                $re{$str7."A".$str8."A".$str9} = undef;
                $re{$str7."A".$str8."C".$str9} = undef;
                $re{$str7."A".$str8."T".$str9} = undef;
                $re{$str7."A".$str8."G".$str9} = undef;
                $re{$str7."C".$str8."A".$str9} = undef;
                $re{$str7."C".$str8."C".$str9} = undef;
                $re{$str7."C".$str8."T".$str9} = undef;
                $re{$str7."C".$str8."G".$str9} = undef;
                $re{$str7."T".$str8."A".$str9} = undef;
                $re{$str7."T".$str8."C".$str9} = undef;
                $re{$str7."T".$str8."T".$str9} = undef;               
                $re{$str7."T".$str8."G".$str9} = undef;
                $re{$str7."G".$str8."A".$str9} = undef;
                $re{$str7."G".$str8."C".$str9} = undef;
                $re{$str7."G".$str8."T".$str9} = undef;
                $re{$str7."G".$str8."G".$str9} = undef;
                $x++;
            }
            $m++;
        }
    }
    %re;
}
sub build_partial3b {
 
my $A = "";
my @str = @_;
my $str = $str[0];
my $reverse = $str[1];
my $no_delete = $str[2];
my %re;
my %re2;
my %re3;
undef %re;
undef %re2;
undef %re3;
my $hasdot = $str =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
my $hasstar = $str =~ tr/\*//;
my $first_nuc = substr $str, 0, 1;
if ($first_nuc eq "*")
{
    substr $str, 0, 1, ".";
}
$re2{$str} = '0';

if ($hasstar > 0)
{
    my $count = '0';
    my $length_before;
    while ($str =~ /((\w\*)+)/g)
    {
        $length_before = $-[0];
        $count++;
    }
    if ($count > 1)
    {
        print OUTPUT5 $count." TEST_COUNT_STAR_B\n";
    }
    if ($count eq '1' || $count > 2)
    {
        if ($reverse eq "reverse" || $reverse eq "reverse_back")
        {
            my $str2 = $str;
            $str2 =~ s/\*.//g;
            $re3{$str2} = ($hasstar*2)."+".$length_before;
        }
        else
        {
            my $str2 = $str;
            $str2 =~ s/.\*//g;
            $re3{$str2} = ($hasstar*2)."+".$length_before;
        }
        if ($reverse eq "reverse" || $reverse eq "back")
        {
            $str =~ tr/\*//d;
            if ($no_delete ne "no_delete")
            {
                my $temp_sre = $str;
                $str = substr $temp_sre, 0, -$hasstar;
            }
            $re3{$str} = $hasstar."+".$length_before;
        }
        else
        {
            $str =~ tr/\*//d;
            if ($no_delete ne "no_delete")
            {
                my $temp_sre = $str;
                $str = substr $temp_sre, $hasstar;
            }
            $re3{$str} = $hasstar."+".$length_before;
        }
    }
    elsif ($count eq '2')
    {
        my $str1 = $str;
        my $x = '0';
        my @combi = ('.\*','\*');
        
        if ($reverse eq "reverse" || $reverse eq "reverse_back")
        {
            @combi = ('\*.','\*');
        }
        my $length_deleted = '0';
        my $length_before = '0';
    
        while ($x < 2)
        {
            $str1 = $str;
            my $count1 = '0';
            while ($str1 =~ /((\w\*)+)/g)
            {
                my $length_before = $-[0];
                my $part1 = $1;   
                if ($count1 eq 0)
                {
                    $length_deleted = -length($part1);
                    $part1 =~ s/$combi[$x]//g;
                    $length_deleted += length($part1);
                    $length_deleted .= "+".$length_before;
                    my $i = 1;
                    $str1 =~ s/((\w\*)+)/--$i == 0 ? "$part1":$1/ge;
                }
                $count1++;
            }   
            my $x2 = '0';
            while ($x2 < 2)
            {
                my $str2 = $str1;
                my $count2 = '0';
                my $length_deleted2;
                while ($str2 =~ /((\w\*)+)/g)
                {
                    my $length_before = $-[0];
                    my $part1 = $1; 
                    if ($count2 eq $count-2)
                    {
                        $length_deleted2 = -length($part1);
                        $part1 =~ s/$combi[$x2]//g;
                        $length_deleted2 += length($part1);
                        $length_deleted .= "*".$length_deleted2."+".$length_before;
                        my $i = $count-1;
                        $str2 =~ s/((\w\*)+)/--$i == 0 ? "$part1":$1/ge;
                    }
                    $count2++;
                }  
                $re3{$str2} = $length_deleted;
                $x2++; 
            }
            $x++; 
        }
    }
}
else
{
    %re3 = %re2;
}

if ($hasdot > 0)
{
    foreach my $str (keys %re3) 
    {
        my @combi = ("A","C","T","G");
        my @split = split //, $str;
        my @dots;
        my $count = '0';
        while ($count < length($str))
        {
            if ($split[$count] eq '.')
            {
                push @dots, $count;
            }
            $count++;
        }
        my $str1 = $str;
        my $x = '0';  
        
        $hasdot = $str =~ tr/\.//;
        if ($hasdot eq '1')
        {
            if ($str =~ m/^(\w*)\.(\w*)$/)
            {
                my $str7 = $1;
                my $str8 = $2;
                
                $re{$str7."A".$str8} = $re3{$str};
                $re{$str7."C".$str8} = $re3{$str};
                $re{$str7."T".$str8} = $re3{$str};
                $re{$str7."G".$str8} = $re3{$str};
            }
        }
        elsif ($hasdot eq '2')
        {
            if ($str =~ m/^(\w*)\.(\w*)\.(\w*)$/)
            {
                my $str7 = $1;
                my $str8 = $2;
                my $str9 = $3;
                
                    $A = $str7."A".$str8."A".$str9; #two substitutions
                    $re{$A} = $re3{$str};
                    $A = $str7."A".$str8."C".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."A".$str8."T".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."A".$str8."G".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."C".$str8."A".$str9; #two substitutions
                    $re{$A} = $re3{$str};
                    $A = $str7."C".$str8."C".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."C".$str8."T".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."C".$str8."G".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."T".$str8."A".$str9; #two substitutions
                    $re{$A} = $re3{$str};
                    $A = $str7."T".$str8."C".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."T".$str8."T".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."T".$str8."G".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."G".$str8."A".$str9; #two substitutions
                    $re{$A} = $re3{$str};
                    $A = $str7."G".$str8."C".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."G".$str8."T".$str9;  
                    $re{$A} = $re3{$str};
                    $A = $str7."G".$str8."G".$str9;  
                    $re{$A} = $re3{$str};
            }
        }
        elsif ($hasdot eq '3')
        {           
            while ($x < 4)
            {
                $str1 = $str;
                substr $str1, $dots[0], 1, $combi[$x];
                my $x2 = '0';
                while ($x2 < 4)
                {
                    my $str2 = $str1;
                    substr $str2, $dots[1], 1, $combi[$x2];
                    my $x3 = '0';
                    while ($x3 < 4)
                    {
                        my $str3 = $str2;
                        substr $str3, $dots[2], 1, $combi[$x3];
                        $re{$str3} = $re3{$str};
                        $x3++; 
                    }
                    $x2++; 
                }
                $x++; 
            }
        }
        elsif ($hasdot eq '4')
        {
            while ($x < 4)
            {
                $str1 = $str;
                substr $str1, $dots[0], 1, $combi[$x];
                my $x2 = '0';
                while ($x2 < 4)
                {
                    my $str2 = $str1;
                    substr $str2, $dots[1], 1, $combi[$x2];
                    my $x3 = '0';
                    while ($x3 < 4)
                    {
                        my $str3 = $str2;
                        substr $str3, $dots[2], 1, $combi[$x3];
                        my $x4 = '0';
                        while ($x4 < 4)
                        {
                           my $str4 = $str3;
                           substr $str4, $dots[3], 1, $combi[$x4];
                           $re{$str4} = $re3{$str};
                           $x4++; 
                        }
                        $x3++; 
                    }
                    $x2++; 
                }
                $x++; 
            }
        }
        elsif ($hasdot eq '5')
        {
            while ($x < 4)
            {
                $str1 = $str;
                substr $str1, $dots[0], 1, $combi[$x];
                my $x2 = '0';
                while ($x2 < 4)
                {
                    my $str2 = $str1;
                    substr $str2, $dots[1], 1, $combi[$x2];
                    my $x3 = '0';
                    while ($x3 < 4)
                    {
                        my $str3 = $str2;
                        substr $str3, $dots[2], 1, $combi[$x3];
                        my $x4 = '0';
                        while ($x4 < 4)
                        {
                            my $str4 = $str3;
                            substr $str4, $dots[3], 1, $combi[$x4];
                            my $x5 = '0';
                            while ($x5 < 4)
                            {
                                my $str5 = $str4;
                                substr $str5, $dots[4], 1, $combi[$x5];
                                $re{$str5} = $re3{$str};
                                $x5++; 
                            }
                           $x4++; 
                        }
                        $x3++; 
                    }
                    $x2++; 
                }
                $x++; 
            }
        }
        elsif ($hasdot eq '6')
        {
            while ($x < 4)
            {
                $str1 = $str;
                substr $str1, $dots[0], 1, $combi[$x];
                my $x2 = '0';
                while ($x2 < 4)
                {
                    my $str2 = $str1;
                    substr $str2, $dots[1], 1, $combi[$x2];
                    my $x3 = '0';
                    while ($x3 < 4)
                    {
                        my $str3 = $str2;
                        substr $str3, $dots[2], 1, $combi[$x3];
                        my $x4 = '0';
                        while ($x4 < 4)
                        {
                            my $str4 = $str3;
                            substr $str4, $dots[3], 1, $combi[$x4];
                            my $x5 = '0';
                            while ($x5 < 4)
                            {
                                my $str5 = $str4;
                                substr $str5, $dots[4], 1, $combi[$x5];
                                my $x6 = '0';
                                while ($x6 < 4)
                                {
                                    my $str6 = $str5;
                                    substr $str6, $dots[5], 1, $combi[$x6];
                                    $re{$str6} = $re3{$str};
                                    $x6++;
                                }
                                $x5++;
                            }
                           $x4++; 
                        }
                        $x3++; 
                    }
                    $x2++; 
                }
                $x++; 
            }
                
        }
        elsif ($hasdot eq '7')
        {
            while ($x < 4)
            {
                $str1 = $str;
                substr $str1, $dots[0], 1, $combi[$x];
                my $x2 = '0';
                while ($x2 < 4)
                {
                    my $str2 = $str1;
                    substr $str2, $dots[1], 1, $combi[$x2];
                    my $x3 = '0';
                    while ($x3 < 4)
                    {
                        my $str3 = $str2;
                        substr $str3, $dots[2], 1, $combi[$x3];
                        my $x4 = '0';
                        while ($x4 < 4)
                        {
                            my $str4 = $str3;
                            substr $str4, $dots[3], 1, $combi[$x4];
                            my $x5 = '0';
                            while ($x5 < 4)
                            {
                                my $str5 = $str4;
                                substr $str5, $dots[4], 1, $combi[$x5];
                                my $x6 = '0';
                                while ($x6 < 4)
                                {
                                    my $str6 = $str5;
                                    substr $str6, $dots[5], 1, $combi[$x6];
                                    my $x7 = '0';
                                    while ($x7 < 4)
                                    {
                                        my $str7 = $str6;
                                        substr $str7, $dots[6], 1, $combi[$x7];
                                        $re{$str7} = $re3{$str};
                                        $x7++;
                                    }
                                    $x6++;
                                }
                                $x5++;
                            }
                           $x4++; 
                        }
                        $x3++; 
                    }
                    $x2++; 
                }
                $x++; 
            }
        }
        elsif ($hasdot eq '8')
        {
            while ($x < 4)
            {
                $str1 = $str;
                substr $str1, $dots[0], 1, $combi[$x];
                my $x2 = '0';
                while ($x2 < 4)
                {
                    my $str2 = $str1;
                    substr $str2, $dots[1], 1, $combi[$x2];
                    my $x3 = '0';
                    while ($x3 < 4)
                    {
                        my $str3 = $str2;
                        substr $str3, $dots[2], 1, $combi[$x3];
                        my $x4 = '0';
                        while ($x4 < 4)
                        {
                            my $str4 = $str3;
                            substr $str4, $dots[3], 1, $combi[$x4];
                            my $x5 = '0';
                            while ($x5 < 4)
                            {
                                my $str5 = $str4;
                                substr $str5, $dots[4], 1, $combi[$x5];
                                my $x6 = '0';
                                while ($x6 < 4)
                                {
                                    my $str6 = $str5;
                                    substr $str6, $dots[5], 1, $combi[$x6];
                                    my $x7 = '0';
                                    while ($x7 < 4)
                                    {
                                        my $str7 = $str6;
                                        substr $str7, $dots[6], 1, $combi[$x7];
                                        my $x8 = '0';
                                        while ($x8 < 4)
                                        {
                                            my $str8 = $str7;
                                            substr $str8, $dots[7], 1, $combi[$x8];
                                            $re{$str8} = $re3{$str};
                                            $x8++;
                                        }
                                        $x7++;
                                    }
                                    $x6++;
                                }
                                $x5++;
                            }
                           $x4++; 
                        }
                        $x3++; 
                    }
                    $x2++; 
                }
                $x++; 
            }
        }
        elsif ($hasdot eq '9')
        {
            while ($x < 4)
            {
                $str1 = $str;
                substr $str1, $dots[0], 1, $combi[$x];
                my $x2 = '0';
                while ($x2 < 4)
                {
                    my $str2 = $str1;
                    substr $str2, $dots[1], 1, $combi[$x2];
                    my $x3 = '0';
                    while ($x3 < 4)
                    {
                        my $str3 = $str2;
                        substr $str3, $dots[2], 1, $combi[$x3];
                        my $x4 = '0';
                        while ($x4 < 4)
                        {
                            my $str4 = $str3;
                            substr $str4, $dots[3], 1, $combi[$x4];
                            my $x5 = '0';
                            while ($x5 < 4)
                            {
                                my $str5 = $str4;
                                substr $str5, $dots[4], 1, $combi[$x5];
                                my $x6 = '0';
                                while ($x6 < 4)
                                {
                                    my $str6 = $str5;
                                    substr $str6, $dots[5], 1, $combi[$x6];
                                    my $x7 = '0';
                                    while ($x7 < 4)
                                    {
                                        my $str7 = $str6;
                                        substr $str7, $dots[6], 1, $combi[$x7];
                                        my $x8 = '0';
                                        while ($x8 < 4)
                                        {
                                            my $str8 = $str7;
                                            substr $str8, $dots[7], 1, $combi[$x8];
                                            my $x9 = '0';
                                            while ($x9 < 4)
                                            {
                                                my $str9 = $str8;
                                                substr $str9, $dots[8], 1, $combi[$x9];
                                                $re{$str9} = $re3{$str};
                                                $x9++;
                                            }
                                            $x8++;
                                        }
                                        $x7++;
                                    }
                                    $x6++;
                                }
                                $x5++;
                            }
                           $x4++; 
                        }
                        $x3++; 
                    }
                    $x2++; 
                }
                $x++; 
            }
        }
        if ($hasdot > 9 && $hasdot < 15)
        {
            my $str1 = $str;
            my @combi = ("A","C","T","G");
            
            my @dots;
            my @split = split //, $str1;
            my $count = '0';
            while ($count < length($str1))
            {
                if ($split[$count] eq '.')
                {
                    push @dots, $count;
                }
                $count++;
            }
            
            my @x;
            my $d = '1';
            while ($d <= $hasdot)
            {
                $x[$d] = '0';
                $d++;
            }  
            
            $d = '0';
            my $current_dot = '0';
            my $goto_dot = $hasdot-1;
        
STRING:     while ($current_dot <= $goto_dot)
            {
                my $x2 = $dots[$current_dot];
                substr $str1, $x2, 1, $combi[$x[$current_dot]];
                $x[$current_dot] = $x[$current_dot]+1;
                $current_dot++;
            }
            $current_dot--;
            my $x3 = '1';
            $re{$str1} = $re3{$str};
            while ($x3 < 4)
            {
                substr $str1, $dots[$current_dot], 1, $combi[$x[$current_dot]];
                $x[$current_dot] = $x[$current_dot]+1;
                $x3++;
                $re{$str1} = $re3{$str};
            }
            if ($current_dot eq $hasdot-1)
            {
                $x[$current_dot] = '0';
                $goto_dot = $current_dot;
                $current_dot--;
                while ($x[$current_dot] eq '4' && $current_dot ne '0')
                {
                    $x[$current_dot] = '0';
                    $current_dot--;
                    $goto_dot = $hasdot-1;
                }
                if ($current_dot eq  0 && $x[$current_dot] eq '4')
                {
                    goto STRING_END;
                }
                goto STRING;
            }
            STRING_END:
        }
        else
        {
            $re{$str} = '0';
        }
    }
}
else
{
    %re = %re3;
}
    %re;
}
sub build_partial3c
{
    my $A = "";
    my @str = @_;
    my $str = $str[0];
    my $reverse = $str[1];
    my $no_delete = $str[2];
    my %re2;
    my %re;
    undef %re2;
    undef %re;
    my $hasstar = $str =~ tr/\*/\*/;
    my $first_nuc = substr $str, 0, 1;
    if ($first_nuc eq "*")
    {
        substr $str, 0, 1, ".";
    }
    $re2{$str} = '0';

    if ($hasstar > 0)
    {
        my $count = '0';
        my $length_before;
        while ($str =~ /((\w\*)+)/g)
        {
            $length_before = $-[0];
            $count++;
        }
        if ($count > 1)
        {
            print OUTPUT5 $count." TEST_COUNT_STAR_C\n";
        }
        if ($count eq '1' || $count > 2)
        {
            if ($reverse eq "reverse" || $reverse eq "reverse_back")
            {
                my $str2 = $str;
                $str2 =~ s/\*.//g;
                $re{$str2} = ($hasstar*2)."+".$length_before;
            }
            else
            {
                my $str2 = $str;
                $str2 =~ s/.\*//g;
                $re{$str2} = ($hasstar*2)."+".$length_before;
            }
            if ($reverse eq "reverse" || $reverse eq "back")
            {
                $str =~ tr/\*//d;
                if ($no_delete ne "no_delete")
                {
                    my $temp_sre = $str;
                    $str = substr $temp_sre, 0, -$hasstar;
                }
                $re{$str} = $hasstar."+".$length_before;
            }
            else
            {
                $str =~ tr/\*//d;
                if ($no_delete ne "no_delete")
                {
                    my $temp_sre = $str;
                    $str = substr $temp_sre, $hasstar;
                }
                $re{$str} = $hasstar."+".$length_before;
            }
        }
        elsif ($count eq '2')
        {
            my $str1 = $str;
            my $x = '0';
            my @combi = ('.\*','\*');
            
            if ($reverse eq "reverse" || $reverse eq "reverse_back")
            {
                @combi = ('\*.','\*');
            }
            
            my $length_deleted = '0';
            my $length_before = '0';
        
            while ($x < 2)
            {
                $str1 = $str;
                my $count1 = '0';
                while ($str1 =~ /((\w\*)+)/g)
                {
                    my $length_before = $-[0];
                    my $part1 = $1;   
                    if ($count1 eq 0)
                    {
                        $length_deleted = -length($part1);
                        $part1 =~ s/$combi[$x]//g;
                        $length_deleted += length($part1);
                        $length_deleted .= "+".$length_before;
                        my $i = 1;
                        $str1 =~ s/((\w\*)+)/--$i == 0 ? "$part1":$1/ge;
                    }
                    $count1++;
                }   
                my $x2 = '0';
                while ($x2 < 2)
                {
                    my $str2 = $str1;
                    my $count2 = '0';
                    my $length_deleted2;
                    while ($str2 =~ /((\w\*)+)/g)
                    {
                        my $length_before = $-[0];
                        my $part1 = $1; 
                        if ($count2 eq $count-2)
                        {
                            $length_deleted2 = -length($part1);
                            $part1 =~ s/$combi[$x2]//g;
                            $length_deleted2 += length($part1);
                            $length_deleted .= "*".$length_deleted2."+".$length_before;
                            my $i = $count-1;
                            $str2 =~ s/((\w\*)+)/--$i == 0 ? "$part1":$1/ge;
                        }
                        $count2++;
                    }  
                    $re{$str2} = $length_deleted;
                    $x2++; 
                }
                $x++; 
            }
        }
    }
    else
    {
        %re = %re2;
    }
    %re;
}
sub uniq
{
    my %seen;
    undef %seen;
    grep !$seen{$_}++, @_;
}
sub encrypt
{
    my @value = @_;
    my $value = $value[0];
    
    $value =~ s/AA/0/g;
    $value =~ s/CC/1/g;
    $value =~ s/TT/2/g;
    $value =~ s/GG/3/g;
    $value =~ s/AC/4/g;
    $value =~ s/AG/5/g;
    $value =~ s/AT/6/g;
    $value =~ s/CT/7/g;
    $value =~ s/CA/8/g;
    $value =~ s/CG/9/g;
    $value =~ s/TA/Z/g;
    $value =~ s/TC/U/g;
    $value =~ s/TG/I/g;
    $value =~ s/GA/O/g;
    $value =~ s/GC/P/g;
    $value =~ s/GT/Q/g;
    return $value;
}
sub decrypt
{
    my @value = @_;
    my $value = $value[0];
    $value =~ s/Q/GT/g;
    $value =~ s/P/GC/g;
    $value =~ s/O/GA/g;
    $value =~ s/I/TG/g;
    $value =~ s/U/TC/g;
    $value =~ s/Z/TA/g;
    $value =~ s/9/CG/g;
    $value =~ s/8/CA/g;
    $value =~ s/7/CT/g;
    $value =~ s/6/AT/g;
    $value =~ s/5/AG/g;
    $value =~ s/4/AC/g;
    $value =~ s/3/GG/g;
    $value =~ s/2/TT/g;
    $value =~ s/1/CC/g;
    $value =~ s/0/AA/g;
    return $value;
}
sub IUPAC
{
    my @snps = @_;
    my $A = $snps[0];
    my $C = $snps[1];
    my $T = $snps[2];
    my $G = $snps[3];
    my $hp = $snps[4];
    my $iupac = "";
    my $most = "";
    my $h = "";
    if ($heteroplasmy ne "" && ($hp_seed_assemble eq "" || $no_hp_one_turn2 ne ""))
    {
        $h = $heteroplasmy*0.75*($A+$C+$T+$G);
        if (($A+$C+$T+$G) > 30 && $h <= 1)
        {
            $h = 1.1;
        }
        if ($hp > 0)
        {
            $h = $hp;
        }
    }
    else
    {
        $h = 0.07*($A+$C+$T+$G);
    }
    if ($A > $C && $A > $T && $A > $G)
    {
        $most = $A;
    }
    elsif ($C > $A && $C > $T && $C > $G)
    {
        $most = $C;
    }
    elsif ($T > $C && $T > $A && $T > $G)
    {
        $most = $T;
    }
    elsif ($G > $A && $G > $T && $G > $C)
    {
        $most = $G;
    }
    
    if ($A > $h && $C <= $h && $T <= $h && $G <= $h)
    {
        $iupac = "A";
    }
    elsif ($C > $h && $A <= $h && $T <= $h && $G <= $h)
    {
        $iupac = "C";
    }
    elsif ($T > $h && $C <= $h && $A <= $h && $G <= $h)
    {
        $iupac = "T";
    }
    elsif ($G > $h && $C <= $h && $T <= $h && $A <= $h)
    {
        $iupac = "G";
    }
    elsif ($A > $h && $C > $h && $T <= $h && $G <= $h)
    {
        $iupac = "M";
    }
    elsif ($A > $h && $G > $h && $T <= $h && $C <= $h)
    {
        $iupac = "R"; 
    }
    elsif ($A > $h && $T > $h && $G <= $h && $C <= $h)
    {
        $iupac = "W"; 
    }
    elsif ($C > $h && $G > $h && $A <= $h && $T <= $h)
    {
        $iupac = "S"; 
    }
    elsif ($C > $h && $T > $h && $A <= $h && $G <= $h)
    {
        $iupac = "Y"; 
    }
    elsif ($G > $h && $T > $h && $A <= $h && $C <= $h)
    {
        $iupac = "K"; 
    }
    elsif ($A > $h && $C > $h && $G > $h && $T <= $h)
    {
        $iupac = "V"; 
    }
    elsif ($A > $h && $C > $h && $T > $h && $G <= $h)
    {
        $iupac = "H"; 
    }
    elsif ($A > $h && $G > $h && $T > $h && $C <= $h)
    {
        $iupac = "D"; 
    }
    elsif ($C > $h && $G > $h && $T > $h && $A <= $h)
    {
        $iupac = "B"; 
    }
    else
    {
        $iupac = "N"; 
    }
    return ($iupac, $most);
}
sub IUPAC_reverse
{
    my @snps = @_;
    my $iupac = $snps[0];
    my @nucs;
    my @nucs2;
    my $nuc_alt;

    if ($iupac eq "A")
    {
        push @nucs, ('1');
        push @nucs2, ("A");
        $nuc_alt = "A";
    }
    elsif ($iupac eq "C")
    {
        push @nucs, ('2');
        push @nucs2, ("C");
        $nuc_alt = "C";
    }
    elsif ($iupac eq "T")
    {
        push @nucs, ('3');
        push @nucs2, ("T");
        $nuc_alt = "T";
    }
    elsif ($iupac eq "G")
    {
        push @nucs, ('4');
        push @nucs2, ("G");
        $nuc_alt = "G";
    }
    elsif ($iupac eq "M")
    {
        push @nucs, ('1','2');
        push @nucs2, ("A","C");
        $nuc_alt = "A,C";
    }
    elsif ($iupac eq "R")
    {
        push @nucs, ('1','4');
        push @nucs2, ("A","G");
        $nuc_alt = "A,G";
    }
    elsif ($iupac eq "W")
    {
        push @nucs, ('1','3');
        push @nucs2, ("A","T");
        $nuc_alt = "A,T";
    }
    elsif ($iupac eq "S")
    {
        push @nucs, ('4','2');
        push @nucs2, ("G","C");
        $nuc_alt = "G,C";
    }
    elsif ($iupac eq "Y")
    {
        push @nucs, ('3','2');
        push @nucs2, ("T","C");
        $nuc_alt = "T,C";
    }
    elsif ($iupac eq "K")
    {
        push @nucs, ('3','4');
        push @nucs2, ("T","G");
        $nuc_alt = "T,G";
    }
    elsif ($iupac eq "V")
    {
        push @nucs, ('1','2','4');
        push @nucs2, ("A","C","G");
        $nuc_alt = "A,C,G";
    }
    elsif ($iupac eq "H")
    {
        push @nucs, ('1','2','3');
        push @nucs2, ("A","C","T");
        $nuc_alt = "A,C,T";
    }
    elsif ($iupac eq "D")
    {
        push @nucs, ('1','3','4');
        push @nucs2, ("A","T","G");
        $nuc_alt = "A,T,G";
    }
    elsif ($iupac eq "B")
    {
        push @nucs, ('3','2','4');
        push @nucs2, ("T","C","G");
        $nuc_alt = "T,C,G";
    }
    elsif ($iupac eq "N")
    {
        push @nucs, ('1','2','3','4');
        push @nucs2, ("A","C","T","G");
        $nuc_alt = "A,C,T,G";
    }
    return ($nuc_alt, \@nucs);
}
sub correct
{
    my @str = @_;
    my $read_correct = $str[0];
    my %rep_pairs = %{$str[1]};
    my $hp = $str[2];
    my $cc = '0';
    my $rep = "";
    
    if (keys %rep_pairs > 1)
    {
        $rep = "yes";
        if ($y > $startprint2)
        {
        }
    }
    $cc = '0';
    my %read_part;
    my %read_part_reverse;
    my %read_matches;
    my @read_matches;
    undef %read_part;
    undef %read_part_reverse;
    undef %read_matches;
    undef @read_matches;
    if ($y > $startprint2)
    {
        print OUTPUT5 $read_correct."\n";
    }
    while ($cc < (length($read_correct)/2)-$overlap+($overlap/2))
    {
        my $read_part = substr $read_correct, $cc, $overlap;
        $read_part =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
        if ($hp eq "")
        {
            %read_part = build_partial3b $read_part;
        }
        else
        {
            %read_part = build_partial2b $read_part;
        }
        foreach my $read_part2 (keys %read_part)
        {
            if (exists($hash2b{$read_part2}))
            {
                my $id_part = $hash2b{$read_part2};
                $id_part = substr $id_part, 1;
                my @id_part = split /,/,$id_part;
                
                foreach my $id_part2 (@id_part)
                {                    
                    my $id_part2_end = substr $id_part2, -1 , 1, "";
      
                    if (exists($hash{$id_part2}))
                    {
                        my @id_part2_tmp = split /,/,$hash{$id_part2};
                        my $id_part2_tmp_new;

                        if ($id_part2_end eq "1")
                        {
                            $id_part2_tmp_new = $id_part2_tmp[0];
                        }
                        elsif ($id_part2_end eq "2")
                        {
                            $id_part2_tmp_new = $id_part2_tmp[1];
                        }
                        if ($use_quality ne "")
                        {
                            $id_part2_tmp_new =~ tr/1|2|3|4/N/;
                        }
                        if ($encrypt eq "yes")
                        {
                            $id_part2_tmp_new = decrypt $id_part2_tmp_new;
                        }
                        my $id_part2_tmp_new3 = substr $id_part2_tmp_new,0, length($id_part2_tmp_new)- $cc+$left;                          
                        while (length($id_part2_tmp_new3) < length($id_part2_tmp_new))
                        {
                            $id_part2_tmp_new3 = "N".$id_part2_tmp_new3;
                        }
                        if ($cc < $left)
                        {
                            $id_part2_tmp_new3 = substr $id_part2_tmp_new,$left-$cc, length($id_part2_tmp_new)- $cc+$left;
                        }                        
                        $read_matches{$id_part2_tmp_new3} = $cc;
                        push @read_matches, $id_part2_tmp_new3;
                    }
                }
            }
        }
        my $read_part_d = $read_part;
                                
        $read_part_d =~ tr/ATCG/TAGC/;
        my $read_part_reverse = reverse($read_part_d);
        if ($hp eq "")
        {
            %read_part_reverse = build_partial3b $read_part_reverse;
        }
        else
        {
            %read_part_reverse = build_partial2b $read_part_reverse;
        }
        
        foreach my $read_part2 (keys %read_part_reverse)
        {
            if (exists($hash2c{$read_part2}))
            {
                my $id_part = $hash2c{$read_part2};
                $id_part = substr $id_part, 1;
                my @id_part = split /,/,$id_part;
                
                foreach my $id_part2 (@id_part)
                {
                    my $id_part2_end = substr $id_part2, -1 , 1, "";
                    if (exists($hash{$id_part2}))
                    {
                        my @id_part2_tmp = split /,/,$hash{$id_part2};
                        my $id_part2_tmp_new;

                        if ($id_part2_end eq "1")
                        {
                            $id_part2_tmp_new = $id_part2_tmp[0];
                        }
                        elsif ($id_part2_end eq "2")
                        {
                            $id_part2_tmp_new = $id_part2_tmp[1];
                        }
                        if ($use_quality ne "")
                        {
                            $id_part2_tmp_new =~ tr/1|2|3|4/N/;
                        }
                        if ($encrypt eq "yes")
                        {
                            $id_part2_tmp_new = decrypt $id_part2_tmp_new;
                        } 
                        my $id_part2_tmp_new2b = $id_part2_tmp_new;
                        $id_part2_tmp_new2b =~ tr/ATCG/TAGC/;
                        $id_part2_tmp_new = reverse($id_part2_tmp_new2b);
                        my $id_part2_tmp_new3 = substr $id_part2_tmp_new,0, length($id_part2_tmp_new)- $cc+$right;
                        while (length($id_part2_tmp_new3) < length($id_part2_tmp_new))
                        {
                            $id_part2_tmp_new3 = "N".$id_part2_tmp_new3;
                        }
                        if ($cc < $right)
                        {
                            $id_part2_tmp_new3 = substr $id_part2_tmp_new,$right-$cc, length($id_part2_tmp_new)- $cc+$right;
                        }                        
                        $read_matches{$id_part2_tmp_new3} = $cc;
                        push @read_matches, $id_part2_tmp_new3;
                    }
                }
            }
        }                                                                
        $cc++;
    }
    $cc -= ($overlap/2);
    while ($cc < length($read_correct)-$overlap)
    {
        my $read_part = substr $read_correct, $cc, $overlap;
        $read_part =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
        if ($hp eq "")
        {
            %read_part = build_partial3b $read_part;
        }
        else
        {
            %read_part = build_partial2b $read_part;
        }
        
        foreach my $read_part2 (keys %read_part)
        {
            if (exists($hash2c{$read_part2}))
            {
                my $id_part = $hash2c{$read_part2};
                $id_part = substr $id_part, 1;
                my @id_part = split /,/,$id_part;
                
                foreach my $id_part2 (@id_part)
                {
                    my $id_part2_end = substr $id_part2, -1 , 1, "";
                    if (exists($hash{$id_part2}))
                    {
                        my @id_part2_tmp = split /,/,$hash{$id_part2};
                        my $id_part2_tmp_new;

                        if ($id_part2_end eq "1")
                        {
                            $id_part2_tmp_new = $id_part2_tmp[0];
                        }
                        elsif ($id_part2_end eq "2")
                        {
                            $id_part2_tmp_new = $id_part2_tmp[1];
                        }
                        if ($use_quality ne "")
                        {
                            $id_part2_tmp_new =~ tr/1|2|3|4/N/;
                        }
                        if ($encrypt eq "yes")
                        {
                            $id_part2_tmp_new = decrypt $id_part2_tmp_new;
                        } 
                        my $id_part2_tmp_new3 = substr $id_part2_tmp_new, -$cc -$overlap-$right;
                        if (length($id_part2_tmp_new)-$cc-$overlap < $right)
                        {
                            $id_part2_tmp_new3 = substr $id_part2_tmp_new, -$cc -$overlap-$right, -($right-length($id_part2_tmp_new)+$cc+$overlap);
                            while (length($id_part2_tmp_new3) < length($id_part2_tmp_new))
                            {
                                $id_part2_tmp_new3 = "N".$id_part2_tmp_new3;
                            }
                        }
                        $read_matches{$id_part2_tmp_new3} = $cc;
                        push @read_matches, $id_part2_tmp_new3;
                    }
                }
            }
        }
        my $read_part_d = $read_part;
                                
        $read_part_d =~ tr/ATCG/TAGC/;
        my $read_part_reverse = reverse($read_part_d);
        if ($hp eq "")
        {
            %read_part_reverse = build_partial3b $read_part_reverse;
        }
        else
        {
            %read_part_reverse = build_partial2b $read_part_reverse;
        }        
        
        foreach my $read_part2 (keys %read_part_reverse)
        {
            if (exists($hash2b{$read_part2}))
            {
                my $id_part = $hash2b{$read_part2};
                $id_part = substr $id_part, 1;
                my @id_part = split /,/,$id_part;
                foreach my $id_part2 (@id_part)
                {
                    my $id_part2_end = substr $id_part2, -1 , 1, "";
                    if (exists($hash{$id_part2}))
                    {
                        my @id_part2_tmp = split /,/,$hash{$id_part2};
                        my $id_part2_tmp_new;
                        
                        if ($id_part2_end eq "1")
                        {
                            $id_part2_tmp_new = $id_part2_tmp[0];
                        }
                        elsif ($id_part2_end eq "2")
                        {
                            $id_part2_tmp_new = $id_part2_tmp[1];
                        }
                        if ($use_quality ne "")
                        {
                            $id_part2_tmp_new =~ tr/1|2|3|4/N/;
                        }
                        if ($encrypt eq "yes")
                        {
                            $id_part2_tmp_new = decrypt $id_part2_tmp_new;
                        }
                        my $id_part2_tmp_new2b = $id_part2_tmp_new;
                        $id_part2_tmp_new2b =~ tr/ATCG/TAGC/;
                        $id_part2_tmp_new = reverse($id_part2_tmp_new2b);
                        
                        my $id_part2_tmp_new3 = substr $id_part2_tmp_new, -$cc -$overlap-$left;
                        
                        if (length($id_part2_tmp_new)-$cc-$overlap < $left)
                        {
                            $id_part2_tmp_new3 = substr $id_part2_tmp_new, -$cc -$overlap-$left, -($left-length($id_part2_tmp_new)+$cc+$overlap);
                            while (length($id_part2_tmp_new3) < length($id_part2_tmp_new))
                            {
                                $id_part2_tmp_new3 = "N".$id_part2_tmp_new3;
                            }
                        }
                        $read_matches{$id_part2_tmp_new3} = $cc;
                        push @read_matches, $id_part2_tmp_new3;
                    }
                }
            }
        }                  
        $cc++;
    }
    my $count_cor = '0';
    $count_cor++ for (keys %read_matches);
    if ($count_cor < 4)
    {
        if ($y > $startprint2)
        {
            print OUTPUT5 "\nBAD_READ1\n";
        }
        if ($y eq '1')
        {
            $bad_read = "yes";
            goto FIRST_SEED;
        }
        else
        {
            goto CORRECT_END;
        }
    }
    
    my $corrected_read = "";
    my @charso = split //, $read_correct;
    my @read_matches2;
    undef @read_matches2;
    my $end_matches = '0';
    foreach my $extensions (@read_matches)
    {
        my $l = '0';
        my @chars = split //, $extensions;
        my $matching = '0';
        while ($l < length($read_correct))
        {
            if ($chars[$l] eq $charso[$l])
            {
                $matching++;
            }
            $l++;
        }
        my $count_N = $extensions =~ tr/N/N/;
        my $gg = '0.95';
        if ($hp ne "")
        {
            $gg = '0.91';
        }
        if ($matching > $gg*(length($read_correct)-$count_N) && $count_N < length($read_correct))
        {
            push @read_matches2, $extensions;
            if (length($extensions) >= length($read_correct)-1)
            {
                $end_matches++;
            }
        }
    }
    
    my $count_cor2 = '0';
    $count_cor2++ for (@read_matches2);
    if ($count_cor2 < 4 || $end_matches < 4)
    {
        if ($y > $startprint2)
        {
            print OUTPUT5 "\nBAD_READ2\n";
        }
        if ($y eq '1')
        {
            $bad_read = "yes";
            goto FIRST_SEED;
        }
        else
        {
            goto CORRECT_END;
        }
    }
    
    my $l = '0';
    while ($l < length($read_correct))
    {
        my $A = '0';
        my $C = '0';
        my $T = '0';
        my $G = '0';
        
POINT:  foreach my $extensions (@read_matches2)
        {                                
            my @chars = split //, $extensions;
            if ($heteroplasmy ne "" && $l > 0 && ($chars[$l-1] eq "N" || $chars[$l-1] eq "N"))
            {
                next POINT;
            }
            if ($chars[$l] eq "A")
            {
                $A++;
            }
            elsif ($chars[$l] eq "C")
            {
                $C++;
            }
            elsif ($chars[$l] eq "T")
            {
                $T++;
            }
            elsif ($chars[$l] eq "G")
            {
                $G++;
            }
            if (($A + $C + $T + $G) > 500)
            {
                last POINT;
            }
        }
        my $tt = '3';

        if ($hp ne "")
        {
            $tt = $hp*($A + $C + $T + $G);
        }
        if ($A >= ($C + $T + $G)*1.8 && (($C <= $tt && $T <= $tt && $G <= $tt) || $hp eq "") && $A > 2)
        {
            $corrected_read = $corrected_read."A";
        }
        elsif ($C >= ($A + $T + $G)*1.8 && (($A <= $tt && $T <= $tt && $G <= $tt) || $hp eq "") && $C > 2)
        {
            $corrected_read = $corrected_read."C";
        }
        elsif ($T >= ($A + $C + $G)*1.8 && (($C <= $tt && $A <= $tt && $G <= $tt) || $hp eq "") && $T > 2)
        {
            $corrected_read = $corrected_read."T";
        }
        elsif ($G >= ($C + $T + $A)*1.8 && (($C <= $tt && $T <= $tt && $A <= $tt) || $hp eq "") && $G > 2)
        {
            $corrected_read = $corrected_read."G";
        }
        elsif (length($corrected_read) > 15 && $rep eq "yes")
        {
            my $last_15 = substr $corrected_read, -15;
            my $count = '0';
            my $count2 = '0';
            foreach my $rep_pair (keys %rep_pairs)
            {
                my $check_rep_pair = $rep_pair =~ s/$last_15/$last_15/g;
                if ($check_rep_pair eq '1')
                {
                    if ($rep_pair =~ m/.*$last_15(.).*/)
                    {
                        my $nuc = $1;
                        if ($charso[$l] eq $nuc)
                        {
                            $count++;
                        }
                        else
                        {
                            $count2++;
                        }
                    }
                }
            }
            if ($count > 2 && $count2 eq '0')
            {
                $corrected_read = $corrected_read.$charso[$l];
            }
            else
            {
                $corrected_read = $corrected_read.".";
            }             
        }
        else
        {
            $corrected_read = $corrected_read.".";
        }
        $l++;
    }
    if ($y > $startprint2)
    {
        print OUTPUT5 $corrected_read." CORRECTED READ\n";
    }
    my $dot_bad = $corrected_read =~ tr/\./\./;
    my $ff = '3';
    if ($hp ne "")
    {
        $ff = length($corrected_read)/10;
    }
    while ($dot_bad > $ff && length($corrected_read) > ($overlap*2)+10)
    {
        my $corrected_read_tmp = substr $corrected_read, 5, -5;
        $corrected_read = $corrected_read_tmp;
        $dot_bad = $corrected_read =~ tr/\./\./;
        $ff = length($corrected_read)/10;
    }
    if ($dot_bad > $ff)
    {
        if ($y > $startprint2)
        {
            print OUTPUT5 "\nBAD_READ3\n";
        }
        if ($y eq '1')
        {
            $bad_read = "yes2";
            goto FIRST_SEED;
        }
    }
    
    $read_correct = $corrected_read;
    if ($y eq '1')
    {
        $read = $read_correct;
    }

    $seeds_check{$id} = undef; 
    $bad_read = "";
    return $read_correct;
CORRECT_END:
}
sub check_deletion
{
    my @str = @_;
    my $best_extension1 = $str[0];
    my $best_extension2 = $str[1];
    my $best_extension_old1_tmp = $str[2];
    my $best_extension_old2_tmp = $str[3];
    my $ref_checking = $str[4];
    my $back = $str[5];
    my $hp_homo = $str[6];
    my $best_extension_tmp;
    my $one_or_two;
    my $shorter = '0';
    
    my @short;
    my @long;
    undef @short;
    undef @long;
    my $p = '-1';
    my $amatch = '0';
    my $nomatch = '0';
    my $best_extension_short = "";
    my $best_extension_long = "";
    my $best_amatch = '0';
    my $best_nomatch = '0';
    my $best_p = '0';
    my $best_amatch_short = '0';
    my $best_nomatch_short = '0';
    my $best_p_short = '0';
    my $finish;
    
    if ($y > $startprint2)
    {
        print OUTPUT5 "CHECK_DELETION\n";
    }
    my $best_extension1_tmp;
    my $best_extension2_tmp;
    if (length($best_extension_old1_tmp) > length($best_extension1))
    {
        $best_extension1_tmp = $best_extension_old1_tmp;
    }
    else
    {
        $best_extension1_tmp = $best_extension1;
    }
    if (length($best_extension_old2_tmp) > length($best_extension2))
    {
        $best_extension2_tmp = $best_extension_old2_tmp;
    }
    else
    {
        $best_extension2_tmp = $best_extension2;
    }
    if (length($best_extension1_tmp) >= length($best_extension2_tmp))
    {
        $best_extension_short = $best_extension2_tmp;
        $best_extension_long = $best_extension1_tmp;
        $best_extension_short =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
        $best_extension_long =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
        @short = split //, $best_extension_short;
        @long = split //, $best_extension_long;
    }
    elsif (length($best_extension2_tmp) > length($best_extension1_tmp))
    { 
        $best_extension_short = $best_extension1_tmp;
        $best_extension_long = $best_extension2_tmp;
        $best_extension_short =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
        $best_extension_long =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
        @short = split //, $best_extension_short;
        @long = split //, $best_extension_long;
    }
CHAR0:
    while (($p < length($best_extension_short) || $p < 15) && ($p < 25 || $ref_checking eq "yes"))
    {
        my $i = '1';
        $amatch = '0';
        $nomatch = '0';
CHAR:   while ($i < @short-$p)
        {
            if ($short[$i+$p] eq $long[$i-1])
            {
                $amatch++;   
            }
            elsif ($short[$i+$p] eq ".")
            {
                $nomatch += 0.5;
            }
            elsif ($i > 10 && $nomatch eq '0' && $ref_checking ne "yes")
            {                            
                last CHAR;
            }
            else
            {                            
                $nomatch++;
            }
            $i++;
        }
        $p++;

        if (($amatch > ($nomatch*6) || ($ref_checking eq "yes" && $amatch >= ($nomatch*2))) && (($amatch > 2 && $amatch > $p) || ($amatch > 1 && $nomatch eq '0' && $p < 0.75*($amatch+$p)) || ($amatch > 7 && $p < 0.75*($amatch+$p))))
        {
            if ($amatch-$nomatch > $best_amatch-$best_nomatch && $finish eq "")
            {
                $best_amatch = $amatch;
                $best_nomatch = $nomatch;
                $best_p = $p;
                $best_amatch_short = $best_amatch;
                $best_nomatch_short = $best_nomatch;
                $best_p_short = $best_p;
                if ($y > $startprint2)
                {
                    print OUTPUT5 $p." DELETION_LONG\n";
                }
                goto CHAR0;
            }
            elsif ($finish eq "")
            {
                goto CHAR0;
            }
                     
            my $indel = substr $best_extension_short, 0, $p;
            if ($back eq "back")
            {
                $indel =~ s/A/*A/g;
                $indel =~ s/T/*T/g;
                $indel =~ s/G/*G/g;
                $indel =~ s/C/*C/g;
                $indel =~ s/\./*\./g;
            }
            else
            {
                $indel =~ s/A/A*/g;
                $indel =~ s/T/T*/g;
                $indel =~ s/G/G*/g;
                $indel =~ s/C/C*/g;
                $indel =~ s/\./\.*/g;
            }
          
            my $after_indel;
            if ($nomatch > 0)
            {
                my $after_indel1 = substr $best_extension_short, $p;
                my @chars3 = split //, $after_indel1;
                my $f = '0';
           
INDEL0:         while ($f < @chars3)
                {
                    if ($chars3[$f] eq $long[$f])
                    {
                        $after_indel .= $chars3[$f];
                    }
                    elsif ($f < 20)
                    {
                        $after_indel .= ".";
                    }
                    else
                    {
                        if ($finish eq "yes")
                        {
                            $shorter = length($best_extension_short) -$f -$p;
                        }
                        last INDEL0;
                    }
                    $f++;
                }
            }
            else
            {
                my $after_indel1 = substr $best_extension_short, $p, $p+$i-1;
                my @chars3 = split //, $after_indel1;
                my $f = '0';
                
INDEL1:         while ($f < @chars3)
                {
                    if ($chars3[$f] eq $long[$f])
                    {
                        $after_indel .= $chars3[$f];
                    }
                    elsif ($f < 20 && ($chars3[$f] eq "." || $long[$f] eq '.'))
                    {
                        $after_indel .= ".";
                    }
                    else
                    {
                        last INDEL1;
                    }
                    $f++;
                }
            }
            $best_extension_tmp = $indel.$after_indel;
            if ($after_indel eq "")
            {
                $best_extension_tmp = "";
            }
            $one_or_two = "one";
            last CHAR0;
        }  
    }
    if ($best_amatch ne '0' && $finish eq "")
    {
        $p = $best_p-1;
        $finish = "yes";
        goto CHAR0;
    }
    $p = '0';
    $best_amatch = '0';
    $best_nomatch = '0';
CHAR1:while (($p < (length($best_extension_long)-length($best_extension_short)) || $p < 15) && ($p < 25 || $ref_checking eq "yes"))
    {
        my $i = '1';
        $amatch = '0';
        $nomatch = '0';
CHAR2:  while ($i <= @short && $i < @long-$p)
        {
            if ($short[$i-1] eq $long[$i+$p])
            {
                $amatch++;
            }
            elsif ($short[$i-1] eq ".")
            {
                $nomatch += 0.5;
            }
            elsif ($i > 10 && $nomatch eq '0' && $ref_checking ne "yes")
            {                            
                last CHAR2;
            }
            else
            {
                $nomatch++;
            }
            $i++;
        }
        $p++;

        if ($amatch-$nomatch > $best_amatch_short-$best_nomatch_short && ($amatch > ($nomatch*6) || ($ref_checking eq "yes" && $amatch >= ($nomatch*2))) && (($amatch > 2 && $amatch > $p) || ($amatch > 7 && $p < 0.75*($amatch+$p)) || ($amatch > 1 && $nomatch eq '0'  && $p < 0.75*($amatch+$p))))
        {
            if ($amatch-$nomatch > $best_amatch-$best_nomatch && $finish ne "yes2")
            {
                $best_amatch = $amatch;
                $best_p = $p;
                if ($y > $startprint2)
                {
                    print OUTPUT5 $p." DELETION_SHORT\n";
                }
                next CHAR1;
            }
            elsif ($finish ne "yes2")
            {
                next CHAR1;
            }
           
            my $indel = substr $best_extension_long, 0, $p;
            if ($back eq "back")
            {
                $indel =~ s/A/*A/g;
                $indel =~ s/T/*T/g;
                $indel =~ s/G/*G/g;
                $indel =~ s/C/*C/g;
                $indel =~ s/\./*\./g;
            }
            else
            {
                $indel =~ s/A/A*/g;
                $indel =~ s/T/T*/g;
                $indel =~ s/G/G*/g;
                $indel =~ s/C/C*/g;
                $indel =~ s/\./\.*/g;
            }
            
            my $after_indel;
            if ($nomatch > 0)
            {
                my $after_indel1 = substr $best_extension_long, $p;
                my @chars3 = split //, $after_indel1;
                my $f = '0';
                
INDEL2:         while ($f < @chars3 && $f < length($best_extension_short))
                {
                    if ($chars3[$f] eq $short[$f])
                    {
                        $after_indel .= $chars3[$f];
                    }
                    elsif ($f < 20)
                    {
                        $after_indel .= ".";
                    }
                    else
                    {
                        if ($finish eq "yes2")
                        {
                            $shorter = length($best_extension_short) - $f;
                        }
                        last INDEL2;
                    }
                    $f++;
                }
            }
            else
            {
                my $after_indel1 = substr $best_extension_long, $p, $p+$i-1;;
                my @chars3 = split //, $after_indel1;
                my $f = '0';
                
INDEL3:         while ($f < @chars3)
                {
                    if ($chars3[$f] eq $short[$f])
                    {
                        $after_indel .= $chars3[$f];
                    }
                    elsif ($f < 20 && ($chars3[$f] eq "." || $long[$f] eq '.'))
                    {
                        $after_indel .= ".";
                    }
                    else
                    {
                        last INDEL3;
                    }
                    $f++;
                }
            }
            $best_extension_tmp = $indel.$after_indel;
            
            if ($after_indel eq "")
            {
                $best_extension_tmp = "";
            }
            $one_or_two = "two";
            goto END_INDEL;
        }  
    }
    if ($best_amatch ne '0' && $finish ne "yes2")
    {
        $p = $best_p-1;
        $finish = "yes2";
        goto CHAR1;
    }
END_INDEL:
    return ($best_extension_tmp, $one_or_two, $shorter, $best_p);
}
sub mismatch
{
    my @str = @_;
    my %extensions = %{$str[0]};
    my %list = %{$str[1]};
    my $best_extension = $str[2];
    $best_extension =~ tr/K|R|Y|S|W|M|B|D|H|V/N/;
    undef %remove_extension_mismatch_tmp;
    my @chars_best = split //, $best_extension;
MISMATCH1:foreach my $extensions_id (keys %extensions)
    {
        my $extensions = $extensions{$extensions_id};
        if (exists($list{$extensions}) || length($extensions) < 4)
        {
            next MISMATCH1;
        }
        if (exists($remove_extension_mismatch_tmp{$extensions}))
        {
            next MISMATCH1;
        }
        my @chars = split //, $extensions;
        my $d = '0';
        my $mismatch = '0';

MISMATCH2:while ($d < length($best_extension))
        {
            if ($chars[$d] eq $chars_best[$d] || $chars_best[$d] eq "N" || $chars[$d] eq "N" || ($chars[$d] eq "1" && $chars_best[$d] eq "A")
               || ($chars[$d] eq "2" && $chars_best[$d] eq "C") || ($chars[$d] eq "3" && $chars_best[$d] eq "T") || ($chars[$d] eq "4" && $chars_best[$d] eq "G"))
            {
            }
            elsif ($chars_best[$d] eq "" || $chars[$d] eq "")
            {
               last MISMATCH2;
            }
            elsif ($mismatch < 3 || $mismatch < $d/5)
            {
                $mismatch++;
            }
            else
            {
                if ($hp_back ne "")
                {
                }
                $remove_extension_mismatch_tmp{$extensions} = $d;
                last MISMATCH2;
            }
            $d++;
        }
    }
}
sub check_HP_pos
{
    my $check = "";
    my @check = @_;
    my $ff_tmp = $check[0];
    my $pos = $check[1];
    my $pos_back = $check[2];
    my $match_pair_tmp = $check[3];
    my $ln = $check[4];
    my $one = $pos-($insert_size*2);
    if ($one < -$pos_back)
    {
        $one = -$pos_back;
    }
    foreach my $pos_tmp (keys %SNPs)
    {
        my $correction_0 = '0';
        if ($pos_tmp > 0)
        {
             $correction_0 = '-1';
        }
               
        if ($pos_tmp > $one + $ff_tmp -10 && $pos_tmp < $one + $ff_tmp -10 +length($match_pair_tmp))
        {
            my $hp_SNP_read = substr $match_pair_tmp, $pos_tmp-($one + $ff_tmp -10)+$correction_0, 1;
            $hp_SNP_read =~ tr/1234/ACTG/;
            if ($containX_short_end2 > 0 || $containX_short_start2 > 0)
            {
            }
            if ($hp_SNP_read eq $SNPs{$pos_tmp})
            {
                $check = "yes";
                $hp_SNP_links{$pos_tmp} .= exists $hp_SNP_links{$pos_tmp} ? ",$ln" : $ln;
            }
            else
            {
                $check = "no";
                delete $accepted_SNPs{$ln};
                return $check;
            }
        }   
    }
    if ($check eq "yes")
    {
        $accepted_SNPs_pair{$ln} = undef;
    }
    return $check;
}
sub check_HP_pos_back
{
    my $check = "";
    my @check = @_;
    my $ff_tmp = $check[0];
    my $pos = $check[1];
    my $pos_back = $check[2];
    my $match_pair_tmp = $check[3];
    my $ln = $check[4];

    foreach my $pos_tmp (keys %SNPs)
    {
        my $correction_0 = '0';
        if ($pos_tmp > 0)
        {
             $correction_0 = '-1';
        }
        if ($pos_tmp >= -$pos_back+$ff_tmp-($right+5) && $pos_tmp < -$pos_back+$ff_tmp-($right+5)+length($match_pair_tmp))
        {
            my $hp_SNP_read = substr $match_pair_tmp, $pos_tmp-(-$pos_back+$ff_tmp-($right+5))+$correction_0, 1;
            $hp_SNP_read =~ tr/1234ACTG/TGACTGAC/;
            if ($containX_short_end2 > 0 || $containX_short_start2 > 0)
            {
            }
            my $k = $pos_tmp-(-$pos_back+$ff_tmp-($right+5))+$correction_0;
            if ($hp_SNP_read eq $SNPs{$pos_tmp})
            {
                $check = "yes";
                $hp_SNP_links_back{$pos_tmp} .= exists $hp_SNP_links_back{$pos_tmp} ? ",$ln" : $ln;
            }
            else
            {
                $check = "no";
                delete $accepted_SNPs_back{$ln};
                return $check;
            }
        }   
    }
    if ($check eq "yes")
    {
        $accepted_SNPs_pair_back{$ln} = undef;
    }
    return $check;
}
sub AT_rich_test
{
    my @str = @_;
    my $region_to_check = $str[0];
    my $extra = $str[1];
    my $AT_rich = "";

    my $A_rich_test = $region_to_check =~ tr/A/A/;
    my $T_rich_test = $region_to_check =~ tr/T/T/;
    my $G_rich_test = $region_to_check =~ tr/G/G/;
    my $C_rich_test = $region_to_check =~ tr/C/C/;
    my $AT_rich_test = $region_to_check =~ s/AT/AT/g;
    my $dot_rich_test3 = $region_to_check =~ tr/\./\./;
    
    if ($A_rich_test+$dot_rich_test3 > length($region_to_check)-$extra || $T_rich_test+$dot_rich_test3 > length($region_to_check)-$extra || $G_rich_test+$dot_rich_test3 > length($region_to_check)-$extra || $C_rich_test+$dot_rich_test3 > length($region_to_check)-$extra || $AT_rich_test+($dot_rich_test3/2) > (length($region_to_check)-$extra-4)/2)
    {
        $AT_rich = "yes";
    }
    return $AT_rich;
}
sub contig_start
{
    my @str = @_;
    my $read_tmp = $str[0];
    my $start_point = '800';
    my $check_repetitive = '3';
                                                                
    while ($check_repetitive > 2)
    {
        my $repetitive = substr $read_tmp, $start_point, 15;
        $repetitive =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
        my $read_short_area = substr $read_tmp, $start_point -170, 340;
        $check_repetitive = $read_short_area =~ s/$repetitive/$repetitive/g;
        if ($check_repetitive > 2)
        {
            $start_point += 20;
            if ($y > $startprint2)
            {
                print OUTPUT5 "DETECT_REPETITIVE_IN_START_SEQUENCE\n";
            }
        } 
    }
    $first_contig_start = substr $read_tmp, $start_point, $overlap;
    $first_contig_start =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

    my $check_start = $first_contig_start =~ tr/\./\./;
    while ($check_start > 0)
    {
        $start_point += 10;
        $first_contig_start = substr $read_tmp, $start_point, $overlap;
        $check_start = $first_contig_start =~ tr/\./\./;
    }
    if ($y > $startprint2)
    {
        print OUTPUT5 $first_contig_start." CONTIG_START3\n";
    }
    foreach my $seedie (keys %seed)
    {
        my $seedie_part = substr $seed{$seedie}, 0, 1000;
        my $check_seedie = $seedie_part =~ s/$first_contig_start/$first_contig_start/;
        if ($check_seedie > 0)
        {
            delete $seed{$seedie};
        }
    }
}
sub hp_select_best_ext
{
    my @str = @_;
    my $best_extension_tmp = $str[0];
    my %SNPs_tmp = %{$str[1]};
    my %linked_SNPs_tmp = %{$str[2]};
    my %linked_half_SNPs_tmp = %{$str[3]};
    my %not_linked_SNPs_tmp = %{$str[4]};
    my $position_tmp = $str[5];
    my $position_other_tmp = $str[6];
    my $pos_tmp = $str[7];
    my $pos_noSNP = $str[8];
    my $all_SNPs = "";
    my $all_SNPs2 = "";
    my $noSNPs_all = "";
    my $noSNPs_all2 = "";
    my $all_linked_SNPs = "";
    my $all_linked_half_SNPs = "";
    my $all_not_linked_SNPs = "";
    if ($pos_tmp ne "")
    {
        $not_linked_SNPs_tmp{$pos_tmp} = undef;
    }  
    foreach my $SNP_tmp (sort {$a <=> $b} keys %SNPs_tmp)
    {
        $all_SNPs .= ",".$SNP_tmp;
        $all_SNPs2 .= ",".$SNPs{$SNP_tmp};
    }
    foreach my $noSNP_tmp (sort {$a <=> $b} keys %noSNPs)
    {
        $noSNPs_all .= ",".$noSNP_tmp;
        $noSNPs_all2 .= ",".$noSNPs{$noSNP_tmp};
    }
    if ($pos_noSNP ne "")
    {
        my $nuc = substr $best_extension_tmp, -1, 1;
        $noSNPs_all .= ",".$pos_noSNP;
        $noSNPs_all2 .= ",".$nuc;
    }
    foreach my $linked_SNPs_tmp (sort {$a <=> $b} keys %linked_SNPs_tmp)
    {
        $all_linked_SNPs .= ",".$linked_SNPs_tmp;
    }
    foreach my $linked_half_SNPs_tmp (sort {$a <=> $b} keys %linked_half_SNPs_tmp)
    {
        $all_linked_half_SNPs .= ",".$linked_half_SNPs_tmp;
    }
    foreach my $not_linked_SNPs_tmp (sort {$a <=> $b} keys %not_linked_SNPs_tmp)
    {
        $all_not_linked_SNPs .= ",".$not_linked_SNPs_tmp;
    }   
    my $hp_pos_tmp = $position_tmp+length($best_extension_tmp);
    $hp_splits = "yes";
    $hp_splits{$id."+".$hp_pos_tmp} = $position_other_tmp."+".$read.$best_extension_tmp."+".$all_SNPs."+".$all_SNPs2."+".$all_linked_SNPs."+".$all_linked_half_SNPs."+".$all_not_linked_SNPs."+".$noSNPs_all."+".$noSNPs_all2;
}
sub SNR_ahead
{
    my @str = @_;
    my %extensions_tmp = %{$str[0]};
    my $skip = $str[1];
    my $back = $str[2];
    my $SNR_ahead = '0';
    my $SNR_ahead2 = '0';
    my %total;
    undef %total;
    my $total_tmp = keys %extensions_tmp;
    my $limit = 10;
    if ($total_tmp/2 < 10)
    {
        $limit = $total_tmp/2;
    }
    if ($total_tmp*0.07 > 10)
    {
        $limit = $total_tmp*0.07;
    }
    my $last3 = substr $read_end, -3;
    if ($back eq "yes")
    {
        $last3 = substr $read_start, 0, 3;
    }
AHEAD:foreach my $extension_id_tmp (keys %extensions_tmp)
    {
        my $extension_tmp = $extensions_tmp{$extension_id_tmp};
        if (length($extension_tmp) > 13)
        {
            my $first14 = substr $extension_tmp, $skip, 14;
            my $first17 = $last3.$first14;
            if ($skip > '0')
            {
                $first17 = substr $extension_tmp, $skip, 17;
            }
            my $A = $first17 =~ tr/1A/1A/;
            my $C = $first17 =~ tr/2C/2C/;
            my $T = $first17 =~ tr/3T/3T/;
            my $G = $first17 =~ tr/4G/4G/;
            my $N = $first17 =~ tr/N/N/;
            my $SNR_check_tmp = $first17 =~ s/AAAAAAAA|CCCCCCCC|GGGGGGGG|TTTTTTTT//;
            if ($A > 11 || $C > 11 || $T > 11 || $G > 11 || $SNR_check_tmp > 0)
            {
                $SNR_ahead2++;
                $total{'A'} = $A+$total{'A'};
                $total{'C'} = $C+$total{'C'};
                $total{'T'} = $T+$total{'T'};
                $total{'G'} = $A+$total{'G'};
                if ($SNR_ahead2 <= $limit)
                {
                    next AHEAD;
                }
            }
        }
        if (length($extension_tmp) > 8)
        {
            my $first9 = substr $extension_tmp, $skip, 9;
            my $first12 = $last3.$first9;
            if ($skip > '0')
            {
                $first12 = substr $extension_tmp, $skip, 12;
            }
            my $A = $first12 =~ tr/1A/1A/;
            my $C = $first12 =~ tr/2C/2C/;
            my $T = $first12 =~ tr/3T/3T/;
            my $G = $first12 =~ tr/4G/4G/;
            my $N = $first12 =~ tr/N/N/;
            if ($A > 8 || $C > 8 || $T > 8 || $G > 8)
            {
                $SNR_ahead++;
                $total{'A'} = $A+$total{'A'};
                $total{'C'} = $C+$total{'C'};
                $total{'T'} = $T+$total{'T'};
                $total{'G'} = $A+$total{'G'};
            }
            elsif ($N < 2)
            {
                $SNR_ahead--;
            }
        }
        if ($SNR_ahead2 > $limit || ($SNR_ahead > $limit && $SNR_ahead2 eq '0') || ($SNR_ahead < -$limit && $SNR_ahead2 eq '0'))
        {
            last AHEAD;
        }
    }
    if ($SNR_ahead > 7 || $SNR_ahead2 > 6)
    {
        $SNR_ahead = "yes";
        if ($SNR_ahead2 > 6)
        {
            $SNR_ahead = "yes2";
        }
        my $highest = '0';
        foreach my $total (keys %total)
        {
            if ($total{$total} > $highest)
            {
                $highest = $total{$total};
                if ($back eq "yes")
                {
                    $SNR_read_back_ahead = $total;
                }
                else
                {
                    $SNR_read_ahead = $total;
                }        
            }  
        }
        print OUTPUT5 $SNR_ahead." SNR_AHEAD\n";
    }
    else
    {
        $SNR_ahead = "";
    }
    return $SNR_ahead;
}
sub HP_SNP
{
    my @str = @_;
    my $match = $str[0];
    my $extension = $str[1];
    my $ln = $str[2];
    my $back = $str[3];
    my %SNPs_or_not;
    undef %SNPs_or_not;
    %SNPs_or_not = %SNPs;
    my $check = "";
    my $check_no_SNPs = "";
    
    my %merged_match1_tmp;
    my %merged_match2_tmp;
    undef %merged_match1_tmp;
    undef %merged_match2_tmp;
    my $position_tmp;
    
    my $pos1 = "";
    my $pos2 = "";
    my $hp_SNP_read_tmp = "";
    if ($back eq "back")
    {
        $pos1 = (-$position_back+(length($match)-length($extension)))+1;
        $pos2 = -$position_back-1;
        %merged_match1_tmp = %merged_match_back1;
        %merged_match2_tmp = %merged_match_back2;
        $position_tmp = $position_back;
        $hp_SNP_read_tmp = length($extension)+$position_tmp;
        
    }
    else
    {
        $pos1 = $position;
        $pos2 = ($position-length($match)+length($extension));
        %merged_match1_tmp = %merged_match1;
        %merged_match2_tmp = %merged_match2;
        $position_tmp = $position;
        $hp_SNP_read_tmp = -length($extension)-$position_tmp-1;
    }
    
HP_SNP:foreach my $pos_tmp (keys %SNPs_or_not)
    {             
        my $pos1_tmp = $pos1;
        if ($pos_tmp > 0 && $back eq "back")
        {
             $pos_tmp--;
        }
        if ($pos_tmp <= $pos1_tmp && $pos_tmp > $pos2)
        {
            if (exists($merged_match1_tmp{$ln}))
            {
                my $match_tmp = reverse($match);             
                my $hp_SNP_read = substr $match_tmp, $hp_SNP_read_tmp+$pos_tmp, 1;
                $hp_SNP_read =~ tr/ACTG1234/TGACTGAC/;
            if ($back ne "")
            {
            }
                if ($hp_SNP_read ne $SNPs_or_not{$pos_tmp})
                {
                    $check = "no";
                    last HP_SNP;
                }
                elsif ($hp_SNP_read eq $SNPs_or_not{$pos_tmp} && $check_no_SNPs eq "")
                {
                    $check = "yes";
                    $hp_SNP_links{$pos_tmp} .= exists $hp_SNP_links{$pos_tmp} ? ",$ln" : $ln;
                }
            }
            elsif (exists($merged_match2_tmp{$ln}) && $last_chance ne "")
            {
                
                my $hp_SNP_read = substr $match, $hp_SNP_read_tmp+$pos_tmp, 1;
                $hp_SNP_read =~ tr/1234/ACTG/;
if ($back ne "")
            {
            }
                if ($hp_SNP_read ne $SNPs_or_not{$pos_tmp})
                {
                    $check = "no";
                    last HP_SNP;
                }
                elsif ($hp_SNP_read eq $SNPs_or_not{$pos_tmp} && $check_no_SNPs eq "")
                {
                    $check = "yes";
                    $hp_SNP_links{$pos_tmp} .= exists $hp_SNP_links{$pos_tmp} ? ",$ln" : $ln;
                }
            }
        }
    }
    if ($check_no_SNPs eq "" && $check ne "no")
    {
        undef %SNPs_or_not;
        %SNPs_or_not = %noSNPs;
        $check_no_SNPs = "yes";
        goto HP_SNP;
    }
    return $check;
}
sub align_hp
{
    my @str = @_;
    my $next_seq = $str[0];
    my $SNP_pos = $str[1];
    my $hp_SNP_seq = $str[2];
    my $ff2_LF = '0';
    $next_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
    my %nuc_counts;
    undef %nuc_counts;
    my $new_next_seq = "";
    my $new_SNP_pos = "";
    my %checked_ids;
    undef %checked_ids;
    my %A;
    my %C;
    my %T;
    my %G;
    undef %A;
    undef %C;
    undef %T;
    undef %G;
 print OUTPUT5 $next_seq." NEXT_SEQ\n";
 
    my $tt = '0';
    my %next_seq;
    undef %next_seq;
    while ($tt <= length($next_seq)-11)
    {
        my $next_seq_part = substr $next_seq, $tt, 11;
        my %next_seq_part = build_partial3b $next_seq_part;
        
        foreach my $next_seq_part_tmp (keys %next_seq_part)
        {
            $next_seq{$next_seq_part_tmp} = undef;
        }
        $tt++;
    }
    while ($ff2_LF <= length($next_seq)-$overlap)
    {
        my $next_seq_part = substr $next_seq, $ff2_LF, $overlap;
        my %next_seq_part = build_partial3b $next_seq_part;
        
        foreach my $next_seq_part_tmp (keys %next_seq_part)
        {
            my $search = "";
            my %search;
            undef %search;
            
            my $next_seq_part_tmp_reverse = reverse($next_seq_part_tmp);
            $next_seq_part_tmp_reverse =~ tr/ACTG/TGAC/;

            if (exists($hash2b{$next_seq_part_tmp}) && $ff2_LF <= $SNP_pos+$overlap)
            {
                my $search_tmp = $hash2b{$next_seq_part_tmp};
                $search = substr $search_tmp, 1;
                my @search = split /,/, $search;
                foreach my $search (@search)
                {
                    $search{$search} = "F2b";
                }
            }
            if (exists($hash2c{$next_seq_part_tmp_reverse}) && $ff2_LF <= $SNP_pos+$overlap)
            {
                my $search_tmp = $hash2c{$next_seq_part_tmp_reverse};
                $search = substr $search_tmp, 1;
                my @search = split /,/, $search;
                foreach my $search (@search)
                {
                    $search{$search} = "R2c";
                }
            }
            if (exists($hash2c{$next_seq_part_tmp}) && $ff2_LF >= $SNP_pos-$overlap)
            {
                my $search_tmp = $hash2c{$next_seq_part_tmp};
                $search = substr $search_tmp, 1;
                my @search = split /,/, $search;
                foreach my $search (@search)
                {
                    $search{$search} = "F2c";
                }
            }
            if (exists($hash2b{$next_seq_part_tmp_reverse}) && $ff2_LF >= $SNP_pos-$overlap)
            {
                my $search_tmp = $hash2b{$next_seq_part_tmp_reverse};
                $search = substr $search_tmp, 1;
                my @search = split /,/, $search;
                foreach my $search (@search)
                {
                    $search{$search} = "R2b";
                }
            }
            
ALIGN:      foreach my $search (keys %search)
            {
                my $search_tmp = substr $search, 0, -1;
                my $search_end = substr $search, -1;
                my $found = "";
                my $hash_and_sense_tmp = $search{$search};
                
                if (exists($checked_ids{$search_tmp}))
                {}
                elsif (exists($hash{$search_tmp}))
                {
                    my @search_tmp = split /,/,$hash{$search_tmp};
                    if ($search_end eq "1")
                    {
                        $found = $search_tmp[0];
                    }
                    elsif ($search_end eq "2")
                    {
                        $found = $search_tmp[1];
                    }
                    if ($encrypt eq "yes")
                    {
                        $found = decrypt $found;
                    }
                    my $hp_SNP_in_read = "";
                    my $found_part = "";
                    my $found2 = $found;
                    if ($hash_and_sense_tmp eq "R2c" || $hash_and_sense_tmp eq "R2b")
                    {
                        $found2 = reverse($found);
                        $found2 =~ tr/ACTG/TGAC/;
                    }
                    if ($hash_and_sense_tmp eq "F2b")
                    {
                        $hp_SNP_in_read = substr $found2, $SNP_pos-$ff2_LF+$left, 1;
                        $found_part = substr $found2, $left, -$right;
                    }
                    elsif ($hash_and_sense_tmp eq "R2c")
                    {
                        $hp_SNP_in_read = substr $found2, $SNP_pos-$ff2_LF+$right, 1;
                        $found_part = substr $found2, $right, -$left;
                    }
                    elsif ($hash_and_sense_tmp eq "F2c")
                    {
                        $hp_SNP_in_read = substr $found2, -$right-$overlap+$SNP_pos-$ff2_LF, 1;
                        $found_part = substr $found2, $left, -$right;
                    }
                    elsif ($hash_and_sense_tmp eq "R2b")
                    {
                        $hp_SNP_in_read = substr $found2, -$left-$overlap+$SNP_pos-$ff2_LF, 1;
                        $found_part = substr $found2, $right, -$left;
                    }
                    
                    
                    if ($hp_SNP_in_read eq $hp_SNP_seq)
                    {
                        $checked_ids{$search_tmp} = undef;
                        
                        my $uu = '0';
                        my $yes = '0';
                        my $no = '0';
                        while ($uu < length($found_part)-11)
                        {
                            my $check_part = substr $found_part, $uu, 11;
                            $check_part =~ tr/1234/ACTG/;
                            
                            if (exists($next_seq{$check_part}))
                            {
                                $yes++;
                            }
                            else
                            {
                                $no++;
                            }
                            $uu += 8;
                        }
                        if ($yes/($yes+$no) < 0.75)
                        {
                            next ALIGN;
                        }
                        
                        my @found_part = split //, $found_part;
                        my $xx = '0';
                        
                        if ($hash_and_sense_tmp eq "F2b")
                        {
                            print OUTPUT5 $found_part." HP_READ1\n";
                        }
                        elsif ($hash_and_sense_tmp eq "R2c")
                        {
                            print OUTPUT5 $found_part." HP_READ2\n";
                        }
                        elsif ($hash_and_sense_tmp eq "F2c")
                        {
                            print OUTPUT5 $found_part." HP_READ3\n";
                        }
                         elsif ($hash_and_sense_tmp eq "R2b")
                        {
                            print OUTPUT5 $found_part." HP_READ4\n";
                        }
                        my $extra = '0';
                        if ($hash_and_sense_tmp eq "F2c" || $hash_and_sense_tmp eq "R2b")
                        {
                            $extra = -length($found_part)+$overlap;
                        }
                        while ($xx < length($found_part))
                        {
                            if ($found_part[$xx] eq "A")
                            {
                                my $count = 0+$A{$ff2_LF+$xx+$extra}+1;
                                $A{$xx+$ff2_LF+$extra} = $count;
                            }
                            elsif ($found_part[$xx] eq "C")
                            {
                                my $count = 0+$C{$ff2_LF+$xx+$extra}+1;
                                $C{$xx+$ff2_LF+$extra} = $count;
                            }
                            elsif ($found_part[$xx] eq "T")
                            {
                                my $count = 0+$T{$ff2_LF+$xx+$extra}+1;
                                $T{$xx+$ff2_LF+$extra} = $count;
                            }
                            elsif ($found_part[$xx] eq "G")
                            {
                                my $count = 0+$G{$ff2_LF+$xx+$extra}+1;
                                $G{$xx+$ff2_LF+$extra} = $count;
                            }
                            $xx++;
                        }
                    }
                }
            }
        }
        $ff2_LF++;
    }
    my $pos_build = $SNP_pos-25;
    while ($pos_build < $SNP_pos+25)
    {
        my $A = $A{$pos_build};
        my $C = $C{$pos_build};
        my $T = $T{$pos_build};
        my $G = $G{$pos_build};
        print OUTPUT5 $pos_build." POS_BUILD\n";
        print OUTPUT5 $A." A\n";
        print OUTPUT5 $C." C\n";
        print OUTPUT5 $T." T\n";
        print OUTPUT5 $G." G\n";
        my @IUPAC = IUPAC($A,$C,$T,$G);
        $new_next_seq .= $IUPAC[0];
        $pos_build++;
    }
    $new_SNP_pos = '26';
    return ($new_next_seq, $new_SNP_pos);
}

my @reads_tmp = undef;

if ($reads12 eq "")
{
    @reads_tmp = ($reads1, $reads2);
    if ($reads1 eq $reads2)
    {     
        if ($batch_file ne "")
        {
            print "\nThe two input files are identical, please check the configuration file!\n";
            print OUTPUT4 "\nThe two input files are identical, please check the configuration file!\n";
            goto BATCH;
        }
        else
        {
            die "\nThe two input files are identical, please check the configuration file!\n";
        }
    }
}
else
{
    @reads_tmp = ($reads12);
}
my $output_file5  = "log_extended_".$project.".txt";
my $output_file6  = "contigs_tmp_".$project.".txt";
my $output_file7  = "Merged_contigs_".$project.".txt";
my $output_file10 = "Assembled_reads_".$project."_R1.fasta";
my $output_file11 = "Assembled_reads_".$project."_R2.fasta";
my $output_file12 = "Variance_".$project.".vcf";
my $output_file13 = "Heteroplasmy_".$project.".vcf";
my $output_file14 = "Heteroplasmy_assemblies_".$project.".fasta";
my $output_file15 = "Possible_NUMTs_".$project.".vcf";
my $output_file16 = "Possible_NUMTs_assemblies_".$project.".fasta";
my $output_file17 = "Circos_links_".$project.".txt";
my $output_file18 = "Circos_mutations_".$project.".txt";
my $output_file19 = "Homoplasmy_".$project.".vcf";
my $output_file20 = "Linkage_table_heteroplasmy_".$project.".txt";
my $output_file21 = "Linkage_table_NUMTs_".$project.".txt";

my $check_zip = substr $reads_tmp[0], -2;
my $check_zip2 = substr $reads_tmp[0], -3;
my $firstLine = "";
my $secondLine = "";
my $thirdLine = "";
my $fourthLine = "";
my $fifthLine = "";

if ($check_zip eq "gz")
{
    open (my $FILE, '-|', 'gzip', '-dc', $reads_tmp[0]) or die "Can't open file $reads_tmp[0], $!\n";
    $firstLine = <$FILE>;
    chomp $firstLine;
    $secondLine = <$FILE>;
    chomp $secondLine;
    $thirdLine = <$FILE>;
    chomp $thirdLine;
    $fourthLine = <$FILE>;
    chomp $fourthLine;
    $fifthLine = <$FILE>;
    chomp $fifthLine;
    close $FILE;
}
elsif ($check_zip2 eq "bz2")
{
    open (my $FILE, '-|', 'bzip2', '-dc', $reads_tmp[0]) or die "Can't open file $reads_tmp[0], $!\n";
    $firstLine = <$FILE>;
    chomp $firstLine;
    $secondLine = <$FILE>;
    chomp $secondLine;
    $thirdLine = <$FILE>;
    chomp $thirdLine;
    $fourthLine = <$FILE>;
    chomp $fourthLine;
    $fifthLine = <$FILE>;
    chomp $fifthLine;
    close $FILE;
}
else
{
    open(INPUT, $reads_tmp[0]) or die "No input file found, make sure it are fastq files $!\n";
    $firstLine = <INPUT>;
    chomp $firstLine;
    $secondLine = <INPUT>;
    chomp $secondLine;
    $thirdLine = <INPUT>;
    chomp $thirdLine;
    $fourthLine = <INPUT>;
    chomp $fourthLine;
    $fifthLine = <INPUT>;
    chomp $fifthLine;
    close INPUT;
}

open(INPUT3, $seed_input0) or die "\nCan't open the seed file, $!\n";
if ($heteroplasmy eq "")
{
    open(OUTPUT6, ">" .$output_file6) or die "\nCan't open file $output_file6, $!\n";
}
if ($print_log eq '1' || $print_log eq '2')
{
    open(OUTPUT5, ">" .$output_file5) or die "\nCan't open file $output_file5, $!\n";
    print OUTPUT5 "Project:\n";
    print OUTPUT5 "----------------------\n";
    print OUTPUT5 "Project name          = ".$project."\n";
    print OUTPUT5 "Type                  = ".$type."\n";
    print OUTPUT5 "Genome range          = ".$genome_range."\n";
    print OUTPUT5 "K-mer                 = ".$overlap."\n";
    print OUTPUT5 "Max memory            = ".$max_memory."\n";
    print OUTPUT5 "Extended log          = ".$print_log."\n";
    print OUTPUT5 "Save assembled reads  = ".$save_reads."\n";
    print OUTPUT5 "Seed Input            = ".$seed_input0."\n";
    print OUTPUT5 "Extend seed directly  = ".$extend_seed_directly."\n";
    print OUTPUT5 "Reference sequence    = ".$reference."\n";
    print OUTPUT5 "Variance detection    = ".$variance_detection."\n";
    print OUTPUT5 "Chloroplast sequence  = ".$cp_input."\n\n";
    
    print OUTPUT5 "Dataset 1:\n";
    print OUTPUT5 "----------------------\n";
    print OUTPUT5 "Read Length           = ".$read_length."\n";
    print OUTPUT5 "Insert size           = ".$insert_size."\n";
    print OUTPUT5 "Platform              = ".$platform."\n";
    print OUTPUT5 "Single/Paired         = ".$paired."\n";
    print OUTPUT5 "Combined reads        = ".$reads12."\n";
    print OUTPUT5 "Forward reads         = ".$reads1."\n";
    print OUTPUT5 "Reverse reads         = ".$reads2."\n\n";
    
    print OUTPUT5 "Heteroplasmy:\n";
    print OUTPUT5 "-----------------------\n";
    print OUTPUT5 "Heteroplasmy          = ".$heteroplasmy."\n";
    print OUTPUT5 "HP exclude list       = ".$HP_exclude."\n";
    print OUTPUT5 "PCR-free              = ".$PCR_free."\n\n";
    
    print OUTPUT5 "Optional:\n";
    print OUTPUT5 "----------------------\n";
    print OUTPUT5 "Insert size auto      = ".$insert_size_correct."\n";
    print OUTPUT5 "Use Quality Scores    = ".$use_quality."\n\n";
}
if ($save_reads ne "")
{
    open(OUTPUT10, ">" .$output_file10) or die "Can't open saved reads1 file $output_file10, $!\n";
    open(OUTPUT11, ">" .$output_file11) or die "Can't open saved reads2 file $output_file11, $!\n";
}
if ($variance_detection eq "yes")
{
    open(OUTPUT12, ">" .$output_file12) or die "Can't open variance file $output_file12, $!\n";
}
my $file13;
my $file14;
my $file15;
my $file16;
my $file17;
my $file18;
my $file19;
my $file20;
my $file21;
if ($heteroplasmy ne "")
{
    open($file13, ">" .$output_file13) or die "Can't open Heteroplasmy file $output_file13, $!\n";
    open($file14, ">" .$output_file14) or die "Can't open Heteroplasmy assemblies file $output_file14, $!\n";
    open($file20, ">" .$output_file20) or die "Can't open linkage table heteroplasmy file $output_file20, $!\n";
    if ($circos_links ne "")
    {
        open($file17, ">" .$output_file17) or die "Can't open Circos links file $output_file17, $!\n";
        open($file18, ">" .$output_file18) or die "Can't open Circos mutations file $output_file18, $!\n";
    }
}
select(STDERR);
$| = 1;
select(STDOUT); # default
$| = 1;
print "\nReading Input...";

my $firstLine_reverse = "";
if ($reads12 eq "")
{
    if ($check_zip eq "gz")
    {
        open (my $FILE, '-|', 'gzip', '-dc', $reads_tmp[1]) or die "Can't open file $reads_tmp[1], $!\n";
        $firstLine_reverse = <$FILE>;
        chomp $firstLine_reverse;
        close $FILE;
    }
    elsif ($check_zip2 eq "bz2")
    {
        open (my $FILE, '-|', 'bzip2', '-dc', $reads_tmp[1]) or die "Can't open file $reads_tmp[1], $!\n";
        $firstLine_reverse = <$FILE>;
        chomp $firstLine_reverse;
        close $FILE;
    }
    else
    {
        open(INPUT2, $reads_tmp[1]) or die "\n\nNo input file found, make sure it are fastq files $!\n";
        $firstLine_reverse = <INPUT2>;
        chomp $firstLine_reverse;
        close INPUT2;
    }
}
my $no_quality_score = substr $thirdLine, 0, 1;
my $type_of_file = "";
my $type_of_file2 = "";
my $code_before_end = substr $firstLine, -2,1;
my $code_before_end0 = substr $firstLine, -1,1;
my $code_before_end_reverse = substr $firstLine_reverse, -2,1;
my $code_before_end0_reverse = substr $firstLine_reverse, -1,1;

my $SRA = "";
if ($paired eq "SE")
{
    $type_of_file = '0';
}
elsif (($code_before_end eq "/" || $code_before_end eq "R" || $code_before_end eq "#") && $firstLine_reverse ne $firstLine && $code_before_end0 eq "1")
{
    $type_of_file = '-1';
}
elsif ($code_before_end eq ":" && $code_before_end0 eq "1" && $firstLine_reverse ne $firstLine && $code_before_end_reverse eq ":" && $code_before_end0_reverse eq "2")
{
    $type_of_file = '-1';
}
elsif($firstLine =~ m/.*(_|\s)(1)(:\w.*\d+:*(\s.*|\w+)*\s*\t*)$/ && $firstLine_reverse ne $firstLine)
{
    $type_of_file = "yes";
}
elsif ($code_before_end eq ":" && $code_before_end0 eq "1" && $firstLine_reverse ne $firstLine && $firstLine_reverse eq "")
{
    $type_of_file = '-1';
}
elsif($firstLine =~ m/.*\s(1)(\S*)$/ && $firstLine_reverse ne $firstLine)
{
    my $firstLine_tmp = $firstLine;
    my $test_space = $firstLine_tmp =~ tr/ //;
    $type_of_file = -length($2)-1;
    if ($test_space eq '1')
    {
        $type_of_file = "split";
    }
}
elsif($firstLine =~ m/.*_(1)(:N.*)$/ && $firstLine_reverse ne $firstLine)
{
    $type_of_file = -length($2)-1;
}
elsif($fifthLine =~ m/.*\.(1)(\s(.+)\s.+)$/ && $firstLine_reverse ne $firstLine)
{
    $type_of_file = -length($2)-1;
}
elsif($firstLine =~ m/.*(length=\d+\s*)$/)
{
    $type_of_file = "identical";
    $type_of_file2 = -length($1)
}
elsif($firstLine_reverse eq $firstLine)
{
    $type_of_file = "identical";
}
elsif($firstLine =~ m/\S*\.(1)(\s(\d+)\s.*)$/ && $firstLine_reverse ne $firstLine)
{
    my $test1 = $3;
    if($fifthLine =~ m/\S*\.(1)(\s(\d+)(\s.*))$/ && $firstLine_reverse ne $firstLine)
    {
         my $test2 = $3;
         if ($test2 eq $test1)
         {
            $type_of_file = -length($2)-1;
         }
         else
         {
            $type_of_file = -length($4);
            $SRA = "yes";
         }
    }
}
elsif($reads12 ne "")
{
    print "\n\nCOMBINED FILE NOT SUPPORTED, PLEASE TRY SEPERATE FILES FOR THE FORWARD AND REVERSE READS!\n\n";
    print OUTPUT4 "\n\nCOMBINED FILE NOT SUPPORTED, PLEASE TRY SEPERATE FILES FOR THE FORWARD AND REVERSE READS!\n\n";
    if ($batch_file ne "")
    {
        goto BATCH;
    }
    else
    {
        exit;
    }
}
else
{
    print "\n\nTHE INPUT READS HAVE AN INCORRECT FILE FORMAT!\nPLEASE SEND ME THE ID STRUCTURE!\n\n";
    print OUTPUT4 "\n\nTHE INPUT READS HAVE AN INCORRECT FILE FORMAT!\nPLEASE SEND ME THE ID STRUCTURE!\n\n";
    if ($batch_file ne "")
    {
        goto BATCH;
    }
    else
    {
        exit;
    }
}
my $check_line_end = $secondLine;
chomp($check_line_end);
my $last_character = substr $check_line_end, -1;
my $space_at_end = "";
if ($last_character =~ m/\s|\t/g)
{
    $space_at_end = "yes";
}
print "...OK\n";


my %cp_ref;
my %cp_ref2;
undef %cp_ref;
undef %cp_ref2;

if ($cp_input ne "")
{
    select(STDERR);
    $| = 1;
    select(STDOUT); # default
    $| = 1;
    print "\nScan chloroplast sequence...";
    open(INPUT4, $cp_input) or die "\n\nCan't open chloroplast file $cp_input, $!\n";
    my $ff = '0';
    my $value_ref = "";
    my $ref_reverse_tmp = "";
    
    while (my $line = <INPUT4>)
    {
        if ($ff < 1)
        {
            $ff++;
            next;
        }
        chomp $line;    
        $line =~ tr/actgn/ACTGN/;
        
        my $line3 = $value_ref.$line;
        $ref_reverse_tmp .= $line;
        
        while (length($line3) > ((35*3)-1))
        {
            my $value_ref2 = substr $line3, 0, 35;
            my $line2 = $line3;
            $line3 = substr $line2, 1;
            
            $cp_ref{$value_ref2} .= exists $cp_ref{$value_ref2} ? ",$ff" : $ff;
            $cp_ref2{$ff} .= exists $cp_ref2{$ff} ? "$value_ref2" : $value_ref2;
            $ff++;
        }
        $value_ref = $line3;
    }
    my $ref_reverse = reverse($ref_reverse_tmp);
    $ref_reverse =~ tr/ACGT/TGCA/;
    while (length($ref_reverse) > ((35*3)-1))
    {
        my $value_ref2 = substr $ref_reverse, 0, 35;
        my $line2 = $ref_reverse;
        $ref_reverse = substr $line2, 1;
        
        $cp_ref{$value_ref2} .= exists $cp_ref{$value_ref2} ? ",$ff" : $ff;
        $cp_ref2{$ff} .= exists $cp_ref2{$ff} ? "$value_ref2" : $value_ref2;
        $ff++;
    }
    close INPUT4;
    print "...OK\n";
}
if ($variance_detection eq "yes")
{
    my ($wday, $mon, $mday, $hour, $min, $sec, $year) = localtime;
    my @localtime = split / /, localtime;
    my %mon2num = qw(
    Jan 01  Feb 02  Mar 03  Apr 04  May 05  Jun 06
    Jul 07  Aug 08  Sep 09  Oct 10 Nov 11 Dec 12
    );
    my $month = $localtime[1];
    if (exists($mon2num{$localtime[1]}))
    {
       $month = $mon2num{$localtime[1]};
    }
    print OUTPUT12 "##fileformat=VCFv4.0\n";
    print OUTPUT12 "##fileDate=".$localtime[4].$month.$localtime[2]."\n";
    print OUTPUT12 "##reference=".$reference."\n";
    print OUTPUT12 "##INFO=<ID=AF,Number=1,Type=Float,Description=\"Allele Frequency\">\n";
    print OUTPUT12 "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Raw Depth\">\n";
    print OUTPUT12 "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n";
}
if ($heteroplasmy ne "")
{
    my ($wday, $mon, $mday, $hour, $min, $sec, $year) = localtime;
    my @localtime = split / /, localtime;
    my %mon2num = qw(
    Jan 01  Feb 02  Mar 03  Apr 04  May 05  Jun 06
    Jul 07  Aug 08  Sep 09  Oct 10 Nov 11 Dec 12
    );
    my $month = $localtime[1];
    if (exists($mon2num{$localtime[1]}))
    {
       $month = $mon2num{$localtime[1]};
    }
    print $file13 "##fileformat=VCFv4.0\n";
    print $file13 "##fileDate=".$localtime[4].$month.$localtime[2]."\n";
    print $file13 "##reference=".$reference."\n";
    print $file13 "##INFO=<ID=AF,Number=1,Type=Float,Description=\"Allele Frequency\">\n";
    print $file13 "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Raw Depth\">\n";
    print $file13 "##INFO=<ID=FR,Number=1,Type=Flag,Description=\"Detected on the forward(F) and/or reverse(R) strand\">\n";
    print $file13 "##INFO=<ID=LCR,Number=1,Type=String,Description=\"Low Complexity Region\">\n";
    print $file13 "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n";
}
if ($type eq "chloro")
{
    $chromosome = "cp";
}
else
{
    $chromosome = "mt";
}
if ($heteroplasmy ne "" && $HP_exclude ne "")
{
    open(INPUT6, $HP_exclude) or die "\nCan't open the exclude list file, $!\n";
    while (my $line = <INPUT6>)
    {
        chomp($line);
        my @pos = split / /, $line;
        foreach my $pos (@pos)
        {
            chomp($pos);
            $HP_exclude{$pos} = undef;
        }
    }
    close INPUT6;
}
my $si = '0';
my $space_at_end2 = "";

while (my $line = <INPUT3>)
{
    chomp($line);
    if ($si eq 0)
    {
        my $last_character = substr $line, -1;       
        if ($last_character =~ m/\s|\t/g)
        {
            $space_at_end2 = "yes";
        }
    }
    if ($si > 0)
    {   
        if ($space_at_end2 eq "yes")
        {
            chop($line);
        }
        my $seed_input_tmp = $seed_input;
        $seed_input = $seed_input_tmp.$line;
        $seed_input =~ tr/actgn/ACTGN/;
    }
    $si++;
}
if ($seed_input eq "")
{
    die "\nThe seed file is empty or corrupt, please use a different one.\n";
}

my %hashref;
my %hashref2;
undef %hashref;
undef %hashref2;

if ($reference ne "")
{
    select(STDERR);
    $| = 1;
    select(STDOUT); # default
    $| = 1;
    print "\nScan reference sequence...";
    open(INPUT5, $reference) or die "\n\nCan't open reference file $reference, $!\n";
    my $ff2 = '0';
    my $value_ref2 = "";
   
    while (my $line = <INPUT5>)
    {
        if ($ff2 < 1)
        {
            $ff2++;
            next;
        }
        chomp $line;    
        $line =~ tr/actgn/ACTGN/;
        my $first = substr $line, 0, 1;
        my $line3 = "";
        if ($first eq '>' || $first eq '@')
        {
            $line3 = $value_ref2."NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN";
        }
        else
        {
            $line3 = $value_ref2.$line;
        }
        
        while (length($line3) > ((30*3)-1))
        {
            my $value_ref2b = substr $line3, 0, 30;
            my $line2 = $line3;
            $line3 = substr $line2, 1;
            
            $hashref{$value_ref2b} .= exists $hashref{$value_ref2b} ? ",$ff2" : $ff2;
            $hashref2{$ff2} .= exists $hashref2{$ff2} ? "$value_ref2b" : $value_ref2b;
            
            $ff2++;
        }
        $value_ref2 = $line3;
    }
    while (length($value_ref2) > 0)
    {
        my $value_ref2b = substr $value_ref2, 0, 30;
        my $value_ref2bc = $value_ref2;
        $value_ref2 = substr $value_ref2bc, 1;
        
        $hashref{$value_ref2b} .= exists $hashref{$value_ref2b} ? ",$ff2" : $ff2;
        $hashref2{$ff2} .= exists $hashref2{$ff2} ? "$value_ref2b" : $value_ref2b;
        $ff2++;
    }
    close INPUT5;
    print "...OK\n";
    
    if ($extend_seed_directly eq "")
    {
        my $seed_input_reverse = reverse($seed_input);
        $seed_input_reverse =~ tr/ATCG/TAGC/;
        my $d = '0';
        my $count = '0';
        my $count_reverse = '0';
        while ($d < length($seed_input)-30)
        {
            my $part = substr $seed_input, $d, 30;
            my $part_reverse = substr $seed_input_reverse, $d, 30;
            if (exists($hashref{$part}))
            {
                $count++;
            }
            if (exists($hashref{$part_reverse}))
            {
                $count_reverse++;
            }
            if ($count_reverse > $count)
            {
                $seed_input = $seed_input_reverse;
            }
            $d++;
        }
    }
}

select(STDERR);
$| = 1;
select(STDOUT); # default
$| = 1;
print "\nBuilding Hash Table...";

my $file1;

if ($reads12 eq "")
{
    $file1 = $reads1;
}
else
{
    $file1 = $reads12;
}
    
my $file_count= '0';
my $count_char = '0';
my $count_hash_element = '0';
my $out_of_memory = "";
my $memory_max_current = "";
my $count_paired = '0';
my $skipped_reads = '0';
my $chop = "";
my $test = '0';
my $keys_hash = '0';
my %map_ids;
undef %map_ids;
my $count_low_quality = '0';
my $no_pair1 = '0';
my $no_pair2 = '0';
my $code_new = '1';
my $file1_count = '0';
my $file2_count = '0';

READS_TMP: foreach my $reads_tmp (@reads_tmp)
{
    my $FILE;
    if ($check_zip eq "gz")
    {
        open ($FILE, '-|', 'gzip', '-dc', $reads_tmp) or die "Can't open file $reads_tmp, $!\n";
    }
    elsif ($check_zip2 eq "bz2")
    {
        open ($FILE, '-|', 'bzip2', '-dc', $reads_tmp) or die "Can't open file $reads_tmp, $!\n";
    }
    else
    {
        open($FILE, $reads_tmp) or die "\n\nCan't open file $reads_tmp, $!\n";
    }
  
    my $N = '0';
    my $f = "";
    my $code = "";
    $code_new = '1';
    my $value = "";
    my $quality = "";
    $out_of_memory = "";

FILE_LINE:while (my $line = <$FILE>)
    {
        if ($file_count eq '0')
        {
            $file1_count++;
        }
        else
        {
            $file2_count++;
        }
        if ($file_count eq "0" && $out_of_memory eq "yes" && $reads12 eq "")
        {    
            next FILE_LINE;
        }
        elsif ($file_count eq "1" && $count_paired eq $keys_hash && $reads12 eq "")
        {
            last READS_TMP;
        }
        
        chomp $line;
        if ($f eq "use_quality")
        {
            if ($use_quality ne "")
            {
                $value = $line;
            }
            $f = "yes";
            next FILE_LINE;
        }
        if ($f eq "yes" && $no_quality_score ne "@" && $no_quality_score ne ">")
        {
            $f = "yes2";
            next FILE_LINE;
        }
        if ($f eq "yes" && ($no_quality_score eq "@" || $no_quality_score eq ">"))
        {
            $code = $line;
            $f = "no";
            next FILE_LINE;
        }
        if ($f eq "yes2")
        {
            if ($use_quality ne "")
            {
                $f = "no";
                $quality = $line;
            }
            else
            {
                $f = "";
                next FILE_LINE;
            }
        }
        if ($f eq "no")
        {
            if ($use_quality eq "")
            {
                $value = $line;
            }

            if ($space_at_end eq "yes")
            {
                chop($value);
            }

            my $code2 = $code;
            my $code_end = substr $code2, $type_of_file, 1;
            my $code0_SRA = "";
            if ($paired eq 'SE')
            {
                $code_end = '2';
            }

            if ($SRA eq "yes")
            {
                my $code_SRA = substr $code2, 0, $type_of_file;
                my @code_SRA = split / /, $code_SRA;
                $code0_SRA = $code_SRA[0];
                $code_end = substr $code0_SRA, -1, 1, "";
            }                  
            if ($type_of_file eq "identical")
            {
                if ($file_count eq '0')
                {
                    $code_end = "1";
                }
                elsif ($file_count eq '1')
                {
                    $code_end = "2";
                }    
            }
            if ($type_of_file eq "yes")
            {
                if($code2 =~ m/.*(_|\s)(1|2)(:\w.*\d+:*(\s.*|\w+)*\s*\t*)$/)
                {
                    $code_end = $2;
                    $type_of_file2 = -length($3)-1;
                }   
            }
            if ($type_of_file eq "split")
            {
                my @split = split / /, $code2;
                $code_end = substr $split[1], 0, 1;
                $type_of_file2 = $split[0];
            }
            if ($code_end eq "1" && $out_of_memory ne "yes" && (length($line) > ($overlap+8)*2 || length($line) > $overlap+$right+$left+10 || length($line) > $read_length-10))
            {
                if ($encrypt eq "yes")
                {
                    my $value_c = $value;
                    $value = encrypt $value_c;
                }
                if ($use_quality ne "")
                {
                    my $quality2 = $quality;
                    my $check_quality = $quality2 =~ tr/\!|\"|\#|\$|\%|\&|\'|\(|\)|\*|\+|\,|\-|\.|\/|0|1|2|3|4|5/O/;
                    
                    if ($check_quality > 0)
                    {
                        my $offset = '0';
                        my $result = index($quality2, 'O', $offset);
                        
                        while ($result != -1)
                        {                        
                            my $nuc = substr $value, $offset, 1;
                            if ($nuc eq "A")
                            {
                                substr $value, $offset, 1, "1";
                            }
                            elsif ($nuc eq "C")
                            {
                                substr $value, $offset, 1, "2";
                            }
                            elsif ($nuc eq "T")
                            {
                                substr $value, $offset, 1, "3";
                            }
                            elsif ($nuc eq "G")
                            {
                                substr $value, $offset, 1, "4";
                            }
                            $offset = $result + 1;
                            $result = index($quality2, 'O', $offset);
                        }
                    }
                }
                my $code0 = substr $code2, 0, $type_of_file;
                if ($SRA eq "yes")
                {
                    $code0 = $code0_SRA;
                }
                
                if ($type_of_file eq "identical")
                {
                   $code0 = $code2;
                   if ($type_of_file2 ne "")
                   {
                        $code0 = substr $code2, 0, $type_of_file2
                   }
                }
                if ($type_of_file eq "yes")
                {
                   $code0 = substr $code2, 0, $type_of_file2;
                }
                if ($type_of_file eq "split")
                {
                    $code0 = $type_of_file2;
                }
                if ($memory_max_current > $max_memory && $max_memory ne "")
                {
                    $out_of_memory = "yes";          
                }
                $keys_hash++;
                $hash{$code0."1a"} = $value;
                $count_char += length($value)*2;
                $count_char += $overlap*2;
                $count_hash_element++;
                $memory_max_current = ((($count_hash_element/4805)*4.5) + ($count_char/1312123))/1000;
                
                if ($save_reads eq "2")
                {
                    $count_char += length($code0);
                    $memory_max_current = ((($count_hash_element/4805)*5.5) + ($count_char/1312123))/1000;
                }
                
                if ($chop eq "")
                {
                    my $last_character = substr $code0, -1;       
                    if ($last_character =~ m/\s|\t/g)
                    {
                        $chop = "yes";
                    }
                    else
                    {
                        $chop = "no";
                    }
                }
            }
            elsif ($code_end eq "1")
            {
                $skipped_reads++;
            }
            elsif ($code_end eq "2")
            {
                my $code1 = substr $code2, 0, $type_of_file;
                if ($SRA eq "yes")
                {
                    $code1 = $code0_SRA;
                }
                if ($paired eq "SE")
                {
                    $code1 = $code2;
                }          
                if ($type_of_file eq "identical")
                {
                   $code1 = $code2;
                   if ($type_of_file2 ne "")
                   {
                        $code1 = substr $code2, 0, $type_of_file2
                   }
                }
                if ($type_of_file eq "yes")
                {
                   $code1 = substr $code2, 0, $type_of_file2;
                }
                if ($type_of_file eq "split")
                {
                    $code1 = $type_of_file2;
                }
 
                if (length($line) > ($overlap+8)*2 || length($line) > $overlap+$right+$left+10 || length($line) > $read_length-10)
                {                    
                    $count_paired++;
                    my $value2 = $hash{$code1."1a"};
                    my $code_new1 = ($code_new*10)+1;
                    my $code_new2 = ($code_new*10)+2;
                    my $value3 = "";
                    my $value4 = "";

                    if ($encrypt eq "yes")
                    {
                        $value3 = encrypt $value2;
                        $value4 = encrypt $value;
                    }
                    else
                    {
                        $value3 = $value2;
                        $value4 = $value;
                    }
                    if ($use_quality ne "")
                    {
                        $value2 =~ tr/1234/ACTG/;
                        my $quality2 = $quality;
                        my $check_quality = $quality2 =~ tr/\!|\"|\#|\$|\%|\&|\'|\(|\)|\*|\+|\,|\-|\.|\/|0|1|2|3|4|5/O/;
                        if ($check_quality > 0)
                        {
                            my $offset = '0';
                            my $result = index($quality2, 'O', $offset);
                            
                            while ($result != -1)
                            {                        
                                my $nuc = substr $value4, $offset, 1;
                                if ($nuc eq "A")
                                {
                                    substr $value4, $offset, 1, "1";
                                }
                                elsif ($nuc eq "C")
                                {
                                    substr $value4, $offset, 1, "2";
                                }
                                elsif ($nuc eq "T")
                                {
                                    substr $value4, $offset, 1, "3";
                                }
                                elsif ($nuc eq "G")
                                {
                                    substr $value4, $offset, 1, "4";
                                }
                                $offset = $result + 1;
                                $result = index($quality2, 'O', $offset);    
                            }
                        }
                    }
                    
                    if ($paired eq "PE" && exists($hash{$code1."1a"}))
                    {
                        $hash{$code_new} = $value3;
                    }
                    else
                    {
                        $no_pair2++;
                    }

                    my $first = substr $value, $left, $overlap;
                    my $second = substr $value, -($overlap+$right), $overlap;
                
                    if ($paired eq "SE")
                    {
                        $hash{$code_new} = $value4;                       
                        $hash2b{$first} .= exists $hash2b{$first} ? ",$code_new1" : $code_new1;
                        $hash2c{$second} .= exists $hash2c{$second} ? ",$code_new1" : $code_new1;
                    }
                    else
                    {
                        $hash{$code_new} .= exists $hash{$code_new} ? ",$value4" : $value4;
                        $hash2b{$first} .= exists $hash2b{$first} ? ",$code_new2" : $code_new2;
                        $hash2c{$second} .= exists $hash2c{$second} ? ",$code_new2" : $code_new2;                  
                    }
                    
                    if ($paired eq "PE" && exists($hash{$code1."1a"}))
                    {
                        $first = substr $value2, $left, $overlap;
                        $second = substr $value2, -($overlap+$right), $overlap;
                    
                        $hash2b{$first} .= exists $hash2b{$first} ? ",$code_new1" : $code_new1;
                        $hash2c{$second} .= exists $hash2c{$second} ? ",$code_new1" : $code_new1;
                    } 
                    $code_new++;
                    delete $hash{$code1."1a"};
                    
                    if ($save_reads eq "2")
                    {
                        if ($chop eq "yes")
                        {
                            chop($code1);
                        }
                        $map_ids{$code_new} = $code1;
                    }
                }
                elsif (exists($hash{$code1."1a"}) || $paired eq "SE")
                {
                    $count_paired++;
                    $no_pair1++;
                
                    my $value2 = $hash{$code1."1a"};
                    delete $hash{$code1."1a"};
                    my $code_new1 = ($code_new*10)+1;
                    my $value3 = "";

                    if ($encrypt eq "yes")
                    {
                        $value3 = encrypt $value2;
                    }
                    else
                    {
                        $value3 = $value2;
                    }
                    
                    if ($use_quality ne "")
                    {
                        $value2 =~ tr/1234/ACTG/;
                    }
                    $hash{$code_new} = $value3;
                    my $first = substr $value2, $left, $overlap;
                    my $second = substr $value2, -($overlap+$right), $overlap;
                
                    $hash2b{$first} .= exists $hash2b{$first} ? ",$code_new1" : $code_new1;
                    $hash2c{$second} .= exists $hash2c{$second} ? ",$code_new1" : $code_new1;
                    $code_new++;
                }
                else
                {
                    $skipped_reads++;
                }
            }
            else
            {
                $test++;
            }
            $f = "yes";
            if ($use_quality ne "")
            {
                $f = "";
            }
        }
        else
        {
            $code = $line;
            $f = "no";
            if ($use_quality ne "")
            {
                $f = "use_quality";
            }
        } 
    }
    $file_count++;
    close $FILE;
}
if ($count_paired ne $keys_hash || $no_pair2 > 0)
{
    foreach my $hash_key (%hash)
    {
        my $last_char = substr $hash_key, -1, 1;
        if ($last_char eq "a")
        {
            $count_paired++;
            $no_pair1++;
            my $code1 = substr $hash_key, 0, -2;
            my $value2 = $hash{$code1."1a"};
            delete $hash{$code1."1a"};
            my $code_new1 = ($code_new*10)+1;
            my $value3 = "";
    
            if ($encrypt eq "yes")
            {
                $value3 = encrypt $value2;
            }
            else
            {
                $value3 = $value2;
            }
            my $tesd = $value2;
            $tesd =~ tr/1234/ACTG/;
            if ($use_quality ne "")
            {
                $value2 =~ tr/1234/ACTG/;
            }
            $hash{$code_new} = $value3;
            my $first = substr $value2, $left, $overlap;
            my $second = substr $value2, -($overlap+$right), $overlap;
        
            $hash2b{$first} .= exists $hash2b{$first} ? ",$code_new1" : $code_new1;
            $hash2c{$second} .= exists $hash2c{$second} ? ",$code_new1" : $code_new1;
            $code_new++;
        }
    }
}
print "...OK\n\n";

my $all_reads = "";
if ($no_quality_score ne "@" && $no_quality_score ne ">")
{ 
    $all_reads = ($file1_count*2)/4;
}
else
{
    $all_reads = ($file1_count*2)/2;
}
my $size2 = keys %hash;
my $percentage_used = "";
if ($all_reads-$skipped_reads eq 0)
{
    $percentage_used = 0;
    die "Unable to read any data from the read files. Check your files and maybe try to move the files to the same directory as the perl file $!\n";
}
else
{
    my $percentage_usedb = ((($size2*2)-($no_pair1+$no_pair2))*100)/($all_reads-$skipped_reads);
    $percentage_used = sprintf("%.2f", $percentage_usedb);
}
print "Subsampled fraction: ".$percentage_used." %\n";
print OUTPUT4 "Subsampled fraction: ".$percentage_used." %\n";
if ($paired eq "PE" && ($no_pair1+$no_pair2) > 0)
{
    print "Forward reads without pair: ".$no_pair1."\n";
    print OUTPUT4 "Forward reads without pair: ".$no_pair1."\n";
    print "Reverse reads without pair: ".$no_pair2."\n";
    print OUTPUT4 "Reverse reads without pair: ".$no_pair2."\n";
}

select(STDERR);
$| = 1;
select(STDOUT); # default
$| = 1;
if ($extend_seed_directly ne "yes")
{
    print "\nRetrieve Seed...";
    print OUTPUT4 "\nRetrieve Seed...\n";
}

HP_BACK:

my %read1;
undef %read1;

FIRST_SEED:

my $seed_input_new2 = "";
my $seed_input_tmp = $seed_input;
my $low_coverage_check = "";

if ($bad_read ne "" && keys %contigs && $hp_back eq "")
{
    $seed_input_tmp = $read;
}
if ($seed_input_tmp ne "" && $test_seed eq "" && $extend_seed_directly ne "yes")
{
    my $build = "";
REF0:
    my $n = '0';
    my $overlap_tmp = $overlap;
    if ($build eq "yes2" && $overlap > 42)
    {
        $overlap_tmp = '33';
    }
    $low_coverage_check = '0';

    while ($n < length($seed_input_tmp) - $overlap_tmp)
    {
        my $first_seed = substr $seed_input_tmp, $n, $overlap_tmp;
        my $first_read = "";
        my $first_read_id = "";
        my %first_seed;
        undef %first_seed;
        if ($build eq "yes")
        {
            %first_seed = build_partial2b $first_seed;
        }
        else
        {
            $first_seed{$first_seed} = undef;
        }
        if ($build eq "yes2" && $overlap > '42' && $n < 3000)
        {          
            my @match1 = grep {$_ =~ /.*($first_seed).+$/} keys %hash2b;
            my @match2 = grep {$_ =~ /.*($first_seed).+$/} keys %hash2c;
            my @match3 = (@match1,@match2);
            undef %first_seed;
            foreach $first_seed (@match3)
            {
                $first_seed{$first_seed} = undef;
            }
        }

FIRST_SEED2: foreach my $first_seed (keys %first_seed)
        {
            if (exists($hash2b{$first_seed}))
            {   
                my $seed_input_id2 = substr $hash2b{$first_seed}, 1;
                my @seed_input_id = split /,/, $seed_input_id2;
                my $seed_input_id = $seed_input_id[0];
                my $seed_input_id_tmp = substr $seed_input_id, 0, -1;
                my $seed_input_id_end = substr $seed_input_id, -1;
                if (exists ($bad_read{$seed_input_id_tmp}))
                {
                    next FIRST_SEED2;
                }
                if (exists($hash{$seed_input_id_tmp}))
                {
                    $low_coverage_check++;
                    my @seed_input_id_tmp = split /,/,$hash{$seed_input_id_tmp};
                    my $seed_input_new = "";
                    if ($seed_input_id_end eq "1")
                    {
                        $seed_input_new = $seed_input_id_tmp[0];
                    }
                    elsif ($seed_input_id_end eq "2")
                    {
                        $seed_input_new = $seed_input_id_tmp[1];
                    }
                    if ($use_quality ne "")
                    {
                       $seed_input_new =~ tr/1234/ACTG/;
                    }
                    if ($encrypt eq "yes")
                    {
                       $seed_input_new2 = decrypt $seed_input_new;
                    }
                    else
                    {
                        $seed_input_new2 = $seed_input_new;
                    }
                    if (exists($read1{$seed_input_new2}))
                    {
                        next FIRST_SEED2;
                    }
                    my $pp = '0';
                    my $pp2= '0';
                    my $part2 = substr $seed_input_new2, -$overlap-25;

                    while ($pp < length($part2)-$overlap)
                    {
                        my $seed_check = substr $part2, $pp, $overlap;
                        my $seed_check_reverse = reverse($seed_check);
                        $seed_check_reverse =~ tr/ACTG/TGAC/;

                        if (exists($hash2b{$seed_check}))
                        {
                            $pp2++;
                        }
                        if (exists($hash2c{$seed_check}))
                        {
                            $pp2++;
                        }
                        if (exists($hash2b{$seed_check_reverse}))
                        {
                            $pp2++;
                        }
                        if (exists($hash2c{$seed_check_reverse}))
                        {
                            $pp2++;
                        }                        
                        if ($pp2 > 5)
                        {
                            $bad_read{$seed_input_id_tmp} = "yes";
                            $first_read_id = $seed_input_id;
                            my %empty_hash;
                            undef %empty_hash;
                            $first_read = correct ($seed_input_new2 , \%empty_hash, $heteroplasmy);
                            print OUTPUT5 "\nInitial read retrieved successfully1: ".$first_read."\n";
                            goto FIRST_READ; 
                        }  
                        $pp++;
                    }   
                }
            }
            if (exists($hash2c{$first_seed}))
            {
                $low_coverage_check++;
                my $seed_input_id2 = substr $hash2c{$first_seed}, 1;
                my @seed_input_id = split /,/, $seed_input_id2;
                my $seed_input_id = $seed_input_id[0];
                my $seed_input_id_tmp = substr $seed_input_id, 0, -1;
                my $seed_input_id_end = substr $seed_input_id, -1;
                if (exists ($bad_read{$seed_input_id_tmp}))
                {
                    next FIRST_SEED2;
                }
        
                if (exists($hash{$seed_input_id_tmp}))
                {  
                    my @seed_input_id_tmp = split /,/,$hash{$seed_input_id_tmp};
                    my $seed_input_new = "";
                    if ($seed_input_id_end eq "1")
                    {
                        $seed_input_new = $seed_input_id_tmp[0];
                    }
                    elsif ($seed_input_id_end eq "2")
                    {
                        $seed_input_new = $seed_input_id_tmp[1];
                    }
                    if ($use_quality ne "")
                    {
                       $seed_input_new =~ tr/1234/ACTG/;
                    }
                    if ($encrypt eq "yes")
                    {
                       $seed_input_new2 = decrypt $seed_input_new;
                    }
                    else
                    {
                        $seed_input_new2 = $seed_input_new;
                    }
                    if (exists($read1{$seed_input_new2}))
                    {
                        next FIRST_SEED2;
                    }
                    my $pp = '0';
                    my $pp2= '0';
                    my $part2 = substr $seed_input_new2, -$overlap-25;

                    while ($pp < length($part2)-$overlap)
                    {
                        my $seed_check = substr $part2, $pp, $overlap;
                        my $seed_check_reverse = reverse($seed_check);
                        $seed_check_reverse =~ tr/ACTG/TGAC/;

                        if (exists($hash2b{$seed_check}))
                        {
                            $pp2++;
                        }
                        if (exists($hash2c{$seed_check}))
                        {
                            $pp2++;
                        }
                        if (exists($hash2b{$seed_check_reverse}))
                        {
                            $pp2++;
                        }
                        if (exists($hash2c{$seed_check_reverse}))
                        {
                            $pp2++;
                        }
                        if ($pp2 > 5)
                        {
                            $bad_read{$seed_input_id_tmp} = "yes";
                            $first_read_id = $seed_input_id;
                            my %empty_hash;
                            undef %empty_hash;
                            $first_read = correct ($seed_input_new2 , \%empty_hash, $heteroplasmy);
                            print OUTPUT5 "\nInitial read retrieved successfully2: ".$first_read."\n";
                            goto FIRST_READ; 
                        }  
                        $pp++;
                    }                    
                }
            }
        }
        $n++;
        if ($build eq "yes2")
        {
            $n += 4;
        }
FIRST_READ:
        my $last_nucleo = substr $first_read, -1;
        while ($last_nucleo eq '.')
        {
            chop($first_read);
            $last_nucleo = substr $first_read, -1;
        }
        my $last_15_nucleo = substr $first_read, -15;
        my $count_dot = $last_15_nucleo =~ tr/\.//;
        while ($count_dot > 4)
        {
            substr $first_read, -15, 15, "";
            $last_15_nucleo = substr $first_read, -15;
            $count_dot = $last_15_nucleo =~ tr/\.//;
        }
        my $first_nucleo = substr $first_read, 0, 1;
        while ($first_nucleo eq '.')
        {
            my $first_read_tmp = $first_read;
            $first_read = substr $first_read_tmp, 1;
            $first_nucleo = substr $first_read, 0, 1;
        }
        
        if ($first_read ne "" && length($first_read) > 50)
        {    
            $seed{$first_read_id} = $first_read;
            $seeds_check{$first_read_id} = undef;
            $read1{$first_read} =undef;
            $contig_count{$first_read_id} = '0';
            $position{$first_read_id} = length($seed{$first_read_id});
            
            if ($hp_back eq "")
            {
                print "...OK\n";
            }
            print "\nInitial read retrieved successfully: ".$first_read."\n";
            print OUTPUT4 "\nInitial read retrieved successfully: ".$first_read."\n";
            if ($bad_read ne "" && keys %contigs)
            {
                $noback{$first_read_id} = "stop";
                $tree{$id} = $first_read_id;
            }
            else
            {
                $tree{"START"} = $first_read_id;
                $first_contig_id = $first_read_id;
            }
            if (exists($old_id{$id}))
            {
                $old_id{$old_id{$id}} = $first_read_id;
            }
            goto REF2;
        }
    }
    if ($low_coverage_check > 10 && $bad_read ne "yes2")
    {
        print "\n\nCOVERAGE IS TOO LOW, SHOULD BE MORE THAN 10X\n\n";
        print OUTPUT4 "\n\nCOVERAGE IS TOO LOW, SHOULD BE MORE THAN 10X\n\n";
        if ($batch_file ne "")
        {
            goto BATCH;
        }
        else
        {
            exit;
        }
    }
    if ($build eq "" && $bad_read ne "yes2")
    {
        print OUTPUT5 "BUILD1\n";
        $build = "yes";
        goto REF0;
    }
    elsif ($build eq "yes")
    {
        $build = "yes2";
        print OUTPUT5 "BUILD2\n";
        goto REF0;
    }
    elsif ($hp_back ne "" && length($seed_input_tmp) < 150 && length($read) > 150)
    {
        print OUTPUT5 $seed_input_tmp." BUILD_HP1\n";
        $seed_input_tmp = substr $read, -200, 200;
        $build = "";
        goto REF0;
    }
    elsif ($hp_back ne "" && length($seed_input_tmp) < 300 && length($read) > 300)
    {
        $seed_input_tmp = substr $read, -500, 500;
        print OUTPUT5 "BUILD_HP2\n";
        $build = "";
        goto REF0;
    }
    elsif ($hp_back ne "")
    {
        goto HP0;
    }
    else
    {
        print "\n\nINVALID SEED, PLEASE TRY AGAIN WITH A NEW ONE\n\n";
        print OUTPUT4 "\n\nINVALID SEED, PLEASE TRY AGAIN WITH A NEW ONE\n\n";
        if ($batch_file ne "")
        {
            goto BATCH;
        }
        else
        {
            exit;
        }
    }
}
elsif ($extend_seed_directly eq "yes")
{
    $seed{"seed"} = $seed_input_tmp;
    $read1{$seed_input_tmp} =undef;
    $contig_count{"seed"} = '0';
    $position{"seed"} = length($seed{"seed"});
    $tree{"START"} = "seed";
    $first_contig_id = "seed";
}
elsif ($test_seed ne "")
{
    $seed{"test"} = $test_seed;
    $seeds_check{"test"} = undef;
    $read1{$test_seed} =undef;
    $contig_count{"test"} = '0';
    $position{"test"} = length($seed{"test"});
}
else
{
REF:foreach my $line (keys %hash)
    {
        my $count = '0';
        my $n = '5';
        my @line_read = split /,/, $hash{$line};
        my $line_read = $line_read[0];
        if ($use_quality ne "")
        {
           $line_read =~ tr/1234/ACTG/;
        }

        while ($n < length($line_read) - $overlap)
        {
            my $line_part = substr $line_read, $n, $overlap;
            if (exists($hash2b{$line_part}))
            {
                my @results = split /,/, $hash2b{$line_part};
                foreach (@results)
                {
                    $count++;
                }
            }
            if (exists($hash2c{$line_part}))
            {
                my @results = split /,/, $hash2c{$line_part};
                foreach (@results)
                {
                    $count++;
                }
            }
            if ($count > 10)
            {
                my $line_read2 = $line_read[1];
                my $count2 = '0';
                my $n2 = '5';
                if ($use_quality ne "")
                {
                   $line_read2 =~ tr/1234/ACTG/;
                }
                
                while ($n2 < length($line_read2) - $overlap)
                {
                    my $line_part2 = substr $line_read2, $n2, $overlap;
                    if (exists($hash2b{$line_part2}))
                    {
                        my @results = split /,/, $hash2b{$line_part2};
                        foreach (@results)
                        {
                            $count2++;
                        }
                    }
                    if (exists($hash2c{$line_part2}))
                    {
                        my @results = split /,/, $hash2c{$line_part2};
                        foreach (@results)
                        {
                            $count2++;
                        }
                    }
                    if ($count2 > 10)
                    {                        
                        $seed{$line."1"} = $line_read;
                        $seeds_check{$line."1"} = undef;
                        if ($hp_back eq "")
                        {
                            print "...OK\n";
                        }
                        print "\nInitial read retrieved successfully: ".$line_read."\n";
                        print OUTPUT4 "\nInitial read retrieved successfully: ".$line_read."\n";
                        print OUTPUT5 "\nInitial read retrieved successfully3: ".$line_read."\n";
                        last REF;
                    }          
                    $n2++;   
                }
            }          
            $n++;   
        }
    }
}
close INPUT3;
REF2:
my $seed = "";
my $seed_id = "";
my $match_pair = "";
my $match_pair2 = "";
my $extension = "";
my $extension_match = "";
my $match = "";
my $regex = "";
my @match_pair;
my @matches;
my @matches1;
my @matches2;
my $read_new = "";
my $id_test = "";
my $best_extension = "";
my $best_match2 = "";
my $best_extension1 = "";
my $best_extension2 = "";
my $best_extension3 = "";
my $best_extension4 = "";
my $use_regex = "";
my $use_regex_back = "";
my %extensions1b;
my %extensions2b;
my %extensionsb;
my %extensionsb_original;
my %extensions_for_before;
my %extensions_for_before_match;
my %extensions_for_before_match_pair;
$position = length($seed_input_new2);
my %insert_size2;
my $split = "";
my $merge = "";
my $circle = "";
my $read_test = "";
my $AT_rich = "";
my $id_old = "";
my $read_new1 = "";
my $delete_first = "";
my $delete_second = "";
my $delete_third = "";
my $correct_after_split = "";
my $sc = '0';
my $still_first_seed = "yes";
my $ext_before = "";

foreach (keys %seed)
{
    $sc++;    
}
if ($bad_read eq "" || $sc eq '1')
{
    if ($hp_seed_assemble eq "")
    {
        print "\nStart Assembly...\n\n";
        print OUTPUT4 "\nStart Assembly...\n\n";
    }
}
ITERATION: while ($y < $iterations)
{
    if ($y > $startprint2)
    {
        print OUTPUT5 "\n".$y."\n\n";
    }
    if (!%seed)
    {
        last ITERATION;
    }
    my $length_other_contig = '0';  
    foreach my $contig_tmp (keys %contigs)
    {
        $length_other_contig += length($contigs{$contig_tmp});
    }

    $|=1;
    my $progress = length($read)+$length_other_contig." bp assembled";
    
    print "\b" x length($progress_before);
    print ' ' x length($progress_before);
    print "\b" x length($progress_before);
    $progress_before = $progress;
    print $progress;
    
    if ($still_first_seed ne "yes")
    {
        $still_first_seed = "yes2";
    }
    else
    {
        $still_first_seed = "";
    }

SEED: foreach $seed_id (keys %seed)
{
    if ($still_first_seed ne "yes2" && $hp_seed_assemble eq "")
    {
        my $test_first_seed;
        if ($seed_id =~ m/.*_(\d+)$/)
        {
            $test_first_seed = $1;
        }
        else
        {
            $test_first_seed = $seed_id;
        }
        if ($test_first_seed ne $first_contig_id)
        {
            next SEED;
        }
        $still_first_seed = "yes";
    }
    if ($benchmark_time eq "yes")
    {
        $time_start_seed = time;
    }
SEED2:
    $merge = "";
    $split = "";
    $circle = "";
    $AT_rich = "";

    undef %extensions1b;
    undef %extensions2b;
    undef %extensionsb;
    undef %extensionsb_original;
    undef %extensions_for_before;
    undef %extensions_for_before_match;
    undef %extensions_for_before_match_pair;
    undef @matches;
    undef @matches1;
    undef @matches2;    
    undef %merged_match;
    undef %merged_match_pair;
    undef %merged_match_pair_back;
    undef %merged_match1;
    undef %merged_match2;
    undef %merged_match_pos;
    undef %merged_match_back;
    undef %merged_match_back1;
    undef %merged_match_back2;
    undef %merged_match_back_pos;
    undef %read_end;
    undef %read_end_b;
    undef %read_start;
    undef %read_start_b;
    undef %read_short_end_tmp;
    undef %read_short_start_tmp;
    undef %read_short_end_tmp2;
    undef %read_short_start_tmp2;
    undef %SNR_length;
    undef %allele_percentage;
    undef %allele_percentage_back;
    undef %accepted_SNPs;
    undef %accepted_SNPs_back;
    undef %accepted_SNPs_pair;
    undef %accepted_SNPs_pair_back;
    undef %remove_extension_mismatch;
    undef %remove_extension_mismatch_tmp;
    undef %hp_SNP_links;
    undef %hp_SNP_links_back;
    undef %SNP_to_assemble;
    undef %exlude_id_prev_nuc_hp;
    undef %exlude_id_prev_nuc_hp_back;
    undef %hp_indel_ratio;
    $containX_short_end2 = '0';
    $contain_dot_short_end2 = '0';
    $containX_short_start2 = '0';
    $contain_dot_short_start2 = '0';
    $delete_first = "";
    $delete_second = "";
    $delete_third = "";
    my $merge_read = "";
    my $merge_read_pair = "";
    my $merge_read_length = '0';
    $SNR_read = "";
    $SNR_read2 = "";
    $SNR_read_back = "";
    $SNR_read_back2 = "";
    $SNR_read_ahead = "";
    $SNR_read_back_ahead = "";
    $split_forward = "";
    $split_forward_tmp = "";
    $deletion = "";
    $deletion_back = "";
    $reference_guided = "";
    $reference_guided_back = "";
    $repetitive_detect = "";
    $repetitive_detect_back = "";
    $repetitive_detect2 = "";
    $repetitive_detect_back2 = "";
    $contig_end = "";
    $repetitive = "";
    $before_repetitive = "";
    $before_repetitive_short = "";
    $CP_check = "";
    $before_extension1 = "";
    $before_extension2 = "";
    $before_extension_back1 = "";
    $before_extension_back2 = "";
    $no_contig_id2 = "";
    $no_contig_id1 = "";
    $no_contig_id3 = "";
    $no_contig_id4 = "";
    $rep_detect2 = "";
    $no_next_seed = "";
    $count_split = "";
    $yuyu_option_A = "";
    $yuyu_option_C = "";
    $yuyu_option_T = "";
    $yuyu_option_G = "";
    $yuyu_option_A_back = "";
    $yuyu_option_C_back = "";
    $yuyu_option_T_back = "";
    $yuyu_option_G_back = "";
    $extensions_before = "";
    $SNR_next_seed = "";
    $ext_before = "";
    $AT_rich_before = "";
    $AT_rich_before_back = "";
    $SNR_nucleo = "";
    $SNR_nucleo_back = "";
    $merge_now = "";
    $use_regex = "";
    $use_regex_back = "";
    $best_extension_old1 = "";
    $best_extension_old2 = "";
    $best_extension_old3 = "";
    $best_extension_old4 = "";
    $reference_next_seed = "";
    $next_seed_ref = "";
    $ref_skip_before = "";
    $ref_skip_before_back = "";
    $best_extension_forward = "";
    $noforward_HP = "";
    $noback_HP = "";
    $NUMT = "";
    $NUMT_back = "";
    $no_large_variance_forward = "";
    $no_large_variance_back = "";
    $long_repeat_forward = "";
    $long_repeat_back = "";
    $large_variance_tmp = "";
    $large_variance_tmp_back = "";
    $ref_check_forward = "";
    $ref_check_back = "";
    $first_without_LV = "";
    $first_without_LV_back = "";
    $save_seq_ref_forward = "";
    $save_seq_ref_back  = "";
    $no_quality = "";
    $no_quality_back = "";
    $get_more_matches = "";
    $get_more_matches_back = "";
    $last_chance_SNR = "";
    $last_chance_SNR_back = "";
    $best_extension1_count = '0';
    $best_extension2_count = '0';
                                                            
                                                                    if ($heteroplasmy ne "")
                                                                    {
                                                                        my $j = '0';
                                                                        $last_SNP_hp = "";
                                                                        foreach my $SNP_tmp (sort {$b <=> $a} keys %SNPs)
                                                                        {
                                                                            if ($j < 10)
                                                                            {
                                                                                if ($last_SNP_hp eq "")
                                                                                {
                                                                                    $last_SNP_hp = $SNP_tmp;
                                                                                }
                                                                                print OUTPUT5 $SNP_tmp." SNP_test\n";
                                                                            }
                                                                            $j++;
                                                                        }
                                                                        my $v = '0';
                                                                        foreach my $SNP_tmp (sort {$b <=> $a} keys %noSNPs)
                                                                        {
                                                                            if ($v < 10)
                                                                            {
                                                                                print OUTPUT5 $SNP_tmp." noSNP_test\n";
                                                                            }
                                                                            $v++;
                                                                        }
                                                                    }
    
    if (exists($insert_size2{$seed_id}))
    {
        $insert_size = $insert_size2{$seed_id};
    }
    
    if (exists($seed{$seed_id}))
    {
        $seed = $seed{$seed_id};
           
        if ($y > $startprint2)
        {
            print OUTPUT5 "\n".$seed_id." SEED_exists\n\n";
            print OUTPUT5 length($seed)." READ_LENGTH\n";
        }
        
        $id = $seed_id;
        $read = $seed;

        if (exists($noforward{$id}) || ($hp_back ne "" && ($position > $insert_size || $y > 30)))
        {
            $noforward = "stop";
            if ($noforward{$id} eq "stop_HP")
            {
                $noforward_HP = "yes";
            }
        }
        else
        {
            $noforward = "";
        }
        my $check_old_id = "";
        if (exists($old_id{$id}))
        {
            $check_old_id = "yes";
        }
        if (exists($noback{$id}) || (length($read) < $insert_size && $noforward eq "" && $check_old_id eq "" && $hp_seed_assemble ne "yes2" && $hp_back ne "yes2") || ($hp_back eq "" && $heteroplasmy ne "" && $hp_seed_assemble eq ""))
        {
            $noback = "stop";
            if ($noback{$id} eq "stop_HP")
            {
                $noback_HP = "yes";
            }
        }
        else
        {
            $noback = "";
        }  
        if ($platform eq "ion")
        {
            my $SNR_end_ion = substr $read, -4;
            my $SNR_check_ion = $SNR_end_ion =~ s/AAAA|CCCC|GGGG|TTTT//;
            if ($SNR_check_ion > 0)
            {
                $SNR_read = "yes";
                $SNR_nucleo = substr $read, -1, 1;
                my $SNR_end_ion2 = substr $read, -6;
                my $SNR_check_ion2 = $SNR_end_ion2 =~ s/AAAAAA|CCCCCC|GGGGGG|TTTTTT//;
                if ($SNR_check_ion2 > 0)
                {
                    $read .= "*";
                }
            }
            my $SNR_end_ion_back = substr $read, 0, 4;
            my $SNR_check_ion_back = $SNR_end_ion_back =~ s/AAAA|CCCC|GGGG|TTTT//;
            if ($SNR_check_ion_back > 0)
            {
                $SNR_read_back = "yes";
                $SNR_nucleo_back = substr $read, 0, 1;
            }
        }
        if ($noforward eq "")
        {
            my $SNR_end0 = substr $read, -20, 20;
            $SNR_end0 =~ s/.\*//g;
            my $SNR_end0t = substr $read, -50, 50;
            $SNR_end0t =~ s/.\*//g;
            $SNR_end0 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            $SNR_end0t =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            my @SNR_end0 = split //, $SNR_end0;
            my $u0 = length($SNR_end0);

            my @SNR_nucleo = ("A","C","T","G");
ALREADY_X0: foreach my $SNR_nucleo_tmp (@SNR_nucleo)
            {
                my $v0 = '1';
                my $other = "";
                my $count_dot = '0';
                while ($v0 < $u0)
                {              
                    if (($SNR_end0[$u0-$v0-1] eq $SNR_nucleo_tmp || $SNR_end0[$u0-$v0] eq $SNR_nucleo_tmp) && $SNR_end0[$u0-$v0-1] eq $SNR_end0[$u0-$v0] || (($SNR_end0[$u0-$v0-1] eq "." || $SNR_end0[$u0-$v0] eq ".") && ($count_dot < 5 || ($count_dot < 8 && $other eq ""))))
                    {
                        if ($SNR_end0[$u0-$v0-1] eq "." || $SNR_end0[$u0-$v0] eq ".")
                        {
                            $v0 += 0.5;
                        }
                        else
                        {
                            $v0++;
                        }
                        if(($v0 > 6 && $other eq "") || $v0 > 8)
                        {
                            $SNR_read = "yes";
                            $SNR_nucleo = $SNR_nucleo_tmp;
                            if ($SNR_end0[$u0-1] eq $SNR_nucleo || $SNR_end0[$u0-2] eq $SNR_nucleo || $SNR_end0[$u0-3] eq $SNR_nucleo)
                            {
                                $SNR_read2 = "yes";
                            }
                            last ALREADY_X0;
                        }
                        if ($SNR_end0[$u0-$v0] eq ".")
                        {
                            $count_dot++;
                        }
                    }
                    elsif(($v0 > 6 && $other eq "") || $v0 > 9)
                    {     
                        $SNR_read = "yes";
                        $SNR_nucleo = $SNR_nucleo_tmp;
                        if ($SNR_end0[$u0-1] eq $SNR_nucleo || $SNR_end0[$u0-2] eq $SNR_nucleo || $SNR_end0[$u0-3] eq $SNR_nucleo)
                        {
                            $SNR_read2 = "yes";
                        }
                        last ALREADY_X0;
                    }
                    elsif($other eq "")
                    {     
                        $other = "yes";    
                        $v0 += 2;
                    }
                    else
                    {     
                        if ($platform ne "ion")
                        {
                            $SNR_read = "";
                        }
                        next ALREADY_X0;
                    }
                }
            }
            if ($SNR_read eq "")
            {
                my $SNR_check = $SNR_end0t =~ s/AAAAAAAAA|CCCCCCCCC|GGGGGGGGG|TTTTTTTTT|TATATATATATATATA//;
                my $check_AT = $SNR_end0t =~ tr/CG/CG/;
                if ($SNR_check > 0 || $check_AT eq '0')
                {
                    $SNR_read = "yes"; 
                }
            }
        }
        if ($noback eq "")
        {        
            my $SNR_end0b = substr $read, 0, 20;
            my $SNR_end0bt = substr $read, 0, 50;
            $SNR_end0b =~ s/.\*//g;
            $SNR_end0bt =~ s/.\*//g;
            $SNR_end0b =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            $SNR_end0bt =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            my @SNR_end0b = split //, $SNR_end0b;
            
            my @SNR_nucleob = ("A","C","T","G");
ALREADY_X0b:foreach my $SNR_nucleo_tmp (@SNR_nucleob)
            {                    
                my $v0b = '1';
                my $otherb = "";
                my $count_dotb = '0';
                while ($v0b < length($SNR_end0b))
                {              
                    if (($SNR_end0b[$v0b] eq $SNR_nucleo_tmp || $SNR_end0b[$v0b-1] eq $SNR_nucleo_tmp) && $SNR_end0b[$v0b-1] eq $SNR_end0b[$v0b] || (($SNR_end0b[$v0b] eq "." || $SNR_end0b[$v0b-1] eq ".") && ($count_dotb < 5 || ($count_dotb < 8 && $otherb eq ""))))
                    {
                        if ($SNR_end0b[$v0b] eq "." || $SNR_end0b[$v0b-1] eq ".")
                        {
                            $v0b += 0.5;
                        }
                        else
                        {
                            $v0b++;
                        }
                        if(($v0b > 6 && $otherb eq "") || $v0b > 8)
                        {     
                            $SNR_read_back = "yes";
                            $SNR_nucleo_back = $SNR_nucleo_tmp;
                            if ($SNR_end0b[0] eq $SNR_nucleo_back)
                            {
                                $SNR_read_back2 = "yes";
                            }
                            last ALREADY_X0b;
                        }
                        if ($SNR_end0b[$v0b-1] eq ".")
                        {
                            $count_dotb++;
                        }
                    }
                    elsif(($v0b > 6 && $otherb eq "") || $v0b > 9)
                    {     
                        $SNR_read_back = "yes";
                        $SNR_nucleo_back = $SNR_nucleo_tmp;
                        if ($SNR_end0b[0] eq $SNR_nucleo_back)
                        {
                            $SNR_read_back2 = "yes";
                        }
                        last ALREADY_X0b;
                    }
                    elsif($otherb eq "")
                    {     
                        $otherb = "yes"; 
                        $v0b += 2;
                    }
                    else
                    {     
                        if ($platform ne "ion")
                        {
                            $SNR_read_back = "";
                        }
                        next ALREADY_X0b;
                    }
                }
            }
            if ($SNR_read_back eq "")
            {
                my $SNR_check = $SNR_end0bt =~ s/AAAAAAAAA|CCCCCCCCC|GGGGGGGGG|TTTTTTTTT|TATATATATATATATA//;
                my $check_AT = $SNR_end0bt =~ tr/CG/CG/;
                if ($SNR_check > 0 || $check_AT eq '0')
                {
                    $SNR_read_back = "yes"; 
                }
            }
        }
        
        $contig_count = $contig_count{$id};
        
        if (exists($position{$id}))
        {
            $position = $position{$id};
        }
        if (exists($position_back{$id}))
        {
            $position_back = $position_back{$id};
        }
        
        $read_short_end2 = substr $read, -$read_length-200;
        $read_short_start2 = substr $read, 0, $read_length+200;
        $read_short_end2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./; 
        $read_short_start2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
        $containX_short_end2 = $read_short_end2 =~ tr/X|\*//;
        $contain_dot_short_end2 = $read_short_end2 =~ tr/\.//;
        $containX_short_start2 = $read_short_start2 =~ tr/X|\*//;
        $contain_dot_short_start2 = $read_short_start2 =~ tr/\.//;
        
        if (($y eq '1' || exists($old_id2{$id}) || exists($bad_read{$id})) && $hp_seed_assemble eq "")
        {
            delete $bad_read{$id};

            $position{$id} = length($read);
            $position = length($read);
            $position_back = '0';
            $position_back{$id} = '0';
            delete $old_id2{$id};
            $read =~ s/\s+$//;
            $read =~ s/\t+$//;
        }
        if ($hp_seed_assemble ne "")
        {
            my $test_star = substr $read, -($position-$last_SNP_hp);
            my $containX_hp = $test_star =~ tr/\*//;
            if ($containX_hp > 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)
            {
                $NUMT = "yes";
            }
        }
        if ($y eq '2')
        {
            my $start_point = '25'; 
            $first_contig_start_reverse = substr $read, $start_point, $overlap;
            $first_contig_start_reverse =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

            my $check_start = $first_contig_start_reverse =~ tr/\./\./;
            while ($check_start > 0)
            {
                $start_point += 5;
                $first_contig_start_reverse = substr $read, $start_point, $overlap;
                $check_start = $first_contig_start_reverse =~ tr/\./\./;
            }
            $first_contig_start_reverse = reverse($first_contig_start_reverse);
            $first_contig_start_reverse =~ tr/ATCG/TAGC/;
        }    
            
        if ($y > $startprint2)
        {
            print OUTPUT5 $insert_size." INSERT_SIZE\n\n";
            print OUTPUT5 $position." POSITION\n";
            print OUTPUT5 $position_back." POSITION_BACK\n";
        }
        if ($use_regex eq "")
        {
            my $read_end_dot = substr $read_short_end2, -($read_length-($overlap+$left+1-$containX_short_end2-$containX_short_end2));
            my $read_end_dot_check = '0';
            $read_end_dot_check = $read_end_dot =~ tr/\./\./;
            if ($read_end_dot_check > 0)
            {
                $use_regex = "yes2";
            }
        }
        if ($use_regex_back eq "")
        {
            my $read_start_dot = substr $read_short_start2, 0, ($read_length-($overlap+$left+1-$containX_short_end2-$containX_short_end2));
            my $read_start_dot_check = '0';
            $read_start_dot_check = $read_start_dot =~ tr/\./\./;
            if ($read_start_dot_check > 0)
            {
                $use_regex_back = "yes2";
            }
        }         

        if (exists($SNR_read{$id}) && $SNR_read eq "")
        {
            $SNR_read = "yes";
            delete $SNR_read{$id};
        }
        if (exists($SNR_read_back{$id}) && $SNR_read_back eq "")
        {
            $SNR_read_back = "yes";
            delete $SNR_read_back{$id};
        }
        if ($SNR_read ne "")
        {
            if ($y > $startprint2)
            {
                print OUTPUT5 $SNR_nucleo." SNR_READ\n";
            }
        }
        if ($SNR_read2 ne "")
        {
            if ($y > $startprint2)
            {
                print OUTPUT5 "SNR_READ2\n";
            }
        }
        if ($SNR_read_back ne "")
        {
            if ($y > $startprint2)
            {
                print OUTPUT5 $SNR_nucleo_back." SNR_BACK_READ\n";
            }
        }
        if (exists($regex{$id}))
        {
            $use_regex = $regex{$id};
        }
        elsif ($use_regex ne "yes2")
        {
            $use_regex = "";
        }
        if (exists($before{$id}))
        {
            $before = $before{$id};
            if ($y > $startprint2)
            {
                print OUTPUT5 "BEFORE\n";
            } 
        }
        else
        {
            $before = "";
        }
        if (exists($before_back{$id}))
        {
            $before_back = $before_back{$id};
            if ($y > $startprint2)
            {
                print OUTPUT5 "BEFORE_BACK\n";
            }
        }
        else
        {
            $before_back = "";
        }
        if (exists($regex_back{$id}))
        {
            $use_regex_back = $regex_back{$id};
        }
        elsif ($use_regex_back ne "yes2")
        {
            $use_regex_back = "";
        }  
        if ((exists($last_chance{$id}) || (length($read) < $insert_size && $hp_seed_assemble_last_chance_forward eq "" && ($hp_seed_assemble eq "" || length($read) < $insert_size*0.8)) || $paired eq "SE") && $noforward eq "")
        {
            $last_chance = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "LAST_CHANCE\n";
            }
        }
        elsif ($SNR_go_last_chance eq "")
        {
            $last_chance = "";
        }
        if (exists($last_chance_back{$id}) || (length($read) < $insert_size*1.5 && $noback ne "stop" && $noforward eq "stop" && $hp_seed_assemble_last_chance_back eq "" && ($hp_seed_assemble eq "" || length($read) < $insert_size*0.8)) || $paired eq "SE")
        {
            $last_chance_back = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "LAST_CHANCE_BACK\n";
            }
        }
        else
        {
            $last_chance_back = "";
        }
        if ((exists($SNP_active{$id}) || $hp_back ne "") && $noforward eq "")
        {
            $SNP_active = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "SNP_ACTIVE\n";
            }
        }
        else
        {
            $SNP_active = "";
        }
        if (exists($SNP_active_back{$id}) && $noback eq "")
        {
            $SNP_active_back = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "SNP_ACTIVE_BACK\n";
            }
        }
        else
        {
            $SNP_active_back = "";
        }
        if (exists($nosecond{$id}))
        {
            $nosecond = "yes";
        }
        else
        {
            $nosecond = "";
        }
        if (exists($before_shorter_skip{$id}))
        {
            $before_shorter_skip = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "BEFORE SHORTER\n";
            }
        }
        else
        {
            $before_shorter_skip = "";
        }
        if (exists($before_shorter_skip_back{$id}))
        {
            $before_shorter_skip_back = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "BEFORE SHORTER BACK\n";
            }
        }
        else
        {
            $before_shorter_skip_back = "";
        }
        if (exists($jump_rep{$id}))
        {
            $jump_rep = "yes";
            $repetitive_detect = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "JUMP REP\n";
            }
        }
        else
        {
            $jump_rep = "";
        }
        if (exists($jump_rep_because_stuck{$id}))
        {
            $jump_rep_because_stuck = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "JUMP REP BECAUSE STUCK\n";
            }
        }
        else
        {
            $jump_rep_because_stuck = "";
        }
        if (exists($jump_rep_back{$id}))
        {
            $jump_rep_back = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "JUMP REP BACK\n";
            }
        }
        else
        {
            $jump_rep_back = "";
        }
        if (exists($reference_next_seed{$id}))
        {
            $reference_next_seed = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "REF NEXT SEED\n";
            }
            delete $reference_next_seed{$id};
        }
        else
        {
            $reference_next_seed = "";
        }
        
        if (exists($no_next_seed{$id}))
        {
            $no_next_seed = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "NO NEXT SEED\n";
            }
        }
        else
        {
            $no_next_seed = "";
        }
        
        if (exists($large_variance_forward{$id}) && $hp_seed_assemble ne "")
        {
            if ($NUMT{$id} > $read_length-30)
            {
                $NUMT = "yes";
                if ($y > $startprint2)
                {
                    print OUTPUT5 $NUMT{$id}." NUMT\n";
                }
            }
            if ($NUMT{$id} > 150)
            {
                $NUMT = "yes2";
                if ($y > $startprint2)
                {
                    print OUTPUT5 "NUMT2\n";
                }
            }
            if ($NUMT{$id} > 1000)
            {
                $noforward = "stop";
                $noforward{$id} = "stop_HP";
            }
        }
        else
        {
            delete $NUMT{$id};
        }
        if (exists($large_variance_back{$id}) && $hp_seed_assemble ne "")
        {
            if ($NUMT_back{$id} > $read_length-30)
            {
                $NUMT_back = "yes";
                if ($y > $startprint2)
                {
                    print OUTPUT5 $NUMT_back{$id}." NUMT_BACK\n";
                }
            }
            if ($NUMT_back{$id} > 150)
            {
                $NUMT_back = "yes2";
                if ($y > $startprint2)
                {
                    print OUTPUT5 "NUMT_BACK2\n";
                }
            }
            if ($NUMT_back{$id} > 1000)
            {
                $noback = "stop";
                $noback{$id} = "stop_HP";
            }
        }
        else
        {
            delete $NUMT_back{$id};
        }
        if (exists($no_large_variance_forward{$id}))
        {
            $no_large_variance_forward = $no_large_variance_forward{$id};
            if ($y > $startprint2)
            {
                print OUTPUT5 $no_large_variance_forward." NO_LARGE_VARIANCE_FORWARD\n";
            }
        }
        if (exists($no_large_variance_back{$id}))
        {
            $no_large_variance_back = $no_large_variance_back{$id};
            if ($y > $startprint2)
            {
                print OUTPUT5 $no_large_variance_back." NO_LARGE_VARIANCE_BACK\n";
            }
        }
        if ($last_150 ne "" && length($read) > $last_150+130)
        {
            $noforward{$id} = "stop";
            $noforward = "stop";
            $no_next_seed = "yes";
        }
        if ($first_150 ne "" && length($read) > $first_150+200)
        {
            $first_150 = "";
        }
        if (exists($SNR_critical{$id}))
        {
            $SNR_critical = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "SNR_critical\n";
            }
            delete $SNR_critical{$id};
        }
        else
        {
            $SNR_critical = "";
        }
        if (exists($SNR_critical_back{$id}))
        {
            $SNR_critical_back = "yes";
            if ($y > $startprint2)
            {
                print OUTPUT5 "SNR_critical_back\n";
            }
            delete $SNR_critical_back{$id};
        }
        else
        {
            $SNR_critical_back = "";
        }
        if ($no_hp_one_turn ne "")
        {
            print OUTPUT5 $no_hp_one_turn." NO_HP_ONE_TURN\n";
        }


        if (exists($yuyu_option{$id."A"}))
        {
            $yuyu_option_A = "A";                        
        }
        if (exists($yuyu_option{$id."C"}))
        {
            $yuyu_option_C = "C";         
        }
        if (exists($yuyu_option{$id."G"}))
        {
            $yuyu_option_G = "G";         
        }
        if (exists($yuyu_option{$id."T"}))
        {
            $yuyu_option_T = "T";         
        }
        
        if (exists($yuyu_option_back{$id."A"}))
        {
            $yuyu_option_A_back = "A";                        
        }
        if (exists($yuyu_option_back{$id."C"}))
        {
            $yuyu_option_C_back = "C";         
        }
        if (exists($yuyu_option_back{$id."G"}))
        {
            $yuyu_option_G_back = "G";         
        }
        if (exists($yuyu_option_back{$id."T"}))
        {
            $yuyu_option_T_back = "T";         
        }
        if ($hp_seed_assemble ne "")
        {
            my $count_back_hp = '0';
            my $count_forward_hp = '0';
            foreach my $SNP_tmp  (sort {$a <=> $b} keys %SNPs)
            {
                if ($SNP_tmp < -$position_back+140)
                {
                    $count_back_hp++;
                }
                if ($SNP_tmp > $position-140)
                {
                    $count_forward_hp++;
                }
            }
            if (exists($NUMT_back{$id}) && $NUMT_back eq "")
            {
                $NUMT_back = "maybe";
            }
            elsif ($count_back_hp > 15 && $NUMT_back eq "")
            {
                $NUMT_back = "maybe";
                $NUMT_back{$id} = $position_back;
            }
            if (exists($NUMT{$id}) && $NUMT eq "")
            {
                $NUMT = "maybe";
            }
            elsif ($count_forward_hp > 15 && $NUMT eq "")
            {
                $NUMT = "maybe";
                $NUMT{$id} = $position;
            }
        }

        if ($noback ne "stop")
        {
            my $start_repetitive = substr $read, $overlap, $insert_size+100;
            my $start_repetitiveb = substr $read, 200, 5000;
            $start_repetitive =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            $start_repetitiveb =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            my $repetitive_test = substr $read_short_start2, 0, 15;
            my $repetitive_testb = substr $read_short_start2, 0, 200;
            my $SNR_skip = "yes";                                        
            my $u = '0';
            while ($SNR_skip eq "yes")
            { 
                $repetitive_test = substr $read_short_start2, $u, 15;
                my $SNR_checkA = $repetitive_test =~ tr/A/A/;
                my $SNR_checkC = $repetitive_test =~ tr/C/C/;
                my $SNR_checkT = $repetitive_test =~ tr/T/T/;
                my $SNR_checkG = $repetitive_test =~ tr/G/G/;
                my $SNR_checkdot = $repetitive_test =~ tr/\./\./;
                if ($SNR_checkA+$SNR_checkdot > 11 || $SNR_checkC+$SNR_checkdot > 11 || $SNR_checkG+$SNR_checkdot > 11 || $SNR_checkT+$SNR_checkdot > 11)
                {
                    $SNR_skip = "yes";
                    $u += 10;
                }
                else
                {
                    $SNR_skip = "";
                }
            }
            $repetitive_test =~ tr/\*//d;
            $repetitive_testb =~ tr/\*//d;
            $start_repetitiveb =~ tr/\*//d;
            my $check_repetitive = $start_repetitive =~ s/$repetitive_test/$repetitive_test/g;
            my $check_repetitiveb = $start_repetitiveb =~ s/$repetitive_testb/$repetitive_testb/g;
            
            if (exists ($rep_return_back{$id}))
            {
                $repetitive_detect_back = "yes2";
                if ($rep_return_back{$id} < $position_back-(2*$read_length))
                {
                    delete $rep_return_back{$id};
                }
                if ($y > $startprint2)
                {
                    print OUTPUT5 "DETECT_REPETITIVE_BACK_RETURN\n";
                    print OUTPUT5 $start_repetitive." START_READ\n";
                }
            }
            if ($check_repetitive > 1 || $check_repetitiveb > 0)
            {
                if ($check_repetitive < 2 || $check_repetitiveb > 2)
                {
                    $long_repeat_back = "yes";
                    print OUTPUT5 "LONG_REPEAT_BACK\n";
                }
                if (exists ($rep_return_back{$id}))
                {
                }
                elsif (length($read) > $insert_size+200 && $heteroplasmy eq "")
                {
                    substr $read, 0, ($read_length+50), "";
                    $seed{$id} = $read;
                    $seeds_check{$id} = undef;
                    $position_back{$id} = $position_back-($read_length+50);
                    $rep_return_back{$id} = $position_back;
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "RETURN_REPETITIVE_BACK\n";
                    }
                    goto SEED;
                }
                $repetitive_detect_back = "yes";
                if ($y > $startprint2)
                {
                    print OUTPUT5 "DETECT_REPETITIVE_back\n";
                    print OUTPUT5 $start_repetitive." START_READ\n";
                }
                if ($stuck_in_rep_back_before eq "")
                {
                    $stuck_in_rep_back_before = substr $read, 500, 500;
                }

                my $start_repetitive1 = substr $read, $insert_size+50, 300;
                my $check_repetitive1= $start_repetitive1 =~ s/$repetitive_test/$repetitive_test/g;
                
                if ($check_repetitive1 > 1 || $check_repetitiveb > 1)
                {
                    $repetitive_detect_back2 = "yes";
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "DETECT_REPETITIVE_back2\n";
                    }
                    my $repetitive_test_stop = substr $read_short_start2, 0, 30;
                    my $start_repetitive_stop = substr $read, 0, $insert_size+550;
                    my $start_repetitive_stopb = substr $read, 200, 8000;
                    my $check_repetitive_stop = $start_repetitive_stop =~ s/$repetitive_test_stop/$repetitive_test_stop/g;
                    my $check_repetitive_stopb = $start_repetitive_stopb =~ s/$repetitive_testb/$repetitive_testb/g;
                    if ($check_repetitive_stop > 3 || $check_repetitive_stopb > 2)
                    {
                        $noback = "stop";
                        $noback{$id} = "stop";
                        $read = substr $read, $read_length;
                        $stuck_in_rep_back = "yes";
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "STUCK_IN_REP_BACK\n";
                        }
                    }
                }
            }
        }
        if ($stuck_in_rep_back_before ne "" && $repetitive_detect_back eq "" && $noback eq "")
        {
            $stuck_in_rep_back_before = "";
        }
        if ($noforward ne "stop")
        {
            my $end_repetitive = substr $read, -$insert_size-100,-$overlap;
            my $end_repetitiveb = substr $read, -5000,-$insert_size;
            $end_repetitive =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            $end_repetitiveb =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            my $repetitive_test2 = substr $read_short_end2, -15;
            my $repetitive_test2b = substr $read_short_end2, -200;
            my $SNR_skip = "yes";                                        
            my $u = '15';
            while ($SNR_skip eq "yes")
            { 
                $repetitive_test2 = substr $read_short_end2, -$u, 15;
                my $SNR_checkA = $repetitive_test2 =~ tr/A/A/;
                my $SNR_checkC = $repetitive_test2 =~ tr/C/C/;
                my $SNR_checkT = $repetitive_test2 =~ tr/T/T/;
                my $SNR_checkG = $repetitive_test2 =~ tr/G/G/;
                my $SNR_checkdot = $repetitive_test2 =~ tr/\./\./;
                if ($SNR_checkA+$SNR_checkdot > 11 || $SNR_checkC+$SNR_checkdot > 11 || $SNR_checkG+$SNR_checkdot > 11 || $SNR_checkT+$SNR_checkdot > 11)
                {
                    $SNR_skip = "yes";
                    $u += 10;
                }
                else
                {
                    $SNR_skip = "";
                }
            }
           
            $repetitive_test2 =~ tr/\*//d;
            $repetitive_test2b =~ tr/\*//d;
            $end_repetitiveb =~ tr/\*//d;
            
            my $check_repetitive2 = $end_repetitive =~ s/$repetitive_test2/$repetitive_test2/g;
            my $check_repetitive2b = $end_repetitiveb =~ s/$repetitive_test2b/$repetitive_test2b/g;

            if (exists ($rep_return{$id}))
            {
                $repetitive_detect = "yes2";
                if ($y > $startprint2)
                {
                    print OUTPUT5 "DETECT_REPETITIVE_RETURN\n";
                    print OUTPUT5 $end_repetitive." END_READ\n";
                }
                if ($rep_return{$id} < $position-(2*$read_length))
                {
                    delete $rep_return{$id};
                }
            }
            if ($check_repetitive2 > 1 || $check_repetitive2b > 0)
            {
                if ($check_repetitive2 < 2 || $check_repetitive2b > 2)
                {
                    $long_repeat_forward = "yes";
                    print OUTPUT5 "LONG_REPEAT_FORWARD\n";
                }
                if (exists ($rep_return{$id}))
                {
                }
                elsif (length($read) > $insert_size+200 && $heteroplasmy eq "")
                {
                    substr $read, -($read_length+50), ($read_length+50), "";
                    $seed{$id} = $read;
                    $seeds_check{$id} = undef;
                    $position{$id} = $position-($read_length+50);
                    $rep_return{$id} = $position;
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "RETURN_REPETITIVE\n";
                    }
                    goto SEED;
                }
                $repetitive_detect = "yes";
                if ($y > $startprint2)
                {
                    print OUTPUT5 "DETECT_REPETITIVE\n";
                    print OUTPUT5 $end_repetitive." END_READ\n";
                }

                my $end_repetitive1 = substr $read, -$insert_size-350, 300;
                my $check_repetitive21 = $end_repetitive1 =~ s/$repetitive_test2/$repetitive_test2/g;
                
                if ($check_repetitive21 > 1 || $check_repetitive2b > 1)
                {
                    $repetitive_detect2 = "yes";
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "DETECT_REPETITIVE2\n";
                    }
                    my $repetitive_test_stop = substr $read_short_end2, -30;
                    my $end_repetitive_stopb = substr $read, -8000,-200;
                    my $check_repetitive_stopb = $end_repetitive_stopb =~ s/$repetitive_test2b/$repetitive_test2b/g;
                    if ($check_repetitive_stopb > 2 && ($jump_rep_because_stuck ne "yes" || $count_stuck_in_rep > 9))
                    {
                        $jump_rep_because_stuck = "yes";
                        $jump_rep_because_stuck{$id} = "yes";
                    }
                    elsif ($check_repetitive_stopb > 2)
                    {
                        $noforward = "stop";
                        $noforward{$id} = "stop";
                        $no_next_seed = "yes";
                        $no_next_seed{$id} = "yes";
                        $read = substr $read, 0, -$read_length;
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "STUCK_IN_REP\n";
                        }
                    }
                }
            }
        }
        if ($y > $startprint2 && $benchmark_time eq "yes")
        {
            $time_before_merge = time;            
            if ($time_before_merge - $time_start_seed > 1)
            {
                print OUTPUT5 $time_before_merge - $time_start_seed." TIME0\n";
            }
        }
MERGE:
        my $merge_extra = '0';
        if ($y > $startprint2)
        {    
            if (exists($old_id{$id}))
            {
                print OUTPUT5 $old_id{$id}." OLD_ID\n";
            }
            if (exists($old_rep{$id}))
            {
                print OUTPUT5 "OLD_REP\n";
            }
        }
        if (exists $old_id{$id} && exists $old_rep{$id})
        {
            if ($position_back > $read_length && $position_back < ($insert_size*3) && $repetitive_detect_back eq "" && $noback ne "stop")
            {
                my $read_oldie = $seed_old{$old_id{$id}};
                my $read_newest = $read;
                                                            
                my $start_seq = substr $read, 0, $insert_size*3;
                my $start_seq1 = substr $read, 0, 39;
                my $start_seq2 = substr $read, 30, 39;
                my $end_seq = substr $read_oldie, -$insert_size*3;
                $merge_read_length = length ($read);
                $start_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $start_seq1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $start_seq2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $end_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
      
                if ($end_seq =~ m/.*.$start_seq1(.*)$/)
                {
                    my $r = length($1);
                    my $read_temp = $read;
                    my $read1 = substr $read_oldie, 0, -39-$r;         
    
                    $read = $read1.$read_temp;                                                      
                    $merge_read = "yes";
                }
                elsif ($end_seq =~ m/.*.$start_seq2(.*)$/)
                {
                    my $r = length($1);
                    my $read_temp = $read;
                    my $read1 = substr $read_oldie, 0, -39-$r;         
                    my $read2 = substr $read_temp, 30;
                    
                    $read = $read1.$read2;                                      
                    $merge_read = "yes";
                }
                if ($merge_read eq "yes")
                {            
                    $seed{$id} = $read;
                    $seeds_check{$id} = undef;
                    delete $tree{$old_id{$id}};
                    
                    foreach my $tree_tmp (keys %tree)
                    {
                        my $old = $old_id{$id};
                        my $tree2 = $tree{$tree_tmp};
                        my $tree3 = $tree{$tree_tmp};

                        if ($old_id{$id} =~ m/.*_(\d+)$/)
                        {
                            $old = $1;
                        }
                        my $id_tmp = $id;
                        if ($id =~ m/.*_(\d+)$/)
                        {
                            $id_tmp = $1;
                        }
                        my @ids_split = split /\*/, $tree2;
                        foreach my $id_split (@ids_split)
                        {
                            if ($id_split  =~ m/^$old(REP)*$/)
                            {
                                if ($tree2 =~ m/^(.*\*)*$old(REP)*(\*.*)*$/)
                                {
                                    if (defined($1))
                                    {
                                        $tree3 = $1.$id_tmp;
                                    }
                                    else
                                    {
                                        $tree3 = $id_tmp;
                                    }
                                    if (defined($2))
                                    {
                                        $tree3 = $tree3."REP";
                                    }
                                    if (defined($3))
                                    {
                                        $tree3 = $tree3.$3;
                                    }
                                }
                            }
                        }
                        delete $tree{$tree_tmp};
                        $tree{$tree_tmp} = $tree3;
                        foreach my $contigs_end (keys %contigs_end)
                        {
                            if ($contigs_end{$contigs_end} eq $old)
                            {
                                delete $contigs_end{$contigs_end};
                                $contigs_end{$contigs_end} = $id_tmp;
                            }
                        }
                    }
                    delete $old_id{$id};
                    delete $old_rep{$id};
                    delete $old_rep_old{$old_id{$id}};
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "Merged both contigs rep!\n";
                        print OUTPUT5 ">".$read_newest."\n";
                    }            
                    $noback = "stop";
                    $noback{$id} = "stop";
                    $merge_extra = $position;
                }
            }
            elsif ((($noback eq "stop" || $position_back >= ($insert_size*3)) && $position > $insert_size+200) || $merge_now ne "")
            {
                my $id_tmp = $id;
                if ($id =~ m/.*_(\d+)$/)
                {
                    $id_tmp = $1;
                }
                $tree{$old_id{$id}} = $id_tmp."REP";
                $noback{$id} = "stop";
                $noback = "stop";
                $merge_extra = $position;
                print OUTPUT5 ">Remove rep merge!\n";
                 
                if ($contig_num eq '1')
                {
                    $contigs{$contig_num."+".$old_id{$id}} = $seed_old{$old_id{$id}};
                    contig_start ($seed_old{$old_id{$id}}); 
                }
                else
                {
                    $contigs{$contig_num."+".$old_id{$id}} = $seed_old{$old_id{$id}};
                }
                $contig_num++;
                delete $old_id{$id};
                delete $old_rep{$id};
                delete $old_rep_old{$old_id{$id}};
                if ($noback eq "stop" && $noforward eq "stop" && $merge_now eq "yes2")
                {
                    $contigs{$contig_num."+".$id} = $read;
                    $contig_num++;
                }
            }
        }
        else
        {
            if (exists $old_id{$id} && $position_back > 25 && $position_back < ($insert_size*3) && $noback ne "stop")
            {                                    
                my $read_oldie = $seed_old{$old_id{$id}};
                my $read_newest = $read;
                                                            
                my $start_seq = substr $read, 0, $insert_size+200;
                my $start_seq1 = substr $read, 0, 39;
                my $start_seq2 = substr $read, 30, 39;
                my $end_seq = substr $read_oldie, -$insert_size-200;
                my $end_seq1 = substr $read_oldie, -39, 39;
                my $end_seq2 = substr $read_oldie, -72, 39;
                $merge_read_length = length ($read);
                $start_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $start_seq1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $start_seq2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $end_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $end_seq1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $end_seq2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                
      
                if ($end_seq =~ m/.*.$start_seq1(.*)$/)
                {
                    my $r = length($1);
                    my $read_temp = $read;
                    my $read1 = substr $read_oldie, 0, -39-$r;         
    
                    $read = $read1.$read_temp;                                                      
                    $merge_read = "yes";
                }
                elsif ($end_seq =~ m/.*.$start_seq2(.*)$/)
                {
                    my $r = length($1);
                    my $read_temp = $read;
                    my $read1 = substr $read_oldie, 0, -39-$r;         
                    my $read2 = substr $read_temp, 30;
                    
                    $read = $read1.$read2;                                      
                    $merge_read = "yes";
                }
                elsif ($start_seq =~ m/(.*.)$end_seq1.*$/)
                {
                    my $r = length($1);
                    my $read_temp = $read;
                    my $read1 = substr $read_oldie, 0, -39-$r;         
                    
                    $read = $read1.$read_temp;                                      
                    $merge_read = "yes";
                }
                elsif ($start_seq =~ m/(.*.)$end_seq2.*$/)
                {
                    my $r = length($1);
                    my $read_temp = $read;
                    my $read1 = substr $read_oldie, 0, -39-$r;         
                    my $read2 = substr $read_temp, 30;
                    
                    $read = $read1.$read2;                                      
                    $merge_read = "yes";
                }
                
                if ($merge_read eq "yes")
                {            
                    $seed{$id} = $read;
                    $seeds_check{$id} = undef;
                    delete $tree{$old_id{$id}};
                    foreach my $tree_tmp (keys %tree)
                    {
                        my $old = $old_id{$id};
                        my $tree2 = $tree{$tree_tmp};
                        my $tree3 = $tree{$tree_tmp};
                        if ($old_id{$id} =~ m/.*_(\d+)$/)
                        {
                            $old = $1;
                        }
                        my $id_tmp = $id;
                        if ($id =~ m/.*_(\d+)$/)
                        {
                            $id_tmp = $1;
                        }
                        my @ids_split = split /\*/, $tree2;
                        foreach my $id_split (@ids_split)
                        {
                            if ($id_split  =~ m/^$old(REP)*$/)
                            {
                                if ($tree2 =~ m/^(.*\*)*$old(REP)*(\*.*)*$/)
                                {
                                    if (defined($1))
                                    {
                                        $tree3 = $1.$id_tmp;
                                    }
                                    else
                                    {
                                        $tree3 = $id_tmp;
                                    }
                                    if (defined($2))
                                    {
                                        $tree3 = $tree3."REP";
                                    }
                                    if (defined($3))
                                    {
                                        $tree3 = $tree3.$3;
                                    }
                                }
                            }
                        }
                        delete $tree{$tree_tmp};
                        $tree{$tree_tmp} = $tree3;
                        foreach my $contigs_end (keys %contigs_end)
                        {
                            if ($contigs_end{$contigs_end} eq $old)
                            {
                                delete $contigs_end{$contigs_end};
                                $contigs_end{$contigs_end} = $id_tmp;
                            }
                        }
                    }
                    delete $old_id{$id};
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "Merged both contigs!\n";
                        print OUTPUT5 ">".$read_newest."\n";
                    }            
                    $noback = "stop";
                    $noback{$id} = "stop";
                    $merge_extra = $position;
                }
            }
            if (((exists $old_id{$id} && ($noback eq "stop" || $position_back >= ($insert_size*3)) && $position > 1000) || $merge_now ne "") && $merge_read eq "")
            {                                    
                $merge_read_length = length($read);
                $merge_read = "yes"; 
                $read = $seed_old{$old_id{$id}} ."LLLLLLLLLLLLLLL".$read;
                $seed{$id} = $read;
                $seeds_check{$id} = undef;
                $hasL = "yes";
                foreach my $tree_tmp (keys %tree)
                {
                    print OUTPUT5 $tree_tmp." TREE_TMP\n";
                    print OUTPUT5 $tree{$tree_tmp}." TREE_TMP2\n";
                    my $old = $old_id{$id};
                    my $tree2 = $tree{$tree_tmp};
                    my $tree3 = $tree{$tree_tmp};
                    if ($old_id{$id} =~ m/.*_(\d+)$/)
                    {
                        $old = $1;
                    }
                    my $id_tmp = $id;
                    if ($id =~ m/.*_(\d+)$/)
                    {
                        $id_tmp = $1;
                    }
                    my @ids_split = split /\*/, $tree2;
                    foreach my $id_split (@ids_split)
                    {
                        print OUTPUT5 $id_split." ID_SPLIT\n";
                        if ($id_split  =~ m/^.*$old(REP)*$/)
                        {
                            print OUTPUT5 $tree2." ID_SPLIT2\n";
                            if ($tree2 =~ m/^(.*\*)*$old(REP)*(\*.*)*$/)
                            {                    
                                if (defined($1))
                                {
                                    $tree3 = $1.$id_tmp;
                                }
                                else
                                {
                                    $tree3 = $id_tmp;
                                }
                                if (defined($2))
                                {
                                    $tree3 = $tree3."REP";
                                }
                                if (defined($3))
                                {
                                    $tree3 = $tree3.$3;
                                }
                                print OUTPUT5 $tree3." TREE3\n";
                            }
                        }
                    }
                    delete $tree{$tree_tmp};
                    $tree{$tree_tmp} = $tree3;
                    foreach my $contigs_end (keys %contigs_end)
                    {
                        if ($contigs_end{$contigs_end} eq $old)
                        {
                            delete $contigs_end{$contigs_end};
                            $contigs_end{$contigs_end} = $id_tmp;
                        }
                    }
                }              
                if ($contig_num eq '1')
                {
                    contig_start ($read); 
                }
                
                delete $old_id{$id};
                $noback{$id} = "stop";
                $noback = "stop";
                $merge_extra = $position;
                if ($y > $startprint2)
                {
                    print OUTPUT5 ">Merged contigs with LLLLLLLLLLL!\n";
                }
                $contig_gap_min{$id."_".$contig_count} = ($contig_gap_min{$id."_".$contig_count}-$position_back);
                $contig_gap_max{$id."_".$contig_count} = ($contig_gap_max{$id."_".$contig_count}-$position_back);
                if ($noback eq "stop" && $noforward eq "stop" && $merge_now eq "yes2")
                {
                    $contigs{$contig_num."+".$id} = $read;
                    $contig_num++;
                }
            }
        }
        if ($merge_now ne "")
        {
            if ($noforward eq "stop")
            {  
                print OUTPUT5 ">MERGE_NOW ".$id."\n";
                print OUTPUT5 $read."\n";
                delete $seed{$id};
                if (!keys %seed)
                {
                    $circle = "contigs";
                    goto FINISH;
                }
                else
                {
                    goto ITERATION;
                }
            }
            else
            {
                print OUTPUT5 ">\n";
                $noback = "stop";
                $noback{$id} = "stop";
                $seed_split{$id} = undef;
                $best_extension = "";
                goto FINISH;
            }
        }
        

    if (exists $old_id{$id})
    {    
    }
    elsif (keys %contigs && $first_contig_start ne "" && $heteroplasmy eq "")
    {
        my %read_short_end2_tmp;
        undef %read_short_end2_tmp;
        
        my $star_in_first_contig = $first_contig_start =~ tr/\*/\*/;
        
        my $sequence_tmp = $read_short_end2;
        if ($merge_extra ne "")
        {
            my $long_end = substr $read, -250-$merge_extra;
            $sequence_tmp = $long_end;            
        }
        $sequence_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

        my $dot_check = $sequence_tmp =~ tr/\./\./;
  
        if ($dot_check < 5)
        {
            %read_short_end2_tmp = build_partial3b $sequence_tmp;
        }
        else
        {
            %read_short_end2_tmp = build_partial3c $sequence_tmp;
        }
        foreach my $read_short_end2_tmpi (keys %read_short_end2_tmp)
        {
            my %read_short_end2_split;
            undef %read_short_end2_split;
            my %read_short_end2_split_dot;
            undef %read_short_end2_split_dot;
            my $check_start0 = '0';
            my $check_start1 = '0';
            my $check_start2 = '0';
            
            if ($dot_check > 4)
            {
                my $f = '0';
                while ($f <= length($read_short_end2_tmpi)-$overlap)
                {
                    my $seq_tmp = substr $read_short_end2_tmpi, $f, $overlap;
                    my $dot_check2 = $seq_tmp =~ tr/\./\./;
                    if ($dot_check2 > 0)
                    {
                        $read_short_end2_split_dot{$seq_tmp} = undef;
                    }
                    else
                    {
                        $read_short_end2_split{$seq_tmp} = undef;
                    }
                    $f++;
                }
                if (exists($read_short_end2_split{$first_contig_start}))
                {
                    $check_start1 = '1';
                }
                if (exists($read_short_end2_split{$first_contig_start_reverse}))
                {
                    $check_start2 = '1';
                }
                foreach my $read_short_end2_split_dot_tmp (keys %read_short_end2_split_dot)
                {
                    my $check_start1_tmp = $first_contig_start =~ s/$read_short_end2_split_dot_tmp/$read_short_end2_split_dot_tmp/;
                    my $check_start2_tmp = $first_contig_start_reverse =~ s/$read_short_end2_split_dot_tmp/$read_short_end2_split_dot_tmp/;
                    if ($check_start1_tmp > 0)
                    {
                        $check_start1 = '1';
                    }
                    if ($check_start2_tmp > 0)
                    {
                        $check_start2 = '1';
                    }
                }
            }
            elsif ($star_in_first_contig < 1 || $star_in_first_contig eq "")
            {     
                $check_start1 = $read_short_end2_tmpi =~ s/$first_contig_start/$first_contig_start/;
                $check_start2 = $read_short_end2_tmpi =~ s/$first_contig_start_reverse/$first_contig_start_reverse/;
            }
            if ($merge_extra ne "")
            {
                $check_start0 = $check_start1;
            }
            
            if ($check_start1 > 0 || $check_start0 > 0)
            {
                $tree{$id} = "END";
            }
            if ($check_start2 > 0)
            {
                $tree{$id} = "END_REVERSE";
            }
            if ($check_start1 > 0 || $check_start2 > 0 || $check_start0 > 0)
            {
                $noforward{$id} = "stop";
                $noforward = "stop";
                if ($y > $startprint2)
                {                                                                                 
                    if ($check_start1 > 0 || $check_start0 > 0)
                    {
                        print OUTPUT5 "\nSTOP_CONTIG, encouter start sequence\n\n";
                    }
                    if ($check_start2 > 0)
                    {
                        print OUTPUT5 "\nSTOP_CONTIG, encouter start sequence reverse\n\n";
                    }
                    print OUTPUT5 ">".$id."\n";
                    print OUTPUT5 $read."\n";
                }
    
                delete $seed{$id};                                         
                if ($check_start1 > 0 || $check_start0 > 0)
                {
                    $contigs{$contig_num."+".$id} = $read;
                    $contig_num++;
                } 
                goto SEED;
            }
        }
    }
        
REPEAT:        
        $read_new = $read;
        $read_new1 = $read;
        
        if ($y > $startprint2 && $noforward eq "")
        {
            if ($use_regex eq "yes")
            {
                print OUTPUT5 "USE_REGEX\n";
            }
            if ($use_regex eq "yes2")
            {
                print OUTPUT5 "USE_REGEX2\n";
            }
        }
        if ($y > $startprint2 && $noback eq "")
        {
            if ($use_regex_back eq "yes2")
            {
                print OUTPUT5 "USE_REGEX_BACK2\n";
            }
            if ($use_regex_back eq "yes")
            {
                print OUTPUT5 "USE_REGEX_BACK2\n";
            }
        }

                                                
                                if (length($read) > $genome_range_low && $heteroplasmy eq "")
                                {
                                    my $start_seq_tmp = $read_new;
                                    my $rep_extra_seq = '0';
                                    if ($stuck_in_rep_back eq "yes" && $stuck_in_rep_back_before ne "" && $type eq "mito" && $merge_read ne "yes")
                                    {
                                        $start_seq_tmp = $stuck_in_rep_back_before;
                                        if ($read_new =~ m/(.*).$stuck_in_rep_back_before.*/)
                                        {
                                            $rep_extra_seq = length($1);
                                        }
                                    }
                                    my $start_seq = substr $start_seq_tmp, 0, 300;
                                    my $start_seq1 = substr $start_seq_tmp, 30, 42;
                                    my $start_seq2 = substr $start_seq_tmp, 60, 42;
                                    my $start_seq3 = substr $start_seq_tmp, 90, 42;
                                    my $end_seq = substr $read_new, -300;
                                    my $end_seq1 = substr $read_new, -72, 42;
                                    my $end_seq2 = substr $read_new, -102, 42;
                                    my $end_seq3 = substr $read_new, -132, 42;
                                    my $end_seq1_merge = "";
                                    my $end_seq2_merge = "";
                                    my $end_seq3_merge = "";
                                    $start_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    $start_seq1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    $start_seq2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    $start_seq3 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    $end_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    $end_seq1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    $end_seq2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    $end_seq3 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    
                                    if ($merge_read eq "yes")
                                    {
                                        $end_seq1_merge = substr $read_new, -$merge_read_length+20, 42;
                                        $end_seq2_merge = substr $read_new, -$merge_read_length+100, 42;
                                        $end_seq3_merge = substr $read_new, -$merge_read_length+170, 42;
                                        $end_seq1_merge =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                        $end_seq2_merge =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                        $end_seq3_merge =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                    }
                                    
                                    if ($end_seq =~ m/.*.$start_seq1(.*)$/)
                                    {
                                        my $r = length($1);
                                        my $read_new_temp = $read_new;
                                        if ($r eq '0')
                                        {
                                            $read_new = substr $read_new_temp, 30+42+$rep_extra_seq;             
                                        }
                                        else
                                        {
                                            $read_new = substr $read_new_temp, 30+42+$rep_extra_seq, -$r;                                                       
                                        }
                                        $read = $read_new;
                                        
                                        $circle = "yes";
                                        $noback = "stop";
                                    }
                                    elsif ($end_seq =~ m/.*.$start_seq2(.*)$/)
                                    {
                                        my $r = length($1);
                                        my $read_new_temp = $read_new;
                                        if ($r eq '0')
                                        {
                                            $read_new = substr $read_new_temp, 60+42+$rep_extra_seq;     
                                        }
                                        else
                                        {
                                            $read_new = substr $read_new_temp, 60+42+$rep_extra_seq, -$r;                                             
                                        }
                                        $read = $read_new;
                                        
                                        $circle = "yes";
                                        $noback = "stop";
                                    }
                                    elsif ($end_seq =~ m/.*.$start_seq3(.*)$/)
                                    {
                                        my $r = length($1);
                                        my $read_new_temp = $read_new;
                                        if ($r eq '0')
                                        {
                                            $read_new = substr $read_new_temp, 90+42+$rep_extra_seq;     
                                        }
                                        else
                                        {
                                            $read_new = substr $read_new_temp, 90+42+$rep_extra_seq, -$r;                                             
                                        }
                                        $read = $read_new;
                                        
                                        $circle = "yes";
                                        $noback = "stop";
                                    }
                                    elsif ($start_seq =~ m/(.*.)$end_seq1.*$/)
                                    {
                                        my $r = length($1);
                                        my $read_new_temp = $read_new;
                                        $read_new = substr $read_new_temp, $r+$rep_extra_seq, -(42+30);
                                        $read = $read_new;
                                        
                                        $circle = "yes";
                                        $noback = "stop";
                                    }
                                    elsif ($start_seq =~ m/(.*.)$end_seq2.*$/)
                                    {
                                        my $r = length($1);
                                        my $read_new_temp = $read_new;
                                        $read_new = substr $read_new_temp, $r+$rep_extra_seq, -(42+60);
                                        $read = $read_new;
                                        
                                        $circle = "yes";
                                        $noback = "stop";
                                    }
                                    elsif ($start_seq =~ m/(.*.)$end_seq3.*$/)
                                    {
                                        my $r = length($1);
                                        my $read_new_temp = $read_new;
                                        $read_new = substr $read_new_temp, $r+$rep_extra_seq, -(42+90);
                                        $read = $read_new;
                                        
                                        $circle = "yes";
                                        $noback = "stop";
                                    }
                                    if ($merge_read eq "yes" && $circle ne "yes")
                                    {
                                        if ($start_seq =~ m/(.*.)$end_seq1_merge.*$/)
                                        {
                                            my $r = length($1);
                                            my $read_new_temp = $read_new;
                                            $read_new = substr $read_new_temp, $merge_read_length-20, -$r;
                                            $read = $read_new;
                                            
                                            $circle = "yes";
                                            $noback = "stop";
                                        }
                                        elsif ($start_seq =~ m/(.*.)$end_seq2_merge.*$/)
                                        {
                                            my $r = length($1);
                                            my $read_new_temp = $read_new;
                                            $read_new = substr $read_new_temp, $merge_read_length-100, -$r;
                                            $read = $read_new;
                                            
                                            $circle = "yes";
                                            $noback = "stop";
                                        }
                                        elsif ($start_seq =~ m/(.*.)$end_seq3_merge.*$/)
                                        {
                                            my $r = length($1);
                                            my $read_new_temp = $read_new;
                                            $read_new = substr $read_new_temp, $merge_read_length-170, -$r;
                                            $read = $read_new;
                                            
                                            $circle = "yes";
                                            $noback = "stop";
                                        }
                                    }
                                }
                                if (keys %contigs && $heteroplasmy eq "")
                                {
                                    my $total_length = length($read);
                                    foreach my $contig_tmp (keys %contigs)
                                    {
                                        $total_length = $total_length + length($contigs{$contig_tmp});
                                    }
                                    if ($total_length > $genome_range_high + $genome_range_high)
                                    {
                                        $circle = "contigs";
                                        $noback = "stop";
                                        $noforward = "stop";
                                        $contigs{$contig_num."+".$id} = $read;
                                        $contig_num++;
                                        delete $seed{$id};
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 "TOTAL_LENGTH_ABOVE_UP_LIMIT\n";
                                        }
                                        goto FINISH2;
                                    }
                                }
                                if (length($read) > $genome_range_high && $heteroplasmy eq "")
                                {
                                    $circle = "no";
                                    $noforward = "stop";
                                    $noback = "stop";
        
                                    $contigs{$contig_num."+".$id} = $read;
                                    $contig_num++;
                                    delete $seed{$id};
                                    if ($y > $startprint2)
                                    {
                                        print OUTPUT5 "READ_ABOVE_UP_LIMIT\n";
                                    }
                                    goto FINISH2;
                                }
        if ($y > $startprint2 && $benchmark_time eq "yes")
        {
            $time_before_scan = time;       
            if ($time_before_scan - $time_start_seed > 1)
            {
                print OUTPUT5 $time_before_scan - $time_start_seed." TIME0b\n";
            }
        }
        my $no_AT = "";
NO_AT:
        undef %extensions1b;
        undef %extensions2b;
        undef %extensionsb;
        undef %extensionsb_original;
        undef @matches;                  
        undef %merged_match;
        undef %merged_match_pair;
        undef %merged_match_back;
        undef %merged_match1;
        undef %merged_match2;
        undef %merged_match_back1;
        undef %merged_match_back2;
                                chomp $read;
                                my $overlap_tmp_forward = $overlap;
                                my $overlap_tmp_back = $overlap;
                           
                                if ($noforward eq "" && $no_AT ne "yes")
                                {
                                    my $read_end_AT = substr $read_short_end2, -$read_length+$right-3;
                                    
                                    $AT_rich = AT_rich_test ($read_end_AT, '3');
                                    if ($AT_rich eq "yes")
                                    {
                                        print OUTPUT5 "STOP_FORWATD_AT\n";
                                        $noforward = "stop";
                                        $noforward{$id} = "stop";
                                        goto FINISH;
                                    }
AT:                                 my $read_end_AT2 = substr $read_short_end2, -$overlap_tmp_forward-3, $overlap+3;
                                    
                                    my $AT_rich_before_tmp = AT_rich_test ($read_end_AT2, '8');
                                    if ($AT_rich_before_tmp eq "yes" && $overlap_tmp_forward < $read_length-$right-$left)
                                    {
                                        $AT_rich_before = "yes";
                                        print OUTPUT5 $AT_rich_before." AT_RICH\n";
                                        $overlap_tmp_forward += 10;
                                        goto AT;
                                    }
                                }
                                if ($noback eq "")
                                {
                                    my $read_start_AT = substr $read_short_start2, 0, $read_length-$right+5;
                                    
                                    my $AT_rich_back = AT_rich_test ($read_start_AT, '5');

                                    if ($AT_rich_back eq "yes")
                                    {
                                        $noback = "stop";
                                        $noback{$id} = "stop";
                                        goto MERGE;
                                    }
AT_BACK:                            my $read_start_AT2 = substr $read_short_start2, $overlap_tmp_back-$overlap, $overlap+3;

                                    my $AT_rich_before_back_tmp = AT_rich_test ($read_start_AT2, '8');
                                   
                                    if ($AT_rich_before_back_tmp eq "yes" && $overlap_tmp_back < $read_length-$right-$left)
                                    {
                                        my $AT_rich_before_back = "yes";
                                        $overlap_tmp_back += 10;
                                        print OUTPUT5 $AT_rich_before_back." AT_RICH_BACK\n";
                                        goto AT_BACK;
                                    }
                                }
                                my $s = $overlap_tmp_forward - $overlap;
                                my $e = $overlap_tmp_back - $overlap;
                                
                                while ($s < $read_length-($overlap+$left+1-$containX_short_end2-$containX_short_end2) || $e < $read_length-($overlap+$left+1-$containX_short_start2-$containX_short_start2))
                                {                                   
                                    my $read_end_d = substr $read_short_end2, -($s+$overlap), $overlap;
                                    my $read_start_t = substr $read_short_start2, $e, $overlap;
                                    
                                    if ($containX_short_end2 > 0)
                                    {
                                        my $star = $read_end_d =~ tr/\*/\*/;

                                        $read_end_d = substr $read_short_end2, -($s+$overlap+($star*2)), $overlap+($star*2);
                                        my $star2 = $read_end_d =~ tr/\*/\*/;                                               
                                        while ($star2 > $star)
                                        {
                                            $read_end_d = substr $read_short_end2, -($s+$overlap+($star*2)+(($star2-$star)*2)), $overlap+($star*2)+(($star2-$star)*2);
                                            $star = $star2;
                                            $star2 = $read_end_d =~ tr/\*/\*/;
                                        }   
                                    }
                                    if ($containX_short_start2 > 0)
                                    {
                                        my $star = $read_start_t =~ tr/\*/\*/;
            
                                        $read_start_t = substr $read_short_start2, $e, $overlap+($star*2);
                                        my $star2 = $read_start_t =~ tr/\*/\*/;                                              
                                        while ($star2 > $star)
                                        {
                                            $read_start_t = substr $read_short_start2, $e, $overlap+($star*2)+(($star2-$star)*2);
                                            $star = $star2;
                                            $star2 = $read_start_t =~ tr/\*/\*/;
                                        }
                                    }     
                                    if ($s eq ($overlap_tmp_forward - $overlap))
                                    {                      
                                        $read_end = substr $read_short_end2, -$overlap;
                                        $read_start = substr $read_short_start2, 0, $overlap;
                                        
                                        if ($containX_short_end2 > 0)
                                        {
                                            my $star = $read_end =~ tr/\*/\*/;
    
                                            $read_end = substr $read_short_end2, -($overlap+($star*2)), $overlap+($star*2);
                                            my $star2 = $read_end =~ tr/\*/\*/;                                                
                                            while ($star2 > $star)
                                            {
                                                $read_end = substr $read_short_end2, -($overlap+($star*2)+(($star2-$star)*2)), $overlap+($star*2)+(($star2-$star)*2);
                                                $star = $star2;
                                                $star2 = $read_end =~ tr/\*/\*/;
                                            }   
                                        }
                                        if ($containX_short_start2 > 0)
                                        {
                                            my $star = $read_start =~ tr/\*/\*/;
                
                                            $read_start = substr $read_short_start2, 0, $overlap+($star*2);
                                            my $star2 = $read_start =~ tr/\*/\*/;                                                
                                            while ($star2 > $star)
                                            {
                                                $read_start = substr $read_short_start2, 0, $overlap+($star*2)+(($star2-$star)*2);
                                                $star = $star2;
                                                $star2 = $read_start =~ tr/\*/\*/;
                                            }
                                        }
                                        
                                        my $X = "";
                                        my $Xb = "";
                                        $read_end =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                        $read_start =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                        
                                        my $read_end_c = $read_end;
                                        $read_end_c =~ tr/ATCG/TAGC/;
                                        $read_end_b = reverse($read_end_c);                                                
                                        
                                        my $read_start_c = $read_start;
                                        $read_start_c =~ tr/ATCG/TAGC/;
                                        $read_start_b = reverse($read_start_c);
                                        
                                        if ($containX_short_end2 > 0)
                                        {
                                            $X = $read_end =~ tr/\*/\*/;
                                            if ($X > 0)
                                            {
                                                %read_end = build_partial3c $read_end, "";
                                                %read_end_b = build_partial3c ($read_end_b, "reverse");
                                            }
                                            else
                                            {
                                                $read_end{$read_end} = undef;
                                                $read_end_b{$read_end_b} = undef;
                                            }
                                        }
                                        else
                                        {
                                            $read_end{$read_end} = undef;
                                            $read_end_b{$read_end_b} = undef;
                                        }                                                   
                                        if ($containX_short_start2 > 0)
                                        {
                                            $Xb = $read_start =~ tr/\*/\*/;
                                            if ($Xb > 0)
                                            {
                                                %read_start = build_partial3c $read_start, "back";
                                                %read_start_b = build_partial3c ($read_start_b, "reverse_back");
                                            }
                                            else
                                            {
                                                $read_start{$read_start} = undef;
                                                $read_start_b{$read_start_b} = undef;
                                            }
                                        }
                                        else
                                        {
                                            $read_start{$read_start} = undef;
                                            $read_start_b{$read_start_b} = undef;
                                        }
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $read_end." READ_END\n";
                                            if ($X > 0)
                                            {
                                                foreach (keys %read_end)
                                                {
                                                    print OUTPUT5 $_."\n";
                                                } 
                                            }
                                            print OUTPUT5 $read_start." READ_START\n";
                                            if ($Xb > 0)
                                            {
                                                foreach (keys %read_start)
                                                {
                                                    print OUTPUT5 $_."\n";
                                                } 
                                            }
                                        }
                                    }
                                    if ($noforward ne "stop") 
                                    {
                                        my $read_end_c = $read_end_d;                                            
                                        $read_end_c =~ tr/ATCG/TAGC/;
                                        my $read_end_e = reverse($read_end_c);
                                                                                    
                                        my %read_end_e;
                                        undef %read_end_e;
                                        
                                        if ($contain_dot_short_end2 > 0 || $containX_short_end2 > 0)
                                        {
                                            my $dot = $read_end_e =~ tr/\./\./;
                                            my $X = $read_end_e =~ tr/\*/\*/;
                                            if ($X > 0 || $dot > 0)
                                            {
                                                %read_end_e = build_partial3c ($read_end_e, "reverse");
                                            }
                                            else
                                            {
                                                $read_end_e{$read_end_e} = undef;
                                            }
                                        }
                                        else
                                        {
                                            $read_end_e{$read_end_e} = undef;
                                        }
                                        if (($use_regex ne "" || $last_chance eq "yes") && $last_chance_SNR ne "yes")
                                        {
                                            my $X_test = $read_end_e =~ tr/\./\./;
                                            my %list;
                                            undef %list;
                                            if ($X_test < 2 && $use_regex ne "yes2" && $heteroplasmy eq "")
                                            {
                                                %list = build_partial2b %read_end_e;
                                                %read_end_e = %list;
                                            }
                                            elsif ($X_test < 5)
                                            {
                                                %read_end_e = build_partial3b ($read_end_e, "reverse");
                                            }
                                            else
                                            {
                                                %read_end_e = build_partial3c ($read_end_e, "reverse");
                                            }

                                            foreach my $list (keys %read_end_e) 
                                            {
                                                if (exists($hash2c{$list}))
                                                {                       
                                                    my $search = $hash2c{$list};
                                                            
                                                    $search = substr $search, 1;
                                                    my @search = split /,/,$search;
                                                                    
                                                    foreach my $search (@search)
                                                    {
                                                        my $search_tmp = substr $search, 0, -1;
                                                        my $search_end = substr $search, -1;
                                                        if (exists($hash{$search_tmp}))
                                                        {
                                                            my @search_tmp = split /,/,$hash{$search_tmp};
                                                            my $found;
                                                            my $found_pair;
                                                            if ($search_end eq "1")
                                                            {
                                                                $found = $search_tmp[0];
                                                                $found_pair = $search_tmp[1];
                                                            }
                                                            elsif ($search_end eq "2")
                                                            {
                                                                $found = $search_tmp[1];
                                                                $found_pair = $search_tmp[0];
                                                            }
                                                            if ($encrypt eq "yes")
                                                            {
                                                                $found = decrypt $found;
                                                                $found_pair = decrypt $found_pair;
                                                            }
                                                            $merged_match1{$search} = $found;
                                                            $merged_match_pos{$search} = $s;
                                                            $merged_match_pair{$search} = $found_pair;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        elsif ($last_chance_SNR ne "yes")
                                        {
                                            foreach my $read_end_e2 (keys %read_end_e)
                                            {                                                   
                                                if (exists($hash2c{$read_end_e2}))
                                                {                       
                                                    my $search = $hash2c{$read_end_e2};
                                                    $search = substr $search, 1;
                                                    my @search = split /,/,$search;
                                        
                                                    foreach my $search (@search)
                                                    {
                                                        my $search_tmp = substr $search, 0, -1;
                                                        my $search_end = substr $search, -1;
                                                        if (exists($hash{$search_tmp}))
                                                        {
                                                            my @search_tmp = split /,/,$hash{$search_tmp};
                                                            my $found;
                                                            my $found_pair;
                                                            if ($search_end eq "1")
                                                            {
                                                                $found = $search_tmp[0];
                                                                $found_pair = $search_tmp[1];
                                                            }
                                                            elsif ($search_end eq "2")
                                                            {
                                                                $found = $search_tmp[1];
                                                                $found_pair = $search_tmp[0];
                                                            }
                                                            if ($encrypt eq "yes")
                                                            {
                                                                $found = decrypt $found;
                                                                $found_pair = decrypt $found_pair;
                                                            }
                                                            $merged_match1{$search} = $found;
                                                            $merged_match_pos{$search} = $s;
                                                            $merged_match_pair{$search} = $found_pair;
                                                        }
                                                    }
                                                }         
                                            }
                                            if ($s > 0 && $s <= $left)
                                            {
                                                foreach my $read_end_e2 (keys %read_end_e)
                                                {                                                   
                                                    if (exists($hash2b{$read_end_e2}))
                                                    {                       
                                                        my $search = $hash2b{$read_end_e2};
                                                        $search = substr $search, 1;
                                                        my @search = split /,/,$search;
                                            
                                                        foreach my $search (@search)
                                                        {
                                                            my $search_tmp = substr $search, 0, -1;
                                                            my $search_end = substr $search, -1;
                                                            if (exists($hash{$search_tmp}))
                                                            {
                                                                my @search_tmp = split /,/,$hash{$search_tmp};
                                                                my $found;
                                                                my $found_pair;
                                                                if ($search_end eq "1")
                                                                {
                                                                    $found = $search_tmp[0];
                                                                    $found_pair = $search_tmp[1];
                                                                }
                                                                elsif ($search_end eq "2")
                                                                {
                                                                    $found = $search_tmp[1];
                                                                    $found_pair = $search_tmp[0];
                                                                }
                                                                if ($encrypt eq "yes")
                                                                {
                                                                    $found = decrypt $found;
                                                                    $found_pair = decrypt $found_pair;
                                                                }
                                                                $merged_match1{$search} = $found;
                                                                $merged_match_pos{$search} = length($found)-$left-$right-$overlap+$s;
                                                                $merged_match_pair{$search} = $found_pair;
                                                            }
                                                        }
                                                    }         
                                                }
                                            }
                                        }
                                        if ($last_chance eq "yes" || $contain_dot_short_end2 > 0 || $containX_short_end2 > 0)
                                        {
                                            my %read_end_d;
                                            undef %read_end_d;
                                        
                                            if ($contain_dot_short_end2 > 0 || $containX_short_end2 > 0)
                                            {
                                                my $dot = $read_end_d =~ tr/\./\./;
                                                my $X = $read_end_d =~ tr/\*/\*/;
                                                if ($dot > 0 && $dot < 5)
                                                {
                                                    %read_end_d = build_partial3b $read_end_d, "";
                                                }
                                                elsif ($X > 0)
                                                {
                                                    %read_end_d = build_partial3c $read_end_d, "";
                                                }
                                                else
                                                {
                                                    $read_end_d{$read_end_d} = undef;
                                                }
                                            }
                                            else
                                            {
                                                $read_end_d{$read_end_d} = undef;
                                            }
                                            
                                            if ($last_chance eq "yes")
                                            {
                                                my $X_test = $read_end_d =~ tr/\./\./;
                                                my %list;
                                                undef %list;
                                                if ($X_test < 2 && $use_regex ne "yes2" && $heteroplasmy eq "")
                                                {
                                                    %list = build_partial2b %read_end_d;
                                                }
                                                else
                                                {
                                                    %list = %read_end_d;
                                                }
                                                foreach my $list (keys %list) 
                                                {
                                                    if (exists($hash2b{$list}))
                                                    {
                                                        my $search = $hash2b{$list};
                                                        
                                                        $search = substr $search, 1;
                                                        my @search = split /,/,$search;
                                                                    
                                                        foreach my $search (@search)
                                                        {
                                                            my $search_tmp = substr $search, 0, -1;
                                                            my $search_end = substr $search, -1;
                                                            if (exists($hash{$search_tmp}))
                                                            {
                                                                my @search_tmp = split /,/,$hash{$search_tmp};
                                                                my $found;
                                                                if ($search_end eq "1")
                                                                {
                                                                    $found = $search_tmp[0];
                                                                }
                                                                elsif ($search_end eq "2")
                                                                {
                                                                    $found = $search_tmp[1];
                                                                }
                                                                if ($encrypt eq "yes")
                                                                {
                                                                    $found = decrypt $found;
                                                                }
                                                                $merged_match2{$search} = $found;
                                                                $merged_match_pos{$search} = $s;
                                                            }
                                                        }
                                                    }
                                                    if ($s > 0 && $s <= $right)
                                                    {
                                                        if (exists($hash2c{$list}))
                                                        {
                                                            my $search = $hash2c{$list};
                                                            
                                                            $search = substr $search, 1;
                                                            my @search = split /,/,$search;
                                                                        
                                                            foreach my $search (@search)
                                                            {
                                                                my $search_tmp = substr $search, 0, -1;
                                                                my $search_end = substr $search, -1;
                                                                if (exists($hash{$search_tmp}))
                                                                {
                                                                    my @search_tmp = split /,/,$hash{$search_tmp};
                                                                    my $found;
                                                                    if ($search_end eq "1")
                                                                    {
                                                                        $found = $search_tmp[0];
                                                                    }
                                                                    elsif ($search_end eq "2")
                                                                    {
                                                                        $found = $search_tmp[1];
                                                                    }
                                                                    if ($encrypt eq "yes")
                                                                    {
                                                                        $found = decrypt $found;
                                                                    }
                                                                    $merged_match2{$search} = $found;
                                                                    $merged_match_pos{$search} = length($found)-$left-$right-$overlap+$s;;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if ($noback ne "stop")
                                    {
                                        my %read_start_t;
                                        undef %read_start_t;
                                        
                                        if ($contain_dot_short_start2 > 0 || $containX_short_start2 > 0)
                                        {
                                            my $dot = $read_start_t =~ tr/\./\./;
                                            my $X = $read_start_t =~ tr/\*/\*/;
                                            if ($X > 0 || $dot > 0)
                                            {
                                                %read_start_t = build_partial3c ($read_start_t, "back");
                                            }
                                            else
                                            {
                                                $read_start_t{$read_start_t} = undef;
                                            }
                                        }
                                        else
                                        {
                                            $read_start_t{$read_start_t} = undef;
                                        }                                                                          
                                        if ($last_chance_back eq "yes" || $use_regex_back ne "")
                                        {
                                            my $X_test = $read_start_t =~ tr/\./\./;
                                            my %list;
                                            undef %list;
                                            if ($X_test < 2 && $use_regex_back ne "yes2" && $heteroplasmy eq "")
                                            {
                                                %list = build_partial2b %read_start_t;
                                                %read_start_t = %list;
                                            }
                                            elsif ($X_test < 5)
                                            {
                                                %read_start_t = build_partial3b ($read_start_t, "back");
                                            }
                                            else
                                            {
                                                %read_start_t = build_partial3c ($read_start_t, "back");
                                            }
                                            foreach my $list (keys %read_start_t) 
                                            {
                                                if (exists($hash2c{$list}))
                                                {                       
                                                    my $search = $hash2c{$list};
                                                                            
                                                    $search = substr $search, 1;
                                                    my @search = split /,/,$search;
                                                                                    
                                                    foreach my $search (@search)
                                                    {
                                                        my $search_tmp = substr $search, 0, -1;
                                                        my $search_end = substr $search, -1;
                                                        if (exists($hash{$search_tmp}))
                                                        {
                                                            my @search_tmp = split /,/,$hash{$search_tmp};
                                                            my $found;
                                                            my $found_pair;
                                                            if ($search_end eq "1")
                                                            {
                                                                $found = $search_tmp[0];
                                                                $found_pair = $search_tmp[1];
                                                            }
                                                            elsif ($search_end eq "2")
                                                            {
                                                                $found = $search_tmp[1];
                                                                $found_pair = $search_tmp[0];
                                                            }
                                                            if ($encrypt eq "yes")
                                                            {
                                                                $found = decrypt $found;
                                                                $found_pair = decrypt $found_pair;
                                                            }
                                                            $merged_match_back1{$search} = $found;
                                                            $merged_match_back_pos{$search} = $e;
                                                            $merged_match_pair_back{$search} = $found_pair;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            foreach my $read_start_t2 (keys %read_start_t)
                                            {
                                                if (exists($hash2c{$read_start_t2}))
                                                {                       
                                                    my $search = $hash2c{$read_start_t2};
                                                    $search = substr $search, 1;
                                                    my @search = split /,/,$search;
                                                                                    
                                                    foreach my $search (@search)
                                                    {
                                                        my $search_tmp = substr $search, 0, -1;
                                                        my $search_end = substr $search, -1;
                                                        if (exists($hash{$search_tmp}))
                                                        {
                                                            my @search_tmp = split /,/,$hash{$search_tmp};
                                                            my $found;
                                                            my $found_pair;
                                                            if ($search_end eq "1")
                                                            {
                                                                $found = $search_tmp[0];
                                                                $found_pair = $search_tmp[1];
                                                            }
                                                            elsif ($search_end eq "2")
                                                            {
                                                                $found = $search_tmp[1];
                                                                $found_pair = $search_tmp[0];
                                                            }
                                                            if ($encrypt eq "yes")
                                                            {
                                                                $found = decrypt $found;
                                                                $found_pair = decrypt $found_pair;
                                                            }
                                                            $merged_match_back1{$search} = $found;
                                                            $merged_match_back_pos{$search} = $e;
                                                            $merged_match_pair_back{$search} = $found_pair;
                                                        }
                                                    }
                                                }
                                            }         
                                        }
                                        if ($last_chance_back eq "yes")
                                        {
                                            my $read_start_c = $read_start_t;
                                            $read_start_c =~ tr/ATCG/TAGC/;
                                            my $read_start_e = reverse($read_start_c);
                                            
                                            my %read_start_e;
                                            undef %read_start_e;
                                        
                                            if ($contain_dot_short_start2 > 0 || $containX_short_start2 > 0)
                                            {
                                                my $dot = $read_start_e =~ tr/\./\./;
                                                my $X = $read_start_e =~ tr/\*/\*/;
                                                my %list;
                                                undef %list;
                                                if ($X < 2 && $use_regex_back eq "yes" && $heteroplasmy eq "")
                                                {
                                                    %list = build_partial2b %read_start_e;
                                                    %read_start_e = %list;
                                                }
                                                elsif ($dot > 0 && $dot < 5)
                                                {
                                                    %read_start_e = build_partial3b ($read_start_e, "reverse_back");
                                                }
                                                elsif ($X > 0)
                                                {
                                                    %read_start_e = build_partial3c ($read_start_e, "reverse_back");
                                                }
                                                else
                                                {
                                                    $read_start_e{$read_start_e} = undef;
                                                }
                                            }
                                            else
                                            {
                                                $read_start_e{$read_start_e} = undef;
                                            }
                                            foreach my $list (keys %read_start_e) 
                                            {
                                                if (exists($hash2b{$list}))
                                                {                       
                                                    my $search = $hash2b{$list};
                                                                            
                                                    $search = substr $search, 1;
                                                    my @search = split /,/,$search;
                                                                                    
                                                    foreach my $search (@search)
                                                    {
                                                        my $search_tmp = substr $search, 0, -1;
                                                        my $search_end = substr $search, -1;
                                                        if (exists($hash{$search_tmp}))
                                                        {
                                                            my @search_tmp = split /,/,$hash{$search_tmp};
                                                            my $found;
                                                            if ($search_end eq "1")
                                                            {
                                                                $found = $search_tmp[0];
                                                            }
                                                            elsif ($search_end eq "2")
                                                            {
                                                                $found = $search_tmp[1];
                                                            }
                                                            if ($encrypt eq "yes")
                                                            {
                                                                $found = decrypt $found;
                                                            }
                                                            $merged_match_back2{$search} = $found;
                                                            $merged_match_back_pos{$search} = $e;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } 
                                    if ($s < $read_length-($overlap+$left+1-$containX_short_end2-$containX_short_end2))
                                    { 
                                        $s++;
                                    }
                                    if ($e < $read_length-($overlap+$left+1-$containX_short_start2-$containX_short_start2))
                                    { 
                                        $e++;
                                    }
                                }
                                   
            %merged_match = (%merged_match1, %merged_match2);
            %merged_match_back = (%merged_match_back1, %merged_match_back2);
            my $mmr = keys %merged_match;
            my $mmbr = keys %merged_match_back;

            if ($y > $startprint2)
            {
                print OUTPUT5 $mmr." MATCH_ARRAY_READ\n";
                print OUTPUT5 $mmbr." MATCH_ARRAY_BACK_READ\n";
            }
            if ($AT_rich_before ne "" && $mmr < 7 && $no_AT eq "")
            {
                $no_AT = "yes";
                goto NO_AT;
            }
            elsif ($no_AT eq "yes" && $mmr > 150)
            {
                $no_AT = "yes2";
                goto NO_AT;
            }
            if ($save_reads ne "")
            {                                  
                my %allmatches = (%merged_match,%merged_match_back);
                foreach my $add_read (keys %allmatches)
                {
                    my $add_read2 = substr $add_read, 0, -1;
                    $save_reads{$add_read2} = undef;
                }
            }
            foreach my $add_read2 (keys %merged_match)
            {
                my $add_read = substr $add_read2, 0, -1;
                $count_reads_all{$add_read} = undef;
            }
            foreach my $add_read2 (keys %merged_match_back)
            {
                my $add_read = substr $add_read2, 0, -1;
                $count_reads_all{$add_read} = undef;
            }
REGEX:
            my $time_for_FOUND = '0';
            my $time_for_NO_MATCH = '0';
            my $time_test = '0';
            
            my $read_count = '0';
            my $read_ex = '0';
            
            if ($y > $startprint2)
            {
                if ($use_regex ne "")
                {
                    print OUTPUT5 $use_regex." USE_REGEX_REVERSE\n";
                }
            }
            if ($y > $startprint2 && $benchmark_time eq "yes")
            {
                $time_end_hash_scan = time;
                if ($time_end_hash_scan - $time_start_seed > 2)
                {
                    print OUTPUT5 $time_end_hash_scan - $time_start_seed." TIME1\n";
                }
            }
            if ($noforward eq "stop")
            {
                goto BACK;
            }
            my $test_N1 = $read_end =~ tr/\./\./;
            my %read_end_dot = %read_end;
            if ($contain_dot_short_end2 > 0)
            {
                if ($mmr > 80 && $test_N1 > 0 && $test_N1 < 4)
                {
                    undef %read_end_dot;
                    %read_end_dot = build_partial3b $read_end, "";
                }
            }
            my $extra_overlap = '0';
            my $read_short_end_tempie = "";
            my $read_short_end_3b = "";
            my @read_short_end_tmp2;
            undef @read_short_end_tmp2;
            my $test_dot = '0';
            my $test_star = '0';    
            undef %hash_read_short_end;
            undef %hash_read_short_end_dot;
            if ($last_chance ne "yes")
            {
                $extra_overlap = sprintf("%.0f", (($read_length-$overlap)/3));
                if (length($read) < $insert_size*$insert_range && $hp_seed_assemble ne "")
                {
                    $extra_overlap = '0';
                }
                $read_short_end_tempie = substr $read, -($insert_size*$insert_range)+10, ((($insert_size*$insert_range)-$insert_size)*2)+$read_length-($read_length-$overlap-$extra_overlap-10)+($read_length-$left-$right-$overlap);
                if ($hp_seed_assemble ne "")
                {
                    $read_short_end_tempie = substr $read, -$insert_size*2;              
                }
                $read_short_end_tempie =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                undef %read_short_end_tmp;
                $test_dot = $read_short_end_tempie =~ tr/\./\./;
                $test_star = $read_short_end_tempie =~ tr/\*/\*/;

                if (($test_dot < 3 || ($mmr > 80 && $test_star < 1 && $test_dot < 6)) && $mmr > 20)
                {
                     %read_short_end_tmp = build_partial3b ($read_short_end_tempie,"","no_delete");
                     $read_short_end_3b = "yes";
                }
                else
                {
                    %read_short_end_tmp = build_partial3c ($read_short_end_tempie,"","no_delete");      
                }
        
                if ($test_star > 0)
                {
                    %read_short_end_tmp2 = build_partial3c ($read_short_end_tempie,"","no_delete");    
                }
                else
                {
                   $read_short_end_tmp2{$read_short_end_tempie} = undef;
                   @read_short_end_tmp2 = split //, $read_short_end_tempie;
                }

                my $ff = '0';    
                undef %hash_read_short_end;
                undef %hash_read_short_end_dot;
                foreach my $read_short_end_tempie (keys %read_short_end_tmp)
                {
                    $ff = '0';
                    my @length_before0;
                    undef @length_before0;
                    if ($test_star > 0)
                    {
                        @length_before0 = split /\*/, $read_short_end_tmp{$read_short_end_tempie};
                    }
                    while ($ff < (length($read_short_end_tempie)-($overlap+$extra_overlap)-1))
                    {
                        my $read_short_end_part = substr $read_short_end_tempie, $ff, $overlap+$extra_overlap;
                        if (exists($hash_read_short_end_dot{$read_short_end_part}) || exists($hash_read_short_end{$read_short_end_part}))
                        {}
                        else
                        {
                            my $star_correction = '0';
                            foreach my $lengt_before0 (@length_before0)
                            {
                                my @lengt_before = split /\+/, $lengt_before0;
                                if ($lengt_before[1] < $ff)
                                {
                                    $star_correction += $lengt_before[0];
                                }
                            }
                            if ($test_dot > 0 && $read_short_end_3b eq "" && $test_star > 0)
                            {
                                my $test_dot2 = $read_short_end_part =~ tr/\./\./;
                                if ($test_dot2 > 0)
                                {
                                    $hash_read_short_end_dot{$read_short_end_part} = $ff+$star_correction;
                                }
                                else
                                {
                                    $hash_read_short_end{$read_short_end_part} = $ff+$star_correction;
                                }
                            }
                            else
                            {
                                $hash_read_short_end{$read_short_end_part} = $ff+$star_correction;
                            } 
                        }
                        $ff++;
                    }
                }
            }
            
NO_MATCH:   foreach my $ln (keys %merged_match)
            {
                $match = $merged_match{$ln};
                
                $id_match = $ln;
                chomp $id_match;
                chomp $match;
           
                my $time_no_match = time;
                my $SNP_in_forward_read = "";
                
                if ($hp_seed_assemble ne "" && $NUMT eq "")
                {
                    foreach my $pos_tmp (keys %SNPs)
                    {
                        if ($pos_tmp <= $position && $pos_tmp > $position-length($match))
                        {
                            $SNP_in_forward_read = "yes";
                        }                                   
                    }
                    if ($SNP_in_forward_read ne "yes" && $last_chance eq "yes")
                    {
                        next NO_MATCH;
                    }
                }
                if ($last_chance eq "yes")
                {                             
                    my $forward = "";
                    if (exists($merged_match1{$ln}))
                    {
                        my $match_reverse = reverse($match);
  
                        if (length($match_reverse) > ($merged_match_pos{$ln}+$right+$overlap) && $heteroplasmy ne "" && $hp_seed_assemble eq "")
                        {
                            my $last_nuc = substr $test, -1, 1;
                            if (($last_nuc eq "1" || $last_nuc eq "2" || $last_nuc eq "3" || $last_nuc eq "4" || $last_nuc eq "N") && $SNR_read eq "")
                            {
                                $exlude_id_prev_nuc_hp{$ln} = undef;
                            }
                        }
                        elsif ($heteroplasmy ne "" && length($match_reverse) <= ($merged_match_pos{$ln}+$right+$overlap))
                        {
                            next NO_MATCH;
                        }
                        
                        my $test = substr $match_reverse, ($merged_match_pos{$ln}+$right), $overlap;
                        
                        if ($use_quality ne "")
                        {   
                            $test =~ tr/1234ACTG/TGACTGAC/;
                        }
                        else
                        {
                            $test =~ tr/ACTG/TGAC/;
                        }
                        
                        foreach my $read_end_tmp (keys %read_end_dot)
                        {
                            if ($test eq $read_end_tmp)
                            {
                                $extension = substr $match_reverse, ($merged_match_pos{$ln}+$right+$overlap);                     
                                $read_count++;
                                goto LAST1;
                            }
                        }
                       
                        my $test_N2 = $test =~ tr/N/\./;
        
                        if ($test_N1 > 0 && $test_N2 eq '0' && $test_N1 < $overlap/6)
                        {
                            foreach my $read_end_tmp (keys %read_end)
                            {
                                if ($test =~ m/$read_end_tmp/)
                                {
                                    $extension = substr $match_reverse, ($merged_match_pos{$ln}+$right+$overlap);          
                                    $read_count++;
                                    goto LAST1;
                                }
                            }
                        }
                        elsif ($test_N2 > 0 && $test_N1 eq '0' && $test_N2 < $overlap/6)
                        {
                            foreach my $read_end_tmp (keys %read_end)
                            {
                                if ($read_end_tmp =~ m/$test/)
                                {
                                    $extension = substr $match_reverse, ($merged_match_pos{$ln}+$right+$overlap);                       
                                    $read_count++;
                                    goto LAST1;
                                }
                            }
                        }
                        foreach my $read_end_tmp (keys %read_end)
                        {
                            my @test_tmp = split //, $test;
                            my @read_end_tmp = split //, $read_end_tmp;

                            my $d = '0';
                            my $next = "";
                            my $N = '0';
                                                                    
                            while ($d < length($read_end_tmp))
                            {
                                if ($test_tmp[$d] eq $read_end_tmp[$d])
                                {
                                }
                                elsif ($read_end_tmp[$d] eq ".")
                                {
                                }
                                elsif ($test_tmp[$d] eq "." && $N < '5')
                                {
                                    $N++;
                                }
                                elsif ($next eq "" && $hp_seed_assemble eq "" && length($read) > $insert_size+200)
                                {
                                    $next = "yes";
                                }
                                elsif ($next eq "yes")
                                {
                                    $next = "yes2";
                                }
                                elsif ($next eq "yes2")
                                {
                                    $next = "yes3";
                                }
                                else
                                {
                                    next NO_MATCH;
                                }
                                $d++    
                            }

                            $extension = substr $match_reverse, ($merged_match_pos{$ln}+$right+$overlap);

                            $read_count++;
                            goto LAST1;
                        }               
                    }
                    if (exists($merged_match2{$ln}))
                    {
                        my $test = substr $match, $merged_match_pos{$ln}+$left, $overlap;
                        
                        if (length($match) > ($merged_match_pos{$ln}+$left+$overlap) && $heteroplasmy ne "" && $hp_seed_assemble eq "")
                        {
                            my $last_nuc = substr $test, -1, 1;
                            if (($last_nuc eq "1" || $last_nuc eq "2" || $last_nuc eq "3" || $last_nuc eq "4" || $last_nuc eq "N") && $SNR_read eq "")
                            {
                                $exlude_id_prev_nuc_hp{$ln} = undef;
                            }
                        }
                        elsif ($heteroplasmy ne "" && $hp_seed_assemble eq "" && length($match) <= ($merged_match_pos{$ln}+$left+$overlap))
                        {
                            next NO_MATCH;
                        }
                        if ($use_quality ne "")
                        {
                            $test =~ tr/1234/ACTG/;
                        }
                        foreach my $read_end_tmp (keys %read_end_dot)
                        {
                            if ($test eq $read_end_tmp)
                            {
                                $extension = substr $match, $merged_match_pos{$ln}+$left+$overlap;
                                $forward = "yes";
                                                       
                                $read_count++;
                                goto LAST1;
                            }
                        }
                        my $test_N2 = $test =~ tr/N/\./;
        
                        if ($test_N1 > 0 && $test_N2 eq '0' && $test_N1 < $overlap/6)
                        {
                            foreach my $read_end_tmp (keys %read_end)
                            {
                                if ($test =~ m/$read_end_tmp/)
                                {
                                    $extension = substr $match, $merged_match_pos{$ln}+$left+$overlap;
                                    $forward = "yes";
                                                           
                                    $read_count++;
                                    goto LAST1;
                                }
                            }
                        }
                        elsif ($test_N2 > 0 && $test_N1 eq '0' && $test_N2 < $overlap/6)
                        {
                            foreach my $read_end_tmp (keys %read_end)
                            {
                                if ($read_end_tmp =~ m/$test/)
                                {
                                    $extension = substr $match, $merged_match_pos{$ln}+$left+$overlap;
                                    $forward = "yes";
                                                           
                                    $read_count++;
                                    goto LAST1;
                                }
                            }
                        }
                        foreach my $read_end_tmp (keys %read_end)
                        {
                            my @test_tmp = split //, $test;
                            my @read_end_tmp = split //, $read_end_tmp;

                            my $d = '0';
                            my $next = "";
                            my $N = '0';
                                                                    
                            while ($d < length($read_end_tmp))
                            {
                                if ($test_tmp[$d] eq $read_end_tmp[$d])
                                {
                                }
                                elsif ($read_end_tmp[$d] eq ".")
                                {
                                }
                                elsif ($test_tmp[$d] eq "." && $N < '5')
                                {
                                    $N++;
                                }          
                                elsif ($next eq "" && $hp_seed_assemble eq "" && length($read) > $insert_size+200)
                                {
                                    $next = "yes";
                                }
                                elsif ($next eq "yes")
                                {
                                    $next = "yes2";
                                }
                                elsif ($next eq "yes2")
                                {
                                    $next = "yes3";
                                }
                                elsif ($containX_short_end2 > 0)
                                {
                                    goto STAR;
                                }
                                else
                                {
                                    next NO_MATCH;
                                }
                                $d++    
                            }

                            $extension = substr $match, $merged_match_pos{$ln}+$left+$overlap;
                            $forward = "yes";

                            $read_count++;
                            goto LAST1;
                        }
                    }
                    
STAR:               if (exists($merged_match1{$ln}))
                    {
                        if ($containX_short_end2 > 0)
                        {
                            foreach my $line (keys %read_end_b)
                            {
                                my @read_end_b_sub;
                                undef @read_end_b_sub;
                                if ($position > $insert_size+200 && $hp_seed_assemble eq "" && $read_count < 60)
                                {
                                    @read_end_b_sub = build_partialb $line;
                                }
                                else
                                {
                                    push @read_end_b_sub, $line;
                                }
                                                           
                                my $found_seq = '0';
                                my $match2 = $match;
                                if ($use_quality ne "")
                                {
                                   $match2 =~ tr/1234/ACTG/;
                                }
                                my $match2_tmp = $match2;
                                
                                foreach my $read_end_b_sub (@read_end_b_sub)
                                {
                                    $found_seq = $match2 =~ s/(.)$read_end_b_sub/$1+/;
                                    if ($found_seq > 1)
                                    {
                                        my $pos = $merged_match_pos{$ln};
                                        my $match4b = substr $match2_tmp, 0, -$pos;
                                        $match4b =~ s/(.+)$read_end_b_sub/$1+/;
                                        my @ext = split /\+/, $match4b;
                                        my $extension5 = $ext[0];
                                        $extension = reverse ($extension5);
        
                                        $read_count++;
                                        goto LAST1;     
                                    }
                                    elsif ($found_seq > 0)
                                    {
                                        my @ext = split /\+/, $match2;
                                        my $extension5 = $ext[0];
                                        $extension = reverse($extension5);
    
                                        $read_count++;
                                        goto LAST1;     
                                    }
                                }
                            }
                        }
                    }
                    elsif (exists($merged_match2{$ln}))
                    {
                        if ($containX_short_end2 > 0)
                        {
                            foreach my $line (keys %read_end)
                            {
                                my @read_end_sub;
                                undef @read_end_sub;
                                if (length($read) > $insert_size+200 && $hp_seed_assemble eq "" && $read_count < 60)
                                {
                                    @read_end_sub = build_partialb $line;
                                }
                                else
                                {
                                    push @read_end_sub, $line;
                                }                            
                                my $found_seq = '0';
                                my $match2 = $match;
                                if ($use_quality ne "")
                                {
                                   $match2 =~ tr/1234/ACTG/;
                                }
                                my $match2_tmp = $match2;
                                
                                foreach my $read_end_sub (@read_end_sub)
                                {
                                    $found_seq = $match2 =~ s/.$read_end_sub/+/;
        
                                    if ($found_seq > 1)
                                    {
                                        my $pos = $merged_match_pos{$ln};
                                        my $match4b = substr $match2_tmp, $pos-2;
                                        $match4b =~ s/.$read_end_sub/+/;
                                        my @ext = split /\+/, $match4b;
                                        $extension = $ext[1];
                                        
                                        $read_count++;
                                        goto LAST1;     
                                    }
                                    elsif ($found_seq > 0)
                                    {
                                        my @ext = split /\+/, $match2;
                                        my $extension5 = $ext[1];
                                        $extension = substr $match, -length($extension5), length($extension5);
                                        
                                        $read_count++;
                                        $forward = "yes";
                                        goto LAST1;
                                    }
                                }
                            }
                        }
                    }
                    next NO_MATCH;
               
LAST1:                              
                    if ($extension eq "NOOO" || $extension eq " " || $extension eq "")
                    {
                        next NO_MATCH;
                    }
                    
                    if ($hp_seed_assemble ne "" && $NUMT eq "")
                    {
                        my $check = "";
                        my %SNPs_or_not;
                        undef %SNPs_or_not;
                        %SNPs_or_not = %SNPs;                         
                        my $check_no_SNPs = "";

HP_SNP1:                    foreach my $pos_tmp (keys %SNPs_or_not)
                        {             
                            if ($pos_tmp <= $position && $pos_tmp > ($position-length($match)+length($extension)))
                            {
                                if (exists($merged_match1{$ln}))
                                {
                                    my $match_tmp = reverse($match);             
                                    my $hp_SNP_read = substr $match_tmp, -length($extension)-$position-1+$pos_tmp, 1;
                                    $hp_SNP_read =~ tr/ACTG1234/TGACTGAC/;

                                    if ($hp_SNP_read ne $SNPs_or_not{$pos_tmp})
                                    {
                                        $check = "no";
                                        last HP_SNP1;
                                    }
                                    elsif ($hp_SNP_read eq $SNPs_or_not{$pos_tmp} && $check_no_SNPs eq "")
                                    {
                                        $check = "yes";
                                        $hp_SNP_links{$pos_tmp} .= exists $hp_SNP_links{$pos_tmp} ? ",$ln" : $ln;
                                    }
                                }
                                elsif (exists($merged_match2{$ln}))
                                {                       
                                    my $hp_SNP_read = substr $match, -length($extension)-$position-1+$pos_tmp, 1;
                                    $hp_SNP_read =~ tr/1234/ACTG/;

                                    if ($hp_SNP_read ne $SNPs_or_not{$pos_tmp})
                                    {
                                        $check = "no";
                                        last HP_SNP1;
                                    }
                                    elsif ($hp_SNP_read eq $SNPs_or_not{$pos_tmp} && $check_no_SNPs eq "")
                                    {
                                        $check = "yes";
                                        $hp_SNP_links{$pos_tmp} .= exists $hp_SNP_links{$pos_tmp} ? ",$ln" : $ln;
                                    }
                                }
                            }
                        }
                        if ($check_no_SNPs eq "" && $check ne "no")
                        {
                            undef %SNPs_or_not;
                            %SNPs_or_not = %noSNPs;
                            $check_no_SNPs = "yes";
                            goto HP_SNP1;
                        }
                        if ($check ne "yes")
                        {
                            next NO_MATCH;
                        }
                    }
                    if ($use_quality ne "" && ($SNR_critical ne "" || $no_quality ne "" || $hp_seed_assemble ne "" || $no_hp_one_turn ne ""))
                    {
                        if (exists($merged_match1{$ln}))
                        {
                            $extension =~ tr/1234ACTG/TGACTGAC/;
                        }
                        elsif (exists($merged_match2{$ln}))
                        {
                            $extension =~ tr/1234/ACTG/;
                        }
                    }
                    elsif (exists($merged_match1{$ln}))
                    {
                        $extension =~ tr/ACTG1234/TGAC3412/;
                    }
                    
                    my $nuc_exlude = "test";
                    if ($yuyu_option_A eq "A" || $yuyu_option_C eq "C" || $yuyu_option_T eq "T" || $yuyu_option_G eq "G")
                    {
                        $nuc_exlude = substr $extension, 0, 1;
                        $nuc_exlude =~ tr/1234/ACTG/;
                    }
                    if ($nuc_exlude ne $yuyu_option_A && $nuc_exlude ne $yuyu_option_C && $nuc_exlude ne $yuyu_option_T && $nuc_exlude ne $yuyu_option_G)
                    {
                        my $match_tmp = $match;

                        if (exists($merged_match1{$ln}))
                        {
                            my $match_reverse = reverse($match_tmp);
                            $match_tmp = $match_reverse;
                        }
                        $extensions_for_before{$id_match} = $extension;
                        $extensions_for_before_match{$id_match} = $match_tmp;
                        if (exists($merged_match_pair{$ln}))
                        {
                            $match_pair = $merged_match_pair{$ln};     
                            chomp($match_pair);
                            $extensions_for_before_match_pair{$id_match} = $match_pair;
                        }
                        
                        push @matches, $id_match.",".$extension.","."".",".$match.","."";
                        if ($forward eq "yes")
                        {
                            $extensions2b{$id_match} = $extension;
                        }
                        else
                        {
                            $extensions1b{$id_match} = $extension;
                        }
                        if ($save_reads ne "")
                        {                                  
                            my $add_read = substr $id_match, 0, -1;
                            $save_reads{$add_read} = undef;
                        }
                    }
                    next NO_MATCH;
                }
                else
                {  
                    my $match_reverse = reverse($match);
                    my $test = substr $match_reverse, ($merged_match_pos{$ln}+$right), $overlap;

                    if (length($match_reverse) > ($merged_match_pos{$ln}+$right+$overlap) && $heteroplasmy ne "")
                    {
                        my $last_nuc = substr $test, -1, 1;
                        if ($heteroplasmy ne "" && ($last_nuc eq "1" || $last_nuc eq "2" || $last_nuc eq "3" || $last_nuc eq "4" || $last_nuc eq "N") && $SNR_read eq "")
                        {
                            $exlude_id_prev_nuc_hp{$ln} = undef;
                        }
                    }
                    elsif ($heteroplasmy ne "" && length($match_reverse) <= ($merged_match_pos{$ln}+$right+$overlap))
                    {
                        next NO_MATCH;
                    }
                    if ($containX_short_end2 > 0)
                    {
                        goto STAR2;
                    }

                    if ($use_quality ne "")
                    {   
                        $test =~ tr/1234ACTG/TGACTGAC/;
                    }
                    else
                    {
                        $test =~ tr/ACTG/TGAC/;
                    }
            
                    foreach my $read_end_tmp (keys %read_end_dot)
                    {
                        if ($test eq $read_end_tmp)
                        {
                            $extension = substr $match_reverse, ($merged_match_pos{$ln}+$right+$overlap);
                            $read_count++;
                            goto FOUND;
                        }
                    }
                    
                    my $test_N2 = $test =~ tr/N/\./;
    
                    if ($test_N1 > 0 && $test_N2 eq '0' && $test_N1 < $overlap/5)
                    {
                        foreach my $read_end_tmp (keys %read_end)
                        {
                            if ($test =~ m/$read_end_tmp/)
                            {
                                $extension = substr $match_reverse, ($merged_match_pos{$ln}+$right+$overlap);                                   
                                $read_count++;
                                goto FOUND;
                            }
                        }
                    }
                    elsif ($test_N2 > 0 && $test_N1 eq '0' && $test_N2 < $overlap/5)
                    {
                        foreach my $read_end_tmp (keys %read_end)
                        {
                            if ($read_end_tmp =~ m/$test/)
                            {
                                $extension = substr $match_reverse, ($merged_match_pos{$ln}+$right+$overlap);             
                                $read_count++;
                                goto FOUND;
                            }
                        }
                    }
                    
                    foreach my $read_end_tmp (keys %read_end)
                    {    
                        my @test_tmp = split //, $test;
                        my @read_end_tmp = split //, $read_end_tmp;

                        my $d = '0';
                        my $next = "";
                        my $N = '0';
                                                                
                        while ($d < length($read_end_tmp))
                        {
                            if ($test_tmp[$d] eq $read_end_tmp[$d])
                            {
                            }
                            elsif ($read_end_tmp[$d] eq ".")
                            {
                            }
                            elsif ($test_tmp[$d] eq "." && $N < '5')
                            {
                                $N++;
                            }
                            elsif ($next eq "" && $hp_seed_assemble eq "" && $use_regex eq "yes")
                            {
                                $next = "yes";
                            }
                            elsif ($next eq "yes")
                            {
                                $next = "yes2";
                            }
                            elsif ($next eq "yes2")
                            {
                                $next = "yes3";
                            }
                            else
                            {
                                next NO_MATCH;
                            }
                            $d++    
                        }

                        $extension = substr $match_reverse, ($merged_match_pos{$ln}+$right+$overlap);

                        $read_count++;                           
                        goto FOUND;
                    }
                }
                
STAR2:              if ($containX_short_end2 > 0)
                {
                    foreach my $line (keys %read_end_b)
                    {
                        my $found_seq = '0';
                        my $match4 = $match;
                        my @read_end_b_sub;
                        undef @read_end_b_sub;
                        if ($hp_seed_assemble eq "" && $use_regex eq "yes")
                        {
                            @read_end_b_sub = build_partialb $line;
                        }
                        else
                        {
                            push @read_end_b_sub, $line;
                        }
                        if ($use_quality ne "")
                        {
                           $match4 =~ tr/1234/ACTG/;
                        }
                        
                        foreach my $read_end_b_subc (@read_end_b_sub)
                        {
                            $found_seq = $match4 =~ s/(.)$read_end_b_subc/$1+/g;
                            if ($found_seq > 1)
                            {
                                my $pos = $merged_match_pos{$ln};
                                my $match4b = substr $match, 0, -$pos;
                                $match4b =~ s/(.+)$line/$1+/;
                                my @ext = split /\+/, $match4b;
                                my $extension5 = $ext[0];
                                $extension = reverse ($extension5);
    
                                $read_count++;
                                goto FOUND;     
                            }
                            elsif ($found_seq > 0)
                            {
                                my @ext = split /\+/, $match4;
                                my $extension5 = $ext[0];
                                my $extension4 = substr $match, 0, length($extension5);
                                $extension = reverse($extension4);
                                                                                       
                                $read_count++;
                                goto FOUND;     
                            }
                        }
                    }
                }
                next NO_MATCH;

FOUND:          if ($last_chance eq "yes" || $extension eq "NOOO" || $extension eq " " || $extension eq "")
                {           
                    next NO_MATCH;
                }
                if ($hp_seed_assemble ne "" && $last_chance ne "yes" && $NUMT eq "" && $SNP_in_forward_read eq "yes")
                {
                    my $check = "";
                    my %SNPs_or_not;
                    undef %SNPs_or_not;
                    %SNPs_or_not = %SNPs;                         
                    my $check_no_SNPs = "";

HP_SNP2:                foreach my $pos_tmp (keys %SNPs_or_not)
                    {             
                        if ($pos_tmp <= $position && $pos_tmp > ($position-length($match)+length($extension)))
                        {
                            my $match_tmp = reverse($match);             
                            my $hp_SNP_read = substr $match_tmp, -length($extension)-$position-1+$pos_tmp, 1;
                            $hp_SNP_read =~ tr/ACTG1234/TGACTGAC/;
            
                            if ($hp_SNP_read ne $SNPs_or_not{$pos_tmp})
                            {
                                $check = "no";
                                last HP_SNP2;
                            }
                            elsif ($hp_SNP_read eq $SNPs_or_not{$pos_tmp} && $check_no_SNPs eq "")
                            {
                                $check = "yes";
                                $hp_SNP_links{$pos_tmp} .= exists $hp_SNP_links{$pos_tmp} ? ",$ln" : $ln;
                            }
                        }
                    }
                    if ($check_no_SNPs eq "" && $check ne "no")
                    {
                        undef %SNPs_or_not;
                        %SNPs_or_not = %noSNPs;
                        $check_no_SNPs = "yes";
                        goto HP_SNP2;
                    }
                    if ($check eq "no")
                    {
                        delete $accepted_SNPs{$ln};
                        next NO_MATCH;
                    }
                    elsif ($check eq "yes")
                    {
                        $accepted_SNPs{$ln} = undef;
                    }
                }
    my $time_FOUND = time;
    $time_for_NO_MATCH += ($time_FOUND-$time_no_match);
    
                $read_ex++;
                if (exists($merged_match_pair{$ln}))
                {
                    $match_pair = $merged_match_pair{$ln};     
                    chomp($match_pair);                   
                    my $ext_for_before_tmp = $extension;
                    if ($use_quality ne "" && ($SNR_critical ne "" || $no_quality ne "" || $hp_seed_assemble ne "" || $no_hp_one_turn ne ""))
                    {
                        $ext_for_before_tmp =~ tr/1234ACTG/TGACTGAC/;
                    }
                    else
                    {
                        $ext_for_before_tmp =~ tr/ACTG1234/TGAC3412/;
                    }
                    my $match_tmp = reverse($match);
                    $extensions_for_before{$id_match} = $ext_for_before_tmp;
                    $extensions_for_before_match{$id_match} = $match_tmp;
                    $extensions_for_before_match_pair{$id_match} = $match_pair;
                    my $match_pair_middle = substr $match_pair, 10, $overlap+$extra_overlap;
                    my $countN = $match_pair_middle =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
                    
                    my $extra_regex_tmp = "";
                    if ($countN > 0 && $countN < length($match_pair_middle)/5)
                    {
                        $extra_regex_tmp = "yes";
                    }
                    elsif ($countN >= length($match_pair_middle)/5)
                    {
                        next NO_MATCH;
                    }
                    if ($use_quality ne "")
                    {
                        $match_pair_middle =~ tr/1234/ACTG/;
                    }
 my $time_FOUND_EXTRA_REGEX = time;
 
                    if (exists($hash_read_short_end{$match_pair_middle}))
                    {
                        $extension_match = "";
                        if ($insert_size_correct eq "yes" && length($read) > $insert_size*$insert_range && $repetitive_detect eq "")
                        {
                            my $cal = ($insert_size*$insert_range)-10;
                            if ($cal > length($read))
                            {
                                $cal = length($read);
                            }
                            my $insert_size_tmp = $cal-$hash_read_short_end{$match_pair_middle}+10+length($extension);        
                            push @insert_size, $insert_size_tmp;
                        }
                        if ($hp_seed_assemble ne "" && $NUMT eq "")
                        {
                            my $ch = check_HP_pos($hash_read_short_end{$match_pair_middle}, $position, $position_back, $match_pair, $ln);
                            if ($ch eq "no")
                            {
                                next NO_MATCH;
                            }
                        }
                        goto SKIP3;
                    }
                    
                    if ($read_short_end_3b eq "" || $extra_regex_tmp eq "yes" || $use_regex eq "yes")
                    {                                                                                         
                        my @match_pair_middle_sub = split //, $match_pair_middle;
                        my $gh = '0';
                        $extension_match = "";
                        foreach my $line (keys %read_short_end_tmp2)
                        {
                            my @line;
                            undef @line;
                            $gh = '0';
                            if ($test_star > 0)
                            {
                                @line = split //, $line;
                            }
                            else
                            {
                                @line = @read_short_end_tmp2;
                            }
         
CHECK_PAIR:                     while ($gh < length($line)-length($match_pair_middle))
                            {
                                my $d = '0';
                                my $next = "";
                                my $th = '0';
                                my $N = '0';
                                if ($use_regex ne "yes")
                                {
                                    $next = "yes3";
                                }
                                
                                while ($d < length($match_pair_middle))
                                {
                                    $th = $d + $gh;
                                    if ($match_pair_middle_sub[$d] eq $line[$th])
                                    {
                                    }
                                    elsif ($line[$th] eq "." || $line[$th] eq "N")
                                    {
                                    }
                                    elsif ($match_pair_middle_sub[$d] eq ".")
                                    {
                                        $N++;
                                    }
                                    elsif ($next eq "" && $hp_seed_assemble eq "")
                                    {
                                        $next = "yes";
                                    }
                                    elsif ($next eq "yes")
                                    {
                                        $next = "yes2";
                                    }
                                    elsif ($next eq "yes2")
                                    {
                                        $next = "yes3";
                                    }
                                    else
                                    {
                                        $gh++;
                                        goto CHECK_PAIR;
                                    }
                                    $d++    
                                }
                                if ($test_star > 0)
                                {
                                    my @length_before0 = split /\*/, $read_short_end_tmp{$line};
                                    my $star_correction = '0';
                                    foreach my $lengt_before0 (@length_before0)
                                    {
                                        my @lengt_before = split /\+/, $lengt_before0;
                                        if ($lengt_before[1] < $gh)
                                        {
                                            $star_correction += $lengt_before[0];
                                        }
                                    }
                                    $gh -= $star_correction;
                                }
                                goto CHECK_PAIR0;
                            }
                        }   
                        $extension_match = "NOOO";
                                
CHECK_PAIR0:                    
                        if ($insert_size_correct eq "yes" && length($read) > $insert_size*$insert_range && $repetitive_detect eq "")
                        {
                            my $cal = ($insert_size*$insert_range)-10;
                            if ($cal > length($read))
                            {
                                $cal = length($read);
                            }
                            my $insert_size_tmp = $cal-$gh+10+length($extension);        
                            push @insert_size, $insert_size_tmp;
                        }                                
                   $time_test += (time-$time_FOUND_EXTRA_REGEX);      
                        if ($hp_seed_assemble ne ""  && $NUMT eq "")
                        {
                            my $ch = check_HP_pos($gh, $position, $position_back, $match_pair, $ln);
                            if ($ch eq "no")
                            {
                                next NO_MATCH;
                            }
                        }
                        goto SKIP3;    
                    }
                    if ($test_star > 0)
                    {
                        my $found_seq = '0';
                        my $match_pair_middle_tmp = $match_pair_middle;
CHECK_PAIR2:                foreach my $line (keys %hash_read_short_end_dot)
                        {
                            my $found_seq = '0';
                            my $star_first = substr $line, 0, 1;
                            if ($star_first eq "*")
                            {
                                $line = substr $line, 1;
                                $match_pair_middle_tmp = substr $match_pair_middle_tmp, 1;
                            }                       
                            $found_seq = $match_pair_middle_tmp =~ s/$line/+/;
                            if ($found_seq > 0)
                            {
                                last CHECK_PAIR2;
                            }
                        }
                        if ($found_seq > 0)
                        {
                            if ($insert_size_correct eq "yes" && length($read) > $insert_size*$insert_range && $repetitive_detect eq "")
                            {
                                my $cal = ($insert_size*$insert_range)-10;
                                if ($cal > length($read))
                                {
                                    $cal = length($read);
                                }
                                my $insert_size_tmp = $cal-$hash_read_short_end_dot{$match_pair_middle}+10+length($extension);        
                                push @insert_size, $insert_size_tmp;
                            }
                            $extension_match = "";
                            if ($hp_seed_assemble ne "" && $NUMT eq "")
                            {
                                my $ch = check_HP_pos($hash_read_short_end_dot{$match_pair_middle}, $position, $position_back, $match_pair, $ln);
                                if ($ch eq "no")
                                {
                                    next NO_MATCH;
                                }
                            }
                            goto SKIP3;
                        }
                        else
                        {
                            $extension_match = "NOOO";
                        }
                    }
                    $extension_match = "NOOO";
SKIP3:
                    if ($extension_match eq "NOOO")
                    {
                        next NO_MATCH;
                    }
                    if ($hp_seed_assemble ne ""  && $NUMT eq "" && $no_hp_one_turn2 eq "")
                    {
                        my $check = "";
                        if (exists($accepted_SNPs{$ln}))
                        {
                            $check = "yes";
                        }
                        elsif (exists($accepted_SNPs_pair{$ln}))
                        {
                            $check = "yes";
                        }
                        if ($check ne "yes")
                        {
                            next NO_MATCH;
                        }
                    }
                    if ($use_quality ne "" && ($SNR_critical ne "" || $no_quality ne "" || $hp_seed_assemble ne "" || $no_hp_one_turn ne ""))
                    {
                        $extension =~ tr/1234ACTG/TGACTGAC/;
                    }
                    else
                    {
                        $extension =~ tr/ACTG1234/TGAC3412/;
                    }
                    my $nuc_exlude = "test";
                    if ($yuyu_option_A eq "A" || $yuyu_option_C eq "C" || $yuyu_option_T eq "T" || $yuyu_option_G eq "G")
                    {
                        $nuc_exlude = substr $extension, 0, 1;
                        $nuc_exlude =~ tr/1234/ACTG/;
                    }
                    if ($nuc_exlude ne $yuyu_option_A && $nuc_exlude ne $yuyu_option_C && $nuc_exlude ne $yuyu_option_T && $nuc_exlude ne $yuyu_option_G)
                    {   
                        $extensions1b{$id_match} = $extension;
                        push @matches, $id_match.",".$extension.","."".",".$match.",".$match_pair;
                        if ($save_reads ne "")
                        {                                  
                            my $add_read = substr $id_match, 0, -1;
                            $save_reads{$add_read} = undef;
                        }
                    }                                                                                           
                }
                my $time_after_FOUND = time;
                $time_for_FOUND += ($time_after_FOUND-$time_FOUND);
            }

            %extensionsb = (%extensions1b, %extensions2b);
            %extensionsb_original = %extensionsb;

            my $ext = '0';
            my $ext_total = '0';
            foreach (keys %extensionsb)
            {
                $ext++;
            }
            $ext_total = $ext;
            if ($y > $startprint2)
            {
                print OUTPUT5 "\n".$read_count ." READ_COUNT\n";
                print OUTPUT5 $read_ex ." READ_EX\n";
                print OUTPUT5 $ext ." EXTENSIONS\n";     
            }
            if ($count_coverage < 20)
            {
                $total_extensions += $ext;
                $count_coverage++;
                $average_coverage_ext = sprintf("%.0f",$total_extensions/$count_coverage);
                print OUTPUT5 $average_coverage_ext ." AVERAGE_COVERAGE\n";
            }
            
            if ($y > $startprint2 && $benchmark_time eq "yes")
            {
                $time_collect_ext = time;
                
                if ($time_collect_ext-$time_end_hash_scan > 2)
                {
                    print OUTPUT5 $time_collect_ext-$time_end_hash_scan." TIME2\n";
                    print OUTPUT5 $time_for_NO_MATCH." TIME_FOR_NO_MATCH\n";
                    print OUTPUT5 $time_for_FOUND." TIME_FOR_FOUND\n";
                }
            }
     
            if (($y > $startprint && $print_log eq '2') || $hp_seed_assemble eq "gqg" || ($y > 2000000000000000000000000000007 && $y < 209) || $SNR_read eq "dgd" || $last_chance eq "ydges")
            {
                foreach my $matches (@matches)
                {
                    my @matchesb;
                    undef @matchesb;
                    @matchesb = split /,/, $matches;
                    my $m_reverse = reverse($matchesb[3]);
                    $m_reverse =~ tr/ACTG/TGAC/;
                    my $mp_reverse = reverse($matchesb[4]);
                    $mp_reverse =~ tr/ACTG/TGAC/;
                    print OUTPUT5 $matchesb[0].",".$matchesb[1]."\n";
                    if (exists($merged_match1{$matchesb[0]}))
                    {
                    }
                    elsif (exists($merged_match2{$matchesb[0]}))
                    {
                    }
                }               
            }

            my %extensionsb_group1;
            my %extensionsb_group2;
            my %extensionsb_group3;
            my %extensionsb_group4;
            my %extensionsb_group1_old;
            my %extensionsb_group2_old;
            my %extensionsb_group3_old;
            my %extensionsb_group4_old;       
            undef %extensionsb_group1;
            undef %extensionsb_group2;
            undef %extensionsb_group3;
            undef %extensionsb_group4;
            undef %extensionsb_group1_old;
            undef %extensionsb_group2_old;
            undef %extensionsb_group3_old;
            undef %extensionsb_group4_old;  
            
            my $no_SNR = "";
            my %extensionsb_backup = %extensionsb;
            
            my $removed_N_reads = "";
            my $percentage_N = '0.1';
REMOVE_N:   if ($use_quality eq "yes" && $SNR_read ne "" && $ext_total > 4 && $SNR_critical eq "")
            {
                undef %extensionsb;
                foreach my $extensions_id (keys %extensionsb_original)
                {                                 
                    my $extensions = $extensionsb_original{$extensions_id};
                    my $N = $extensions =~ tr/N1234/N1234/;
                    if ($N/length($extensions) < $percentage_N)
                    {
                        $extensionsb{$extensions_id} = $extensions;
                    }
                }
                my $f = keys %extensionsb;
                print OUTPUT5 $f." EXT-N\n";
                if ($f < 4 && $percentage_N < 0.5)
                {
                    %extensionsb = %extensionsb_original;
                    $percentage_N += 0.1;
                    goto REMOVE_N;
                }
                elsif ($f < 4)
                {
                    %extensionsb = %extensionsb_original;
                }
                elsif ($removed_N_reads ne "yes1")
                {
                    $removed_N_reads = "yes";
                }
            }
SPLIT:
            if ($split eq "yes")
            {
                %extensionsb = %extensionsb_group2;
                $split = "yes2";
                $ext = keys %extensionsb;
            }
            elsif ($split eq "yes2")
            {
                %extensionsb = %extensionsb_group3;
                $split = "yes3";
                $ext = keys %extensionsb;
            }
            elsif ($split eq "yes3")
            {
                %extensionsb = %extensionsb_group4;
                $split = "yes4";
                $ext = keys %extensionsb;
            }
            elsif ($split eq "yes4")
            {
                %extensionsb = %extensionsb_group1;
                $split = "yes5";
                $ext = keys %extensionsb;
                if ($count_split eq '1')
                {
                    $split = "";
                    $split_forward_tmp = "";
                }
            }
            $position = $position{$id};       
            my $l = '0';
            my $best_extension = "";
            my $SNP = '0';
            my $A_SNP = '0';
            my $C_SNP = '0';
            my $T_SNP = '0';
            my $G_SNP = '0';
            my $pos_SNP = '0';
            my $pos_SNP2 = '0';
            my $pos_SNP3 = '0';
            my $pos_SNP4 = '0';
            
            if ($SNR_read eq "")
            {
                $SNR_read = SNR_ahead (\%extensionsb, '0');
            }
    
            my $SNP_to_assemble_check = "";
         
NUCLEO0:            
            if ($SNR_read ne "")
            {
                $ext = keys %extensionsb;
            }
            my $highest_all_freq = '0';
            my $extra_l = '0';
            my $ll = $read_length - ($overlap+$left-1) + $extra_l;
            my $count_hp_SNPS = '0';
            
NUCLEO:     while ($l < $ll && $l < 149)
            {
                my $A = '0';
                my $C = '0';
                my $T = '0';
                my $G = '0';
                my $skipped = '0';
                my $low_quality_nucs = '0';
                
                if ($SNR_read2 ne "" && $l > 0 && $split eq "")
                {
                    my $best_extension_tmp8 = $best_extension;
                    $best_extension_tmp8 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

                    my $last_nuc = substr $best_extension_tmp8, -1;
                    my $arrSize1 = keys %extensionsb;
                    if ($last_nuc ne '.' && $arrSize1 > 4)
                    {
                        my %extensionsb_tmp;
                        undef %extensionsb_tmp;
                        foreach my $extensions_id (keys %extensionsb)
                        {
                            my $extensions = $extensionsb{$extensions_id};
                            my @chars = split//, $extensions;
                            if ($chars[$l-1] eq $last_nuc || length($extensions) < $l)
                            {
                                $extensionsb_tmp{$extensions_id} = $extensions;
                            }
                        }
                        my $arrSize2 = keys %extensionsb_tmp;

                        if ($arrSize1 ne $arrSize2)
                        {
                            undef %extensionsb;
                            %extensionsb = %extensionsb_tmp;
                                                       
                            my $best_extension_dot = $best_extension_tmp8 =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
                            if ($best_extension_dot > 0)
                            {
                                $l = 0;
                                $SNP = '0';
                                $best_extension = "";
                                goto NUCLEO0;
                            }
                        }
                    }               
                }
                
                foreach my $extensions_id (keys %extensionsb)
                {                                
                    my $extensions = $extensionsb{$extensions_id};
                    my @chars = split//, $extensions;
                    if ($l eq '0' && $heteroplasmy ne "" && exists($exlude_id_prev_nuc_hp{$extensions_id}))
                    {
                        $low_quality_nucs++;
                    }  
                    elsif ($chars[$l] eq "A")
                    {
                        $A++;
                    }
                    elsif ($chars[$l] eq "C")
                    {
                        $C++;
                    }
                    elsif ($chars[$l] eq "T")
                    {
                        $T++;
                    }
                    elsif ($chars[$l] eq "G")
                    {
                        $G++;
                    }
                    elsif ($chars[$l] eq "1" || $chars[$l] eq "2" || $chars[$l] eq "3" || $chars[$l] eq "4")
                    {
                        $low_quality_nucs++;
                    }
                    elsif ($chars[$l] ne "")
                    {
                        $skipped++;
                    }
                }
                if (($A+$T+$G+$C) < 1)
                {
                    last NUCLEO;
                }
                my $c = '2.8';
                my $q = '2';
                
                if ($ext > 22 && $SNR_read eq "")
                {
                    $c = '3.7';
                }
                if ($ext > 60)
                {
                    $c = '3.5';
                }
                if ($SNR_read2 ne "" && $l < 5)
                {
                    $c = '1.8';
                }
                if ($ext > 6 && $SNR_read eq "" && ($type ne "chloro" || $extensions_before ne ""))
                {
                    $c = '5';
                }
                if ($ext > 22 && $SNR_read eq "" && $type ne "chloro")
                {
                    $c = '6.5';
                }
                if ($ext > 38 && $SNR_read eq "" && $type ne "chloro")
                {
                    $c = '8.4';
                }
                if ($ext > 100 && $SNR_read eq "" && $type eq "mito_plant")
                {
                    $c = '13';
                }
                if ($ext > $average_coverage_ext*4 && $SNR_read eq "" && $type eq "mito_plant")
                {
                    $c = '25';
                }
                if ($repetitive_detect ne "" && $ext < 23 && $SNR_read eq "")
                {
                   $c = '7';
                }
                if ($repetitive_detect ne "" && $ext >= 23 && $SNR_read eq "")
                {
                   $c = '9';
                }
                if ($repetitive_detect2 eq "yes" || ($repetitive_detect ne "" && $ext > 150))
                {
                   $c = '15';
                }
                if ($extensions_before eq "yes" && $c < 6.3)
                {
                   $c = '6.3';
                }
                if ($extensions_before eq "yes" && $type eq "mito_plant")
                {
                   $c = '13';
                }
                if ($extensions_before eq "yes" && $ext > $average_coverage_ext*0.5 && $type eq "mito_plant")
                {
                   $c = '23';
                }
                if ($extensions_before eq "yes" && $ext > $average_coverage_ext && $type eq "mito_plant")
                {
                   $c = '35';
                }
                if ($type eq "mito_plant")
                {
                    $c += 2;
                }
                    
                my $v = '6';
                my $s = '3';
                my $z = '1';
                my $w = '5';
                if ($need_longer_ext eq "yes" || $split ne "")
                {
                    $w = '10';
                }
                if ($split ne "")
                {
                    $v = '10';
                    $z = '0';
                    $s = '2';
                }
                my $dup = "";
                my $r = 4;
                if ($type eq "mito_plant" && $ext > $average_coverage_ext*3)
                {
                    $dup = "yes";
                    if ($extensions_before eq "yes")
                    {
                        $r = 9;
                    }
                }
                if ($type eq "mito_plant" && $ext > $average_coverage_ext*5)
                {
                    $dup = "yes";
                    if ($extensions_before eq "yes")
                    {
                        $r = 12;
                    }
                }
                my $hp = 10000000000;
                if ($heteroplasmy ne "" && $repetitive_detect eq "" && ($hp_seed_assemble eq "" || $no_hp_one_turn2 ne "") && $split eq "" && $no_hp_one_turn eq "" && ($SNR_read2 eq "" || $need_longer_ext eq ""))
                {
                    $hp = ($A + $T + $G + $C)*$heteroplasmy*0.75;
                    if ($heteroplasmy*0.75 < 0.0048)
                    {
                        $hp = ($A + $T + $G + $C)*0.0048;
                    }
                    $q = 1.5;
                    $v = 4;
                    $z = 2;
                    my $tmp = $read_end.$best_extension;
                    my $dot = $tmp =~ tr/\./\./;
                    if ($skipped/($A + $T + $G + $C+$skipped) > $heteroplasmy && $skipped/($A + $T + $G + $C+$skipped) > 0.02 && $dot < 4)
                    {
                        $hp = ($A + $T + $G + $C)*($heteroplasmy*0.78);
                        if ($heteroplasmy*0.75 < 0.0048)
                        {
                            $hp = ($A + $T + $G + $C)*0.0048;
                        }
                    }
                }
                if ($hp_seed_assemble ne "" && $no_hp_one_turn2 eq "")
                {
                    $v = '40';
                    $q = '1.4';
                    $c += 1;
                    if ($c < 5 && $SNR_read eq "")
                    {
                        $c = '5';
                    }
                }
                
                if ($heteroplasmy ne "" && ($SNR_read_ahead eq "" || $l > 25) && ($SNR_read eq "" || $l > 10) && ($l > 15 || ($l > $w && $SNP < 3)) && (($highest_all_freq > $heteroplasmy/2) || $pos_SNP eq $l-1 || $pos_SNP2 eq $l-1 || $pos_SNP3 eq $l-1))
                {
                    chop($best_extension);
                    last NUCLEO;
                }
                if (($pos_SNP eq '0' && $l eq '1') || ($pos_SNP eq '1' && $l eq '2') || ($pos_SNP eq '2' && $l eq '3') || ($pos_SNP eq '3' && $l eq '4'))
                {
                    $q = '3';
                }
                if ($y eq 'dvsdv')
                {
                    print OUTPUT5 $A."+".$C."+".$T."+".$G."+".$l."+".$ext."+".$skipped."+".$low_quality_nucs."+".$SNP."+".$ll."+".$highest_all_freq."+".$pos_SNP."+".$q."+".$hp."+".$extensions_before."+".$ext_before."+".$w."+".$SNR_read."+".$SNP_active."\n";
                }
                if ($A > ($C + $T + $G)*$c && (($C <= $hp && $T <= $hp && $G <= $hp) || ($C < 2 && $T < 2 && $G < 2)) && (($A > $s && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q) || ($A > $z && $l < $v && ($C + $T + $G) eq 0)) && ($dup ne "yes" || ($C + $T + $G) < $average_coverage_ext/$r))
                {
                    $best_extension = $best_extension."A";
                    $allele_percentage{$l} = $A."+".$C."+".$T."+".$G;
                    $highest_all_freq = ($C+$T+$G)/($A+$C+$T+$G);
                }
                elsif ($C > ($A + $T + $G)*$c && (($A <= $hp && $T <= $hp && $G <= $hp) || ($A < 2 && $T < 2 && $G < 2)) && (($C > $s && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q) || ($C > $z && $l < $v && ($A + $T + $G) eq 0)) && ($dup ne "yes" || ($A + $T + $G) < $average_coverage_ext/$r))
                {
                    $best_extension = $best_extension."C";
                    $allele_percentage{$l} = $A."+".$C."+".$T."+".$G;
                    $highest_all_freq = ($A+$T+$G)/($A+$C+$T+$G);
                }
                elsif ($T > ($A + $C + $G)*$c && (($C <= $hp && $A <= $hp && $G <= $hp) || ($A < 2 && $C < 2 && $G < 2)) && (($T > $s && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q) || ($T > $z && $l < $v && ($C + $A + $G) eq 0)) && ($dup ne "yes" || ($C + $A + $G) < $average_coverage_ext/$r))
                {
                    $best_extension = $best_extension."T";
                    $allele_percentage{$l} = $A."+".$C."+".$T."+".$G;
                    $highest_all_freq = ($A+$C+$G)/($A+$C+$T+$G);
                }
                elsif ($G > ($C + $T + $A)*$c && (($C <= $hp && $T <= $hp && $A <= $hp) || ($C < 2 && $T < 2 && $A < 2)) && (($G > $s && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q) || ($G > $z && $l < $v && ($C + $T + $A) eq 0)) && ($dup ne "yes" || ($C + $T + $A) < $average_coverage_ext/$r))
                {
                    $best_extension = $best_extension."G";
                    $allele_percentage{$l} = $A."+".$C."+".$T."+".$G;
                    $highest_all_freq = ($A+$C+$T)/($A+$C+$T+$G);
                }
                elsif ((($heteroplasmy ne "" && (($l < 10 && $SNP eq '0') || ($l < $pos_SNP+10 && $SNP eq '1') || ($l < $pos_SNP2+10 && $SNP eq '2') || ($l < $pos_SNP3+10 && $SNP eq '3'))) || $SNP_active eq "yes" ||
                       ($extensions_before eq "yes" && $ext_before ne "yes")) && $SNP < 4 && ($A+$T+$G+$C) > 3 && (($l < 15 && $split eq "") || ($l < 11 && $split ne "")) && (($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q || ($SNR_read ne "" && $l < 12))) 
                {
                    if ($hp_seed_assemble ne "" && $no_hp_one_turn2 eq "" && $split eq "" && $SNR_read eq "")
                    {
                        my %A_hp;
                        my %C_hp;
                        my %T_hp;
                        my %G_hp;
                        undef %A_hp;
                        undef %C_hp;
                        undef %T_hp;
                        undef %G_hp;
                        foreach my $pos_hp (sort {$a <=> $b} keys %hp_SNP_links)
                        {
                            my $A_hp = '0';
                            my $C_hp = '0';
                            my $T_hp = '0';
                            my $G_hp = '0';
                            my %all_ids_tmp;
                            undef %all_ids_tmp;
                            my $list = substr $hp_SNP_links{$pos_hp},1;
                            my @list_id = split /,/, $list;
                            my %list_id;
                            undef %list_id;
                            foreach my $id_hp (@list_id)
                            {
                                $list_id{$id_hp} = undef;
                            }
                            foreach my $id_hp (keys %list_id)
                            {
                                if (exists($extensionsb{$id_hp}))
                                {
                                    my $first_nuc = substr $extensionsb{$id_hp}, $l, 1;
                                    if ($first_nuc eq "A")
                                    {
                                        $A_hp++;     
                                    }
                                    if ($first_nuc eq "C")
                                    {
                                        $C_hp++;     
                                    }
                                    if ($first_nuc eq "T")
                                    {
                                        $T_hp++;     
                                    }
                                    if ($first_nuc eq "G")
                                    {
                                        $G_hp++;     
                                    }
                                    $all_ids_tmp{$id_hp} = undef;
                                }     
                            }
                            if (($A_hp+$C_hp+$T_hp) eq '0' && $G_hp > 2)
                            {
                                foreach my $id_tmp (keys %all_ids_tmp)
                                {
                                    $G_hp{$id_tmp} = undef;
                                }
                            }
                            if (($A_hp+$C_hp+$G_hp) eq '0' && $T_hp > 2)
                            {
                                foreach my $id_tmp (keys %all_ids_tmp)
                                {
                                    $T_hp{$id_tmp} = undef;
                                }
                            }
                            if (($A_hp+$G_hp+$T_hp) eq '0' && $C_hp > 2)
                            {
                                foreach my $id_tmp (keys %all_ids_tmp)
                                {
                                    $C_hp{$id_tmp} = undef;
                                }
                            }
                            if (($G_hp+$C_hp+$T_hp) eq '0' && $A_hp > 2)
                            {
                                foreach my $id_tmp (keys %all_ids_tmp)
                                {
                                    $A_hp{$id_tmp} = undef;
                                }
                            }
                            if ($A_hp > 0 || $C_hp > 0 || $T_hp > 0 || $G_hp > 0)
                            {
                                $count_hp_SNPS++;
                            }
                            
                            if ($pos_hp eq $SNP_to_assemble && $SNP_to_assemble_check eq "")
                            {
                                $SNP_to_assemble{"A"} = $A_hp;
                                $SNP_to_assemble{"C"} = $C_hp;
                                $SNP_to_assemble{"T"} = $T_hp;
                                $SNP_to_assemble{"G"} = $G_hp;
                                $SNP_to_assemble_check = "yes";
                            }
                        }
                        my @A_hp = keys %A_hp;
                        my @C_hp = keys %C_hp;
                        my @T_hp = keys %T_hp;
                        my @G_hp = keys %G_hp;
                        my $hp_correct = "";
                        if ((@C_hp+@T_hp+@G_hp) eq '0' && (@A_hp > 0.2*($A+$C+$T+$G) || (@A_hp > 0.15*$A && ($C+$T+$G) > 2*$A) || (@A_hp > 5 && @A_hp > 0.2*$A && $A/($C+$T+$G) > 0.5 && $A/($C+$T+$G) < 1.9)))
                        {
                            $best_extension = $best_extension."A";
                            $hp_correct = @A_hp;
                        }
                        elsif ((@A_hp+@T_hp+@G_hp) eq '0' && (@C_hp > 0.2*($A+$C+$T+$G) || (@C_hp > 0.15*$C && ($A+$T+$G) > 2*$C) || (@C_hp > 5 && @C_hp > 0.2*$C && $C/($A+$T+$G) > 0.5 && $C/($A+$T+$G) < 1.9)))
                        {
                            $best_extension = $best_extension."C";
                            $hp_correct = @C_hp;
                        }
                        elsif ((@C_hp+@A_hp+@G_hp) eq '0' && (@T_hp > 0.2*($A+$C+$T+$G) || (@T_hp > 0.15*$T && ($C+$A+$G) > 2*$T) || (@T_hp > 5 && @T_hp > 0.2*$T && $T/($C+$A+$G) > 0.5 && $T/($C+$A+$G) < 1.9)))
                        {
                            $best_extension = $best_extension."T";
                            $hp_correct = @T_hp;
                        }
                        elsif ((@C_hp+@T_hp+@A_hp) eq '0' && (@G_hp > 0.2*($A+$C+$T+$G) || (@G_hp > 0.15*$G && ($C+$T+$A) > 2*$G) || (@G_hp > 5 && @G_hp > 0.2*$G && $G/($C+$T+$A) > 0.5 && $G/($C+$T+$A) < 1.9)))
                        {
                            $best_extension = $best_extension."G";
                            $hp_correct = @G_hp;
                        }
                        if ($hp_correct ne "")
                        {
                            $allele_percentage{$l} = $A."+".$C."+".$T."+".$G;
                            print OUTPUT5 $l." HP_CORRECT\n";
                            $l++;
                            next NUCLEO;
                        }
                    }
                    if ($heteroplasmy ne "" && $SNP > 0)
                    {
                    }                    
                    delete $SNP_active{$id};
                    if ($SNP eq '0')
                    {
                        $A_SNP = $A;
                        $C_SNP = $C;
                        $T_SNP = $T;
                        $G_SNP = $G;
                        $pos_SNP = $l;
print OUTPUT5 $A_SNP." A ".$C_SNP." C ".$T_SNP." T ".$G_SNP." G INPUT\n";
                    }
                    if ($SNP eq '1')
                    {
                        $pos_SNP2 = $l;
                    }
                    if ($SNP eq '2')
                    {
                        $pos_SNP3 = $l;
                    }
                    if ($SNP eq '3')
                    {
                        $pos_SNP4 = $l;
                    }
                          
                    my @IUPAC = IUPAC($A,$C,$T,$G,$hp);
                    if ($IUPAC[0] eq "A" || $IUPAC[0] eq "C" || $IUPAC[0] eq "T" || $IUPAC[0] eq "G")
                    {
                    }
                    else
                    {
                        $SNP++;
                    }
                    $allele_percentage{$l} = $A."+".$C."+".$T."+".$G;
                    $best_extension = $best_extension.$IUPAC[0]; 
                }
                elsif ((($heteroplasmy ne "" && $l < $pos_SNP4+10) || $heteroplasmy eq "") && $SNP eq "4" && ($pos_SNP ne 0 || ($pos_SNP4 > $pos_SNP+12) || ($extensions_before eq "yes" && $l > 12)))
                {
                    $SNP = "yes5";
                    my $g = $l;
                    my $pos_SNP_tmp = $pos_SNP;
                    if ($pos_SNP4 > $pos_SNP+12)
                    {
                        $pos_SNP_tmp = $pos_SNP4;
                    }
                    if ($pos_SNP2 > $pos_SNP+5)
                    {
                        $pos_SNP_tmp = $pos_SNP2;
                    }
                    if ($extensions_before ne "yes" && $pos_SNP ne 0 && $SNR_read2 eq "")
                    {
                        while ($g > $pos_SNP_tmp)
                        {                                         
                            chop($best_extension);
                            $g--;
                        }
                    }
                    last  NUCLEO;
                }
                
                elsif ((($SNP eq "4" && $pos_SNP eq 0 && $l <= 15) || ($l eq 0 && $ext > 4)) && ($A + $T + $G + $C) > 4 && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q)
                {
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $best_extension." L\n";
                    }
                    if ($SNR_read ne "" && $no_SNR ne "yes")
                    {
                        $l = '0';
                        $best_extension = "";
                        $no_SNR = "yes";
                        %extensionsb = %extensionsb_backup;
                        
                        goto SPLIT;
                    }
                    if ($SNP eq "0")
                    {
                        $A_SNP = $A;
                        $C_SNP = $C;
                        $T_SNP = $T;
                        $G_SNP = $G;
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 $best_extension." BEST_EXTENSIONll\n";
                            print OUTPUT5 $A_SNP." A\n";
                            print OUTPUT5 $C_SNP." C\n";
                            print OUTPUT5 $T_SNP." T\n";
                            print OUTPUT5 $G_SNP." G\n";
                        }
                    }
                    print OUTPUT5 $A_SNP." A ".$C_SNP." C ".$T_SNP." T ".$G_SNP." G \n";
                    if ($heteroplasmy ne "" && $hp_seed_assemble eq "")
                    {
                        $hp_indel_ratio{"A"} = $A_SNP;
                        $hp_indel_ratio{"C"} = $C_SNP;
                        $hp_indel_ratio{"T"} = $T_SNP;
                        $hp_indel_ratio{"G"} = $G_SNP;
                    }
                    $best_extension = "";
                    $split = "yes";
                    $split_forward_tmp = "yes";
                    undef @firstSNP_max;
                    my $w = 0.035;
                    my $u = 0;
                    if ($type eq "mito_plant")
                    {
                        $w = 0.015;
                    }
                    if ($type eq "mito_plant" && $ext > $average_coverage_ext*5 && $extensions_before eq "yes")
                    {
                        $w = 0.005;
                    }
                    if ($type eq "mito_plant" && $ext > $average_coverage_ext*5 && $extensions_before eq "yes")
                    {
                        $w = 0.005;
                    }
                    if ($average_coverage_ext > 15 && $extensions_before ne "yes")
                    {
                        $u = 1;
                    }

                    if ($A_SNP >= ($C_SNP+$A_SNP+$T_SNP+$G_SNP)*$w && $A_SNP > $u)
                    {
                        if (exists($yuyu_option{$id."A"}))
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "YUYU_A_EXISTS\n";
                            }
                        }
                        else
                        {
                            push @firstSNP_max, "A";
                        }  
                    }
                    if ($C_SNP >= ($C_SNP+$A_SNP+$T_SNP+$G_SNP)*$w && $C_SNP > $u)
                    {
                        if (exists($yuyu_option{$id."C"}))
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "YUYU_C_EXISTS\n";
                            }
                        }
                        else
                        {
                            push @firstSNP_max, "C";
                        }  
                    }
                    if ($T_SNP >= ($C_SNP+$A_SNP+$T_SNP+$G_SNP)*$w && $T_SNP > $u)
                    {
                        if (exists($yuyu_option{$id."T"}))
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "YUYU_T_EXISTS\n";
                            }
                        }
                        else
                        {
                            push @firstSNP_max, "T";
                        }  
                    }
                    if ($G_SNP >= ($C_SNP+$A_SNP+$T_SNP+$G_SNP)*$w && $G_SNP > $u)
                    {
                        if (exists($yuyu_option{$id."G"}))
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "YUYU_G_EXISTS\n";
                            }
                        }
                        else
                        {
                            push @firstSNP_max, "G";
                        }  
                    }
                    
                    $count_split = @firstSNP_max;
                    my $count_split_tmp = '0';
                    
                    if ($count_split eq '2')
                    {
                        $delete_third = "yes";
                        $delete_second = "yes";
                    }
                    if ($count_split eq '3')
                    {
                        $delete_third = "yes";
                    }
                    if ($count_split eq '1')
                    {
                        $delete_third = "yes";
                        $delete_first = "yes";
                        $delete_second = "yes";
                        $split = "yes4";
                    }
                    
                    foreach my $firstSNP_max (@firstSNP_max)
                    {                                            
                        foreach my $extensions_id (keys %extensionsb)
                        {                       
                            my $extensions_tmp = $extensionsb{$extensions_id};
                            my $first_nuc = substr $extensions_tmp, 0, 1;
                            if ($first_nuc eq $firstSNP_max && $count_split_tmp eq '0')
                            {
                                $extensionsb_group1{$extensions_id} = $extensions_tmp;
                            }
                            elsif ($first_nuc eq $firstSNP_max && $count_split_tmp eq '1')
                            {
                                $extensionsb_group2{$extensions_id} = $extensions_tmp;
                            }
                            elsif ($first_nuc eq $firstSNP_max && $count_split_tmp eq '2')
                            {
                                $extensionsb_group3{$extensions_id} = $extensions_tmp;
                            }
                            elsif ($first_nuc eq $firstSNP_max && $count_split_tmp eq '3')
                            {
                                $extensionsb_group4{$extensions_id} = $extensions_tmp;
                            }
                        }
                        $count_split_tmp++;
                    }
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $count_split." COUNT_SPLIT\n";
                    }
                    goto SPLIT;
                }
                else
                { 
                    last  NUCLEO;
                }
                $l++;
            }
            
            if ($SNR_read eq "yes2" && $SNR_read_ahead ne "" && $SNR_go_last_chance eq "" && $split eq "" && ($count_split eq "" || $count_split eq '1') )
            {
                $last_chance = "yes";
                $SNR_go_last_chance = $position;
                goto SEED2;
            }
                
            if ($get_more_matches ne "no" && $split eq "" &&  $ext_total*$heteroplasmy < 1.1 && $ext_total < $mmr && $repetitive_detect eq "" && $heteroplasmy ne "" && $hp_seed_assemble eq "" && ($last_chance eq "" || ($no_quality eq "" && $ext_total < 20)))
            {
                if ($last_chance eq "" )
                {
                    $last_chance = "yes";
                }
                if ($use_quality ne "" && $ext_total < 20 && $last_chance eq "yes")
                {
                    $no_quality = "yes";
                }
                $get_more_matches = "yes";
                print OUTPUT5 $last_chance." LC ".$use_regex." UR ".$get_more_matches." GMM\n";
                goto NO_AT;
            }
            if ($ext_total*$heteroplasmy > 100000000000 && $get_more_matches eq "yes")
            {
                $last_chance = "";
                $get_more_matches = "no";
                goto NO_AT;
            }
            my $last_nucleo = substr $best_extension, -1;
            $last_nucleo =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            while ($last_nucleo eq '.')
            {
                chop($best_extension);
                $last_nucleo = substr $best_extension, -1;
                $last_nucleo =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            }

            if ($best_extension eq "" && $removed_N_reads ne "" && $removed_N_reads ne "yes1")
            {
                $removed_N_reads = "yes1";
                $SNP_active = "yes";
                %extensionsb = %extensionsb_original;
                print OUTPUT5 $percentage_N." SNP_ACTIVE\n";
                goto REMOVE_N;
            }
            if ($best_extension eq "" && $use_quality eq "yes" && $SNR_critical ne "yes" && $ext_total > 4)
            {
                my $N_total = '0';
                my $Total = '1';
                foreach my $extensions_id (keys %extensionsb_original)
                {                                 
                    my $extensions = $extensionsb_original{$extensions_id};
                    my $N = $extensions =~ tr/N1234/N1234/;
                    $N_total += $N;
                    $Total += length($extensions);
                }
                print OUTPUT5 $N_total/$Total." BEST_EXTENSION_N2\n";
                if ($N_total/$Total > 0.35 && $split ne "" && $removed_N_reads ne "yes1")
                {
                    $removed_N_reads = "yes1";
                    $split = "";
                    $split_forward_tmp = "";
                    $SNR_read = "yes";
                    %extensionsb = %extensionsb_original;
                    $SNR_critical_pos{$id} = $position;
                    goto REMOVE_N;
                }
                elsif ($N_total/$Total > 0.35 && $split ne "" && $SNP_active eq "")
                {
                    $SNP_active = "yes";
                    $split = "";
                    $split_forward_tmp = "";
                    $removed_N_reads = "yes1";
                    %extensionsb = %extensionsb_original;
                    $SNR_critical_pos{$id} = $position;
                    goto REMOVE_N;
                }
                if ($N_total/$Total > 0.35)
                {
                    $SNR_critical = "yes1";
                    $SNR_critical{$id} = "yes";
                    $SNP_active{$id} = "yes";
                    $SNR_critical_pos{$id} = $position;
                    $best_extension = "";
                    $split = "";
                    $split_forward_tmp = "";
                }
            }
            if ($split ne "" && $use_quality eq "yes" && $SNR_critical ne "yes" && $ext_total > 4)
            {
                my $N_total = '0';
                my $Total = '1';
                foreach my $extensions_id (%extensionsb_original)
                {                                 
                    my $extensions = $extensionsb_original{$extensions_id};
                    my $N = $extensions =~ tr/N1234/N1234/;
                    $N_total += $N;
                    $Total += length($extensions);
                }
                print OUTPUT5 $N_total/$Total." N_SPLT_SNR\n";
                my $SNR_end0bt = $read_end;
                my $SNR_check = $SNR_end0bt =~ s/AAAA|CCCC|GGGG|TTTT|TATATA//;
                if ($N_total/$Total > 0.25 && $split ne "" && $SNR_check > 0)
                {
                    $SNR_read{$id} = "yes";
                }
            }
            if ($SNR_critical ne "" && $split eq "")
            {
                $best_extension = substr $best_extension, 0, 5;
            }
            if($split eq "" && $SNP ne "0" && $extensions_before ne "" && $pos_SNP eq '0')
            {
                my $ext_tmp = $best_extension;
                my $count_N = $ext_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                if ($count_N > length($best_extension)/2)
                {
                    $best_extension = "";
                }
            }
            if ($SNP eq "4" && $split eq "" && length($best_extension) < 15 && $pos_SNP ne '0')
            {
                $SNP = "yes5";
                my $g = $l;
                my $pos_SNP_tmp = $pos_SNP;
                    
                while ($g > $pos_SNP_tmp)
                {                                         
                    chop($best_extension);
                    $g--;
                }
                if ($y > $startprint2)
                {
                    print OUTPUT5 $best_extension." BEST_EXTENSION_chopped\n";
                }
            }
            
            if ($split eq "yes2" || ($split eq "yes3" && $count_split > 2) || ($split eq "yes4" && $count_split > 3))
            {               
                if ($split eq "yes2")
                {
                    $best_extension2 = $best_extension;
                    $best_extension2_count = keys %extensionsb_group2;
                }
                elsif ($split eq "yes3")
                {
                    $best_extension3 = $best_extension;
                }
                elsif ($split eq "yes4")
                {
                    $best_extension4 = $best_extension;
                }
                my $best_extension_tmp = $best_extension;
                $best_extension_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

                my $contig_id2_prev = $id;
                
                if ($split eq "yes2")
                {
                    $contig_id2 = "2".length($read);
                    $contig_id2{$contig_id2_prev} = $contig_id2;
                    $contig_id2_prev = $contig_id2;
                    $contig_read2 = substr $read, -$read_length;
                    $contig_read2 = $contig_read2.$best_extension_tmp;
                }
                elsif ($split eq "yes3")
                {
                    $contig_id3 = "3".length($read);
                    $contig_id3{$contig_id2_prev} = $contig_id3;
                    $contig_id2_prev = $contig_id3;
                    $contig_read3 = substr $read_short_end2, -$read_length;
                    $contig_read3 = $contig_read3.$best_extension_tmp;
                }
                elsif ($split eq "yes4")
                {
                    $contig_id4 = "4".length($read);
                    $contig_id4{$contig_id2_prev} = $contig_id4;
                    $contig_id2_prev = $contig_id4;
                    $contig_read4 = substr $read_short_end2, -$read_length;
                    $contig_read4 = $contig_read4.$best_extension_tmp;
                }                
                
                if ($y > $startprint2)
                {
                    if ($split eq "yes2")
                    {
                        print OUTPUT5 "GROUP2\n";
                        if ($extensions_before ne "yes")
                        {
                            %extensionsb_group2_old = %extensionsb_group2;
                        }
                        if (keys %extensionsb_group2 < 150)
                        {
                            foreach my $extensions_tmp (keys %extensionsb_group2)
                            {  
                                print OUTPUT5 $extensionsb_group2{$extensions_tmp}."\n";                        
                            }
                        }
                        print OUTPUT5 $best_extension_tmp." BEST_EXTENSION2\n\n";
                    }
                    elsif ($split eq "yes3")
                    {
                        print OUTPUT5 "GROUP3\n";
                        if ($extensions_before ne "yes")
                        {
                            %extensionsb_group3_old = %extensionsb_group3;
                        }
                        if (keys %extensionsb_group3 < 150)
                        {
                            foreach my $extensions_tmp (keys %extensionsb_group3)
                            {  
                                print OUTPUT5 $extensionsb_group3{$extensions_tmp}."\n";                        
                            }
                        }
                        print OUTPUT5 $best_extension_tmp." BEST_EXTENSION3\n\n";
                    }
                    elsif ($split eq "yes4")
                    {
                        print OUTPUT5 "GROUP4\n";
                        if ($extensions_before ne "yes")
                        {
                            %extensionsb_group4_old = %extensionsb_group4;
                        }
                        if (keys %extensionsb_group4 < 150)
                        {
                            foreach my $extensions_tmp (keys %extensionsb_group4)
                            {  
                                print OUTPUT5 $extensionsb_group4{$extensions_tmp}."\n";                        
                            }
                        }
                        print OUTPUT5 $best_extension_tmp." BEST_EXTENSION4\n\n";
                    }    
                }
                if ($before eq "yes")
                {

                    my $contigs_end2 = substr $best_extension2, 0, 7;
                    $contigs_end2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                    my $contigs_end0 = substr $read_end, -5;
    
                    if (exists($contigs_end{$contigs_end0.$contigs_end2}))
                    {
                        my $id_tmp = $id;
                        if ($id =~ m/.*_(\d+)$/)
                        {
                            $id_tmp = $1;
                        }
                        $tree{$id_tmp} = $contigs_end{$contigs_end0.$contigs_end2};
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nDELETE BEST EXTENSION 2 (CONTIG_END)\n\n";
                        }
                        if ($split eq "yes2")
                        {
                            $delete_first = "yes";
                            $best_extension2 = "";
                            if ($count_split eq '2')
                            {
                                $split = "yes4";
                            }
                        }
                        if ($split eq "yes3")
                        {
                            $delete_second = "yes";
                            $best_extension3 = "";
                            if ($count_split eq '3')
                            {
                                $split = "yes4";
                            }
                        }
                        if ($split eq "yes4")
                        {
                            $best_extension4 = "";
                            $delete_third = "yes";
                        }
                        goto SPLIT;  
                    }
                }
                if ($split eq "yes2")
                {                      
                    if ($count_split eq '2')
                    {
                        $split = "yes4";
                    }
                    goto SPLIT;
                }
                elsif ($split eq "yes3")
                {                      
                    if ($count_split eq '3')
                    {
                        $split = "yes4";
                    }                                               
                    goto SPLIT;
                }
                if ($split eq "yes4")
                {                      
                    goto SPLIT;
                }             
            }
            elsif ($split eq "yes5" || (($variance_detection eq "yes" || $heteroplasmy ne "") && $best_extension ne "" && $last_150 eq "" && $hp_back eq "") || $reference_next_seed eq "yes")
            {
                if ($split eq "" && $hp_back eq "" && ($variance_detection eq "yes" || $reference_next_seed eq "yes" || $heteroplasmy ne ""))
                {
                    goto DEL;
                }
                $best_extension1 = $best_extension;
                $best_extension1_count = keys %extensionsb_group1;
                
                
                my $contig_id1_prev = $id;
                my $best_extension1_tmp = $best_extension1;
                $best_extension1_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

                $contig_id1 = "1".length($read);
                $contig_id1{$contig_id1_prev} = $contig_id1;
                $contig_id1_prev = $contig_id1;
                $contig_read1 = substr $read, -$insert_size;
                $contig_read1 = $contig_read1.$best_extension1_tmp;

                $contig_id1 = $contig_id1{$id};
                
                if ($y > $startprint2)
                {
                    print OUTPUT5 "GROUP1\n";
                    if ($extensions_before ne "yes")
                    {
                       %extensionsb_group1_old = %extensionsb_group1;
                    }
                    if (keys %extensionsb_group1 < 150)
                    {
                        foreach my $extensions_tmp (keys %extensionsb_group1)
                        {  
                            print OUTPUT5 $extensionsb_group1{$extensions_tmp}."\n";
                        }
                    }
                    print OUTPUT5 $best_extension1." BEST_EXTENSION1\n\n";
                }
                my $contigs_end0;
DEL:    
                my $best_p_from_del = "";
                if ($before eq "yes" || ($heteroplasmy ne "" && $hp_seed_assemble eq ""))
                {
                    my $contigs_end1 = substr $best_extension1, 0, 7;
                    $contigs_end1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                    my $contigs_end0 = substr $read_end, -5;
    
                    if (exists($contigs_end{$contigs_end0.$contigs_end1}))
                    {
                        $tree{$id} = $contigs_end{$contigs_end0.$contigs_end1};
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nDELETE BEST EXTENSION 1 (CONTIG_END)\n\n";
                        }
                        $split = "";
                        $split_forward_tmp = "";
                        if ($best_extension2 eq "" && $best_extension3 eq "" && $best_extension4 eq "")
                        {
                            $contig_end = "yes";
                            $best_extension1 = "";
                            goto AFTER_EXT;
                        }
                        else
                        {
                            $best_extension1 = "";
                            goto AFTER_EXT;
                        }
                    }
                    my $read_part_tmp = substr $read_short_end2, -$read_length;
                    my $star_check = $read_part_tmp =~ tr/\*/\*/;          
                    
                    if ($SNP_active eq "yes" && $count_split eq '2' && ($star_check eq 0 || $star_check eq "" || $platform eq "ion") && $hp_seed_assemble eq "")
                    {
                        my @check_deletion = check_deletion($best_extension1, $best_extension2, $best_extension_old1, $best_extension_old2, "", "");
                        $best_extension = $check_deletion[0];
                        if ($best_extension ne "")
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $best_extension." BEST_EXTENSION_DEL\n";
                            }
                            $deletion = "yes";
                            $split = "";
                            $best_p_from_del = $check_deletion[3];
                            
                            if ($heteroplasmy eq "" && $variance_detection eq "")
                            {
                                goto INDEL;
                            }
                            else
                            {
                                my $star_check = $best_extension =~ tr/\*/\*/;
                                $SNPs_indel{$position} = $star_check;
                            }
                        } 
                    }
                }
REFERENCE:

                if ($NUMT ne "yes2" && $hp_back eq "" && $last_150 eq "" && $reference ne "" && ($split eq "" || $before ne "" || ($heteroplasmy ne "" && $hp_seed_assemble eq "")) &&
                ($reference_next_seed eq "yes" || ((((length($best_extension1) > 4 && length($best_extension2) > 4) || (length($best_extension_old1) > 4 && length($best_extension_old2) > 4))
                 && $SNP_active eq "yes" && $repetitive_detect eq "" && $deletion eq "") || (($variance_detection eq "yes" || $heteroplasmy ne "") && $best_extension ne "" && $repetitive_detect2 eq ""))))
                {
                    my $deletion_length0_tmp_save = "";
                    my $extra_seq_save = "";
                    my $p = -30;
                    my $p_prev = 100;
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "CHECK_REFERENCE\n\n";
                    }
                    my $ref_part_prev = "";
                    my $found_further_back = "";
                    my %ref_id3;
                    my @ref_id3;
                    undef %ref_id3;
                    undef @ref_id3;
                    my $further = "";
                    my $first_last_seq_ref = "";
                    my $last_seq_ref = "";
                    my $check_back_length = '800';
                    
                    if (exists($large_variance_forward{$id}))
                    {
                        $large_variance_tmp = "yes";
                    }
                                    
CHECK_REF:          while ($p > -$check_back_length && $p > -length($read))
                    {
                        if ($found_further_back ne "yes")
                        {
                            undef @ref_id3;
                            undef %ref_id3;
                        }
                        my $read_short_end2_tmp = substr $read, -$check_back_length-200;
                        
                        if (exists($last_ref_seq_forward{$id}) && $first_last_seq_ref ne "yes" && $first_without_LV eq "")
                        {
                            print OUTPUT5 $last_ref_seq_forward{$id}." LAST_REF_SEQ\n";
                            print OUTPUT5 $last_ref_pos_forward{$id}." LAST_REF_POS\n";
                            $read_short_end2_tmp = $last_ref_seq_forward{$id};
                            if (length($read_short_end2_tmp)+$p < 0)
                            {
                                $first_last_seq_ref = "yes";
                                $read_short_end2_tmp = $read_short_end2;
                            }
                        }
                        my $ref_part2 = substr $read_short_end2_tmp, $p, 30;
                        my $star2;
                        if ($containX_short_end2 > 0)
                        {
                            my $star = $ref_part2 =~ tr/\*/\*/;

                            $ref_part2 = substr $read_short_end2_tmp, -(-$p+($star*2)), 30+($star*2);
                            $star2 = $ref_part2 =~ tr/\*/\*/;                                                
                            while ($star2 > $star)
                            {
                                $ref_part2 = substr $read_short_end2_tmp, -(-$p+($star*2)+(($star2-$star)*2)), 30+($star*2)+(($star2-$star)*2);
                                $star = $star2;
                                $star2 = $ref_part2 =~ tr/\*/\*/;
                            }   
                        }
                        my %ref_part;
                        if ($last_ref_seq_back{$id} eq "")
                        {
                            my $ref_part2_tmp = $ref_part2;
                            my $count_dots = $ref_part2_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
                            if ($count_dots < 6)
                            {
                               %ref_part = build_partial3b $ref_part2_tmp, "";   
                            }     
                        }
                        $ref_part{$ref_part2} = undef;                     
                        
                        if ($found_further_back eq "yes")
                        {
                            $p++;
                        }
                        my $ref_loc = -$p;
                        
                        my $check_dots = $ref_part2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        my $check_AT_rich = AT_rich_test ($ref_part2, '6');
                        if (($reference_next_seed ne "" && $check_dots > 0) || $check_AT_rich eq "yes")
                        {
                            print OUTPUT5 $reference_next_seed." REF_NEXT " .$check_dots." DOT ".$check_AT_rich." AT\n";
                            undef %ref_part;
                        }
                        if ($found_further_back eq "")
                        {
                            foreach my $ref_part_tmp (keys %ref_part)
                            {
                                if (exists($hashref{$ref_part_tmp}))
                                {                             
                                    my $ref_id3 = $hashref{$ref_part_tmp};      
                                    my $ref_id2 = substr $ref_id3, 1;
                                    my @ref_id3_tmp2;
                                    undef @ref_id3_tmp2;

                                    my @ref_id3_tmp = split /,/, $ref_id2;
                                    
                                    foreach (@ref_id3_tmp)
                                    {
                                        if (($_ < $last_ref_pos_forward{$id}+5000 && $_ > $last_ref_pos_forward{$id}-5000 && ($_+$ref_loc >= $last_ref_pos_forward{$id} || $heteroplasmy eq "")) || $last_ref_pos_forward{$id} eq "")
                                        {  
                                            if ($_ > $large_variance_forward{$id} || $first_without_LV eq "")
                                            {
                                                $ref_id3{$_} = $ref_part_tmp;
                                                push @ref_id3_tmp2, $_;
                                            }
                                        }
                                        else
                                        {
                                            
                                        }
                                    }
                                    push @ref_id3, @ref_id3_tmp2; 
                                }
                            }
                        }
                        if (@ref_id3 > 1 && exists($last_ref_pos_forward{$id}))
                        {
                            my @ref_id3_tmpie;
                            undef @ref_id3_tmpie;
                            foreach my $ref_id (@ref_id3)
                            {
                                if ($ref_id+$ref_loc eq $last_ref_pos_forward{$id})
                                {
                                    push @ref_id3_tmpie, $ref_id;
                                }
                            }
                            if (@ref_id3_tmpie eq 1)
                            {
                                undef @ref_id3;
                                foreach my $tmp (@ref_id3_tmpie)
                                {
                                    push @ref_id3, $tmp;
                                }
                            }
                        }
                        if (@ref_id3 eq 1)
                        {
                            foreach my $ref_id (@ref_id3)
                            {
                                my $prev_loc1 = $ref_id + $ref_loc;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $ref_loc." LOC ".$ref_id." REF_ID ".$prev_loc1." PREV_LOC\n";
                                }
                                if ($y eq '1' && $hp_seed_assemble eq "")
                                {
                                    my $read_tmp = substr $read, 0, -$ref_loc+30;
                                    print OUTPUT5 $read_tmp." READ_TMP\n";
                                    if (length($read_tmp) > $overlap+10)
                                    {
                                        $read = $read_tmp;
                                        delete $seed{$id};
                                        $seed{$id} = $read;
                                        $y++;
                                        goto ITERATION;
                                    }
                                }
                                if ($reference_next_seed eq "yes")
                                {
                                    my $next_seed_loc = $ref_id + $ref_loc - $p + 100;
                                    if (exists($hashref2{$next_seed_loc}))
                                    {
                                        $next_seed_ref = $hashref2{$next_seed_loc}.$hashref2{$next_seed_loc+30}.$hashref2{$next_seed_loc+60}.$hashref2{$next_seed_loc+90}.$hashref2{$next_seed_loc+120}.$hashref2{$next_seed_loc+150}.$hashref2{$next_seed_loc+180}.$hashref2{$next_seed_loc+210}.$hashref2{$next_seed_loc+240}.$hashref2{$next_seed_loc+270};
                                        $SNR_next_seed = "yes";
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $next_seed_ref." NEXT_SEED_REF\n";
                                        }
                                        goto FINISH;
                                    }
                                }
                                $last_ref_pos_forward{$id} = $prev_loc1;
                           
                                my @delete;
                                undef @delete;
                                if ($first_last_seq_ref ne "yes")
                                {
                                }
                                else
                                {
                                    foreach my $var_pos_tmp (keys %variance_forward)
                                    {
                                        my @split = split /\*/, $var_pos_tmp;
                                         print OUTPUT5 $var_pos_tmp." VAR_POS_TMP\n";
                                        my $var_pos = $split[1];
                                        if ($split[0] eq $id)
                                        {
                                            if ($var_pos > $ref_id && $var_pos < $ref_id+2000)
                                            {
                                                $prev_loc1 -= $variance_forward{$var_pos_tmp};
                                            }
                                            if ($ref_id + $ref_loc - $check_back_length > $var_pos)
                                            {
                                                push @delete, $var_pos_tmp;
                                            }
                                        }
                                    }
                                }
                                foreach my $delete (@delete)
                                {
                                    delete $variance_forward{$delete};
                                }
                              
                                $last_seq_ref = $hashref2{$prev_loc1-30};
                                print OUTPUT5 $prev_loc1." PREV_LOC1\n";
 print OUTPUT5 $last_seq_ref." LAST_SEQ_REF00\n";
                                my $prev_loc1_old = $prev_loc1;
                                if (exists($hashref2{$prev_loc1}))
                                {}
                                else
                                {
                                    my $m = '0';
                                    while (exists($hashref2{$prev_loc1-$ref_loc+$m}))
                                    {
                                        $m++;
                                    }
                                    $prev_loc1 = $ref_loc-$m;
                                }
                                if (exists($hashref2{$prev_loc1}))
                                {
                                    my $ref_check;
                                    my $j = '0';
                                    my $prev_loc1_tmp = $prev_loc1;
                                    
                                    my $ref_check_star;

                                    while ($j < 130)
                                    {
                                        if (exists($hashref2{$prev_loc1_tmp+$j}))
                                        {
                                            $ref_check .= $hashref2{$prev_loc1_tmp+$j};
                                            $ref_check_star .= $hashref2{$prev_loc1_tmp+$j};
                                        }
                                        elsif ($heteroplasmy ne "" && (length($ref_check) <= length($best_extension) || ($split ne "" && (length($ref_check) <= length($best_extension1) || length($ref_check) <= length($best_extension2)))))
                                        {
                                            my $best_extension_tmp = substr $best_extension, 0, length($ref_check);
                                            if ($split ne "")
                                            {
                                                $best_extension1 = substr $best_extension1, 0, length($ref_check);
                                                $best_extension2 = substr $best_extension2, 0, length($ref_check);
                                            }
                                            $best_extension = $best_extension_tmp;
                                            $last_150 = length($read);
                                            $no_next_seed = "yes";
                                            print OUTPUT5 "END_REF\n";
                                        }
                                        $j += 30;
                                    } 
                           
                                    if ($y > $startprint2)
                                    {
                                        print OUTPUT5 $ref_check." REF_CHECK ".$prev_loc1_tmp." PREV_LOC1\n";
                                    }
                                    if ($prev_loc1_tmp < 500 && $prev_loc1_old > 2000 && $y < 20)
                                    {
                                        delete $last_ref_seq_forward{$id};
                                        delete $last_ref_pos_forward{$id};
                                    }
                                    $ref_check_forward = $ref_check;

                                    
                                    my $best_extension_del = $best_extension;
                                    if (exists($large_variance_forward{$id}) && $first_without_LV eq "yes2")
                                    {
                                        $variance_forward{$id."*".$large_variance_forward{$id}} = $prev_loc1_tmp-$large_variance_forward{$id}-$large_variance_length_forward{$id};
                                        print OUTPUT5 $variance_forward{$id."*".$large_variance_forward{$id}}." LARGE_DELETION\n";
                                        delete $last_ref_seq_forward{$id};
                                        delete $last_ref_pos_forward{$id};
                                        delete $large_variance_forward{$id};
                                        delete $large_variance_length_forward{$id};
                                        $large_variance_tmp = "";
                                    }
                                    if ($hp_seed_assemble ne "" && $split ne "" && $SNP_active ne "" && $before ne "" && $NUMT eq "" && $NUMT_back eq "" && ($deletion eq "" || $split_hp_options ne "") && $hp_splits eq "")
                                    {
                                        $pos_of_last_hp_split_option = $position;
                                        if ($position_back eq '0' && length($read) < $insert_size*2)
                                        {
                                            $noforward{$id} = "stop";
                                            goto FINISH;
                                        }
                                        $best_extension = $best_extension1;
                                        $split = "";
                                        my $first_nuc1 = substr $best_extension1, 0, 1;
                                        my $first_nuc2 = substr $best_extension2, 0, 1;
                                        my $ref_nuc = substr $ref_check, 0, 1;
                                        my $best_extension_tmp = $best_extension2;
                                        if ($first_nuc1 eq $ref_nuc)
                                        {
                                            $best_extension_tmp = $best_extension1;
                                            $best_extension = $best_extension2;
                                        }
                                        hp_select_best_ext ($best_extension_tmp, \%SNPs, \%linked_SNPs, \%linked_half_SNPs, \%not_linked_SNPs, $position, $position_back);
                                        print OUTPUT5 $best_extension." ADD_EXTRA_SPLIT\n";
                                    }
                                    if (($variance_detection eq "yes" || $heteroplasmy ne "") && $split eq "" && $repetitive_detect eq "" && $NUMT ne "yes2")
                                    {
                                        my $prev_loc1_tmp_correction = '0';
                                        my $prev_loc1_tmp_2 = $prev_loc1_tmp;
                                        my $del_detect = '1';
                                        my %hold_SNPs;
                                        my %hold_linked;
                                        undef %hold_SNPs;
                                        undef %hold_linked;
                                        my $no_homoplasmy = "";
DEL_DETECT:                             if ($deletion eq "yes" && $del_detect eq '1')
                                        {
                                            my $best_extension1_tmp = $best_extension;
                                            $best_extension1_tmp =~ tr/\*//d;
                                            $best_extension = $best_extension1_tmp;    
                                        }
                                        elsif ($deletion eq "yes" && $del_detect eq '2')
                                        {
                                            my $best_extension2_tmp = $best_extension_del;
                                            $best_extension2_tmp =~ s/.\*//g;
                                            $best_extension = $best_extension2_tmp;
                                        }
                                        if ($best_extension1 =~ m/^$best_extension.*/ && $deletion eq "yes")
                                        {
                                            if ($best_extension1_count < $best_extension2_count)
                                            {
                                                $no_homoplasmy = "yes";
                                            }
                                        }
                                        if ($best_extension2 =~ m/^$best_extension.*/ && $deletion eq "yes")
                                        {
                                            if ($best_extension2_count < $best_extension1_count)
                                            {
                                                $no_homoplasmy = "yes";
                                            }
                                        }   
                                        if ($heteroplasmy ne "" && $y eq '1' && $hp_seed_assemble eq "" && $hp_back eq "")
                                        {
                                            my @first_SNPs = split //, $seed;
                                            my $t = '0';
                                            foreach my $first_SNPs (@first_SNPs)
                                            {
                                                if ($first_SNPs eq "." || $first_SNPs eq "N")
                                                {
                                                    my $pos = $prev_loc1_tmp-length($seed)+$t;
                                                    $variance_all_SNP{$pos} = undef;
                                                    $variance_all_SNP_seed{$pos} = undef;
                                                }
                                                $t++;
                                            }
                                        }
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $best_extension." BEST_EXTENSION_VAR\n\n";
                                        }
                                        my $best_extension_tmp = $best_extension;
                                        my %not_linked_tmp;
                                        undef %not_linked_tmp;
WITHOUT_LV:                                        
                                        my $ref_check_tmp = $ref_check;
                                        
                                        if (exists($large_variance_forward{$id}) && $first_without_LV eq "yes")
                                        {
                                            $ref_check_tmp = $hashref2{$large_variance_forward{$id}}.$hashref2{$large_variance_forward{$id}+30}.$hashref2{$large_variance_forward{$id}+60}.$hashref2{$large_variance_forward{$id}+90}.$hashref2{$large_variance_forward{$id}+120};
                                            print OUTPUT5 $ref_check_tmp." EXISTSREF1_VAR_DETECT\n\n";
                                        }
                                        
                                        my $write_last_SNP = "";
                                        my $deletion_found = "";
                                        my $deletion_correction = '0';
                                        my $max_SNP = 1;

                                        if ($no_large_variance_forward ne "")
                                        {
                                            if ($no_large_variance_forward <= $prev_loc1-75)
                                            {
                                                delete $no_large_variance_forward{$id};
                                            }
                                            else
                                            {
                                                $max_SNP = length($best_extension_tmp);
                                            }
                                        }
                                        my $loop_check = "";
VAR_START:                              
                                        my @line = split //, $best_extension_tmp;
                                        my @ref_check = split //, $ref_check_tmp;
                                        my $gh = '0';
                                        my $th = '0';
                                        $prev_loc1_tmp = $prev_loc1_tmp_2;
                                        
VAR_CHECK:                              while ($gh <= length($ref_check_tmp)-length($best_extension_tmp))
                                        {
                                            my $d = '0';
                                            my $next = '0';
                                            my @pos;
                                            undef @pos;
                                            my $pos = "";
                                            my $pos_first = "";
                                            my $pos_last = "";
                                            my $v = '4';
                                            my $AF = "";
                                            my $AF_save = "";
                                            my $AF_major = "";
                                            my $DP = "";
                                            my $FR = "";
                                            my $LCR = "";
                                            my $check_for_DEL = "";
                                            if ($SNR_read ne "")
                                            {
                                                if ($SNR_nucleo ne "")
                                                {
                                                    $LCR = "SNR(".$SNR_nucleo.")";
                                                }
                                                else
                                                {
                                                    $LCR = "SNR";
                                                }
                                                $v = '8';
                                            }
                                            if ($heteroplasmy ne "")
                                            {
                                                $FR = ";FR=R";
                                            }
                                            my $var_recorderd = '0';
                                            if (length($best_extension_tmp) > 15)
                                            {
                                                $v = '6';
                                            }
                                            $prev_loc1_tmp += $prev_loc1_tmp_correction;
                                            $prev_loc1_tmp_correction = '0';
                                            
NEXT_NUC_HP:                                while ($d < length($best_extension_tmp))
                                            {
                                                $th = $d + $gh;
                                                $hp_forward_data2{$prev_loc1+$th} = $allele_percentage{$th};
                                                if ($line[$d] eq $ref_check[$th] || $write_last_SNP eq "yes")
                                                {
                                                    if ($next ne '0' && $large_variance_tmp eq "" && (((($pos-$prev_loc1-$gh) < $d-$v) && $deletion eq "") || ($d eq length($best_extension_tmp)-1 )))
                                                    {
                                                        foreach my $pos_tmp (@pos)
                                                        {
                                                            if (exists $HP_exclude{$pos_tmp})
                                                            {
                                                            }
                                                            else
                                                            {
                                                                $var_recorderd++;
                                                                my $position_tmp;
                                                                my $nuc_other_than_ref = "";
                                                                my $nuc_other_than_ref_AF = "";
                                                                my $nuc_count_ref = "";
                                                                $pos_last = $pos_tmp-$prev_loc1+1;
                                                                if ($AF eq "")
                                                                {
                                                                    $position_tmp = $pos_first;                                                                    
                                                                }
                                                                else
                                                                {
                                                                    $position_tmp = $pos_tmp-$prev_loc1;
                                                                }
                                                                
                                                                my @nucs_count = split /\+/, $allele_percentage{$position_tmp};
                                                                my ($nucs_alt2, $nucs_alt_array) = IUPAC_reverse($line[$pos_tmp-$prev_loc1-$gh]);
                                                                
                                                                my @nucs_alt = @$nucs_alt_array;
                                                                my $nucs_alt = "";
                                                                my $nucs_alt_major = "";
                                                                my $no_variance = "";
                                                                my $deduct_duplications_first = '0';
                                                                my $deduct_low_quality_next_nuc_first = '0';
                                                                my $deduct_mismatch_nuc_first = '0';
    
                                                    print OUTPUT5 $allele_percentage{$position_tmp}." TESh2\n";
                                                                my $s = '0';
                                                                my @nucs_order = ('A','C','T','G');
                                                                my $AF_high = '0';
                                                                my %allele_ordered;
                                                                undef %allele_ordered;
                                                                my $AF_tmp2 = "";
                                                                my $nuc_other_than_ref_tmp = "";
                                                                if ($hp_seed_assemble ne "")
                                                                {
                                                                    my @variances_tmp = split /\t/, $variance_all{$pos_tmp};
                                                                    my $AF_tmp = $variances_tmp[7];
                                                                    print OUTPUT5 $AF_tmp." TESTOS\n";
                                                                    print OUTPUT5 $pos_tmp." TESTOS2\n";
                                                                    if ($AF_tmp =~ m/AF=(\d+\.\d+).*/)
                                                                    {
                                                                        $AF_tmp2 = $1;
                                                                        print OUTPUT5 $AF_tmp2." AF_TMP2a\n";
                                                                    }
                                                                    if ($AF_tmp2 > 0.5)
                                                                    {
                                                                        $nuc_other_than_ref_tmp = $variances_tmp[3];
                                                                    }
                                                                    elsif ($AF_tmp2 < 0.5 && $AF_tmp2 ne "")
                                                                    {
                                                                        $nuc_other_than_ref_tmp = $variances_tmp[4];
                                                                    }
                                                                }
                                                                my $pos_tmp2 = $pos_tmp+$deletion_correction;
                                                if ($deletion_correction > 0)
                                                {
                                                    print OUTPUT5 $pos_tmp." POS_TMP\n";
                                                    print OUTPUT5 $pos_tmp2." POS_TMP22222222\n";
                                                }
                                                                if (($nucs_count[0]+$nucs_count[1]+$nucs_count[2]+$nucs_count[3]) > 0)
                                                                {
                                                                    my $h = '0.001';
                                                                    foreach (@nucs_alt)
                                                                    {  
                                                                        my $nuc_tmp = $_-1;   
                                                                        my $AF_tmp = sprintf("%.3g",$nucs_count[$nuc_tmp]/($nucs_count[0]+$nucs_count[1]+$nucs_count[2]+$nucs_count[3]));
                                                            print OUTPUT5 $nucs_order[$nuc_tmp]." TESh3\n";
                                                                        if ($hp_seed_assemble ne "" && $nuc_other_than_ref_tmp ne "")
                                                                        {
                                                                            if ($nucs_order[$nuc_tmp] eq $nuc_other_than_ref_tmp && @nucs_alt < 3)
                                                                            {
                                                                                $nuc_other_than_ref = $nuc_other_than_ref_tmp;
                                                                                $nuc_other_than_ref_AF = $AF_tmp;  
                                                                            }
                                                                        }
                                                                        elsif ($nucs_order[$nuc_tmp] ne $ref_check[$pos_tmp-$prev_loc1] && @nucs_alt < 3)
                                                                        {
                                                                            $nuc_other_than_ref = $nucs_order[$nuc_tmp];
                                                                            $nuc_other_than_ref_AF = $AF_tmp;  
                                                                        }
                                                                        if ($nucs_order[$nuc_tmp] eq $ref_check[$pos_tmp-$prev_loc1] && @nucs_alt < 3 && $nuc_count_ref eq "")
                                                                        {
                                                                            $nuc_count_ref = $nucs_count[$nuc_tmp];
                                                                        }
                                                                        if (exists($allele_ordered{$AF_tmp}))
                                                                        {
                                                                            $allele_ordered{$AF_tmp+0.001} = $nuc_tmp;
                                                                            $h = '0.002';
                                                                        }
                                                                        else
                                                                        {
                                                                           $allele_ordered{$AF_tmp} = $nuc_tmp; 
                                                                        }
                                                            print OUTPUT5 $AF_tmp." TESh4\n";
                                                                    }
                                                                    my %deduct_duplications;
                                                                    undef %deduct_duplications;
                                                                    my $deduct_duplications_total;
                                                                    
                                                                    mismatch (\%extensionsb, \%remove_extension_mismatch, $ref_check);
                                                                    my $count_tmp = keys %remove_extension_mismatch_tmp;
                                                                    my $count_tmp2 = keys %extensionsb;
                                                                    if ($count_tmp < $count_tmp2/5 && $split eq "")
                                                                    {
                                                                       print OUTPUT5 $count_tmp." COUNT_TMP ".$count_tmp2." COUNT_TMP2\n";
                                                                       %remove_extension_mismatch = (%remove_extension_mismatch, %remove_extension_mismatch_tmp);
                                                                    }
                                                                    foreach my $allele_ordered (sort {$b <=> $a} keys %allele_ordered)
                                                                    {
                                                                        if ($s eq '0')
                                                                        {
                                                                            my %count_ext_first;
                                                                            undef %count_ext_first;
                                                                            
HP_NEXT:                                                                    foreach my $ext_tmp (keys %extensionsb)
                                                                            {
                                                                                my $first_nuc = substr $extensionsb{$ext_tmp}, $position_tmp, 1;
                                                                                if ($first_nuc eq $nucs_order[$allele_ordered{$allele_ordered}])
                                                                                {
                                                                                    if (exists($remove_extension_mismatch{$extensionsb{$ext_tmp}}))
                                                                                    {
                                                                                            $deduct_mismatch_nuc_first++;
                                                                                            next HP_NEXT;
                                                                                    }
                                                                                    if ($position_tmp > 0)
                                                                                    {
                                                                                        my $next_nuc = substr $extensionsb{$ext_tmp}, $position_tmp-1, 1;
                                                                                        if ($next_nuc eq "N" || $next_nuc eq "1" || $next_nuc eq "2" || $next_nuc eq "3" || $next_nuc eq "4" || $next_nuc eq "")
                                                                                        {
                                                                                            $deduct_low_quality_next_nuc_first++;
                                                                                            next HP_NEXT;
                                                                                        }
                                                                                    }
                                                                                    if (exists($exlude_id_prev_nuc_hp{$ext_tmp}))
                                                                                    {
                                                                                        $deduct_low_quality_next_nuc_first++;
                                                                                        next HP_NEXT;
                                                                                    }
                                                                                    if (length($extensionsb{$ext_tmp}) > $position_tmp+1)
                                                                                    {
                                                                                        my $next_nuc = substr $extensionsb{$ext_tmp}, $position_tmp+1, 1;
                                                                                        if ($next_nuc eq "N" || $next_nuc eq "1" || $next_nuc eq "2" || $next_nuc eq "3" || $next_nuc eq "4" || $next_nuc eq "")
                                                                                        {
                                                                                            $deduct_low_quality_next_nuc_first++;
                                                                                            next HP_NEXT;
                                                                                        }
                                                                                    }
                                                                                    elsif (length($extensionsb{$ext_tmp}) <= $position_tmp+1)
                                                                                    {
                                                                                        $deduct_low_quality_next_nuc_first++;
                                                                                        next HP_NEXT;
                                                                                    }
                                                                                    if (exists($count_ext_first{length($extensionsb{$ext_tmp})}))
                                                                                    {
                                                                                        my $count = $count_ext_first{length($extensionsb{$ext_tmp})}+1;
                                                                                        $count_ext_first{length($extensionsb{$ext_tmp})} = $count;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        $count_ext_first{length($extensionsb{$ext_tmp})} = '1';
                                                                                    }
                                                                                }
                                                                            }            
                                                                            foreach my $count_ext_first (keys %count_ext_first)
                                                                            {
                                                                                if ($count_ext_first{$count_ext_first} > ($nucs_count[$allele_ordered{$allele_ordered}]/($read_length-$left-$overlap))*3 && $count_ext_first{$count_ext_first} > 2)
                                                                                {
                                                                                    $deduct_duplications_first += $count_ext_first{$count_ext_first}-(($nucs_count[$allele_ordered{$allele_ordered}]/($read_length-$left-$overlap))*1.7);
                                                                                }
                                                                            }
                                                                            $deduct_duplications{$allele_ordered} = $nucs_count[$allele_ordered{$allele_ordered}]-$deduct_duplications_first-$deduct_low_quality_next_nuc_first-$deduct_mismatch_nuc_first;
                                                                            $deduct_duplications_total = $deduct_duplications_first+$deduct_low_quality_next_nuc_first+$deduct_mismatch_nuc_first;
                                                                        print OUTPUT5 $deduct_duplications{$allele_ordered}." GIGI_FIRST\n";
                                                                            if ($deduct_duplications{$allele_ordered} < 1)
                                                                            {
                                                                                 delete $deduct_duplications{$allele_ordered};
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            my %count_ext;
                                                                            undef %count_ext;
                                                                            my $deduct_low_quality_next_nuc = '0';
                                                                            my $deduct_mismatch_nuc = '0';
                                                                            
HP_NEXT2:                                                                   foreach my $ext_tmp (keys %extensionsb)
                                                                            {
                                                                                my $first_nuc = substr $extensionsb{$ext_tmp}, $position_tmp, 1;                                          
                                                                                if ($first_nuc eq $nucs_order[$allele_ordered{$allele_ordered}])
                                                                                {                                                                                  
                                                                                    if (exists($remove_extension_mismatch{$extensionsb{$ext_tmp}}))
                                                                                    {
                                                                                            $deduct_mismatch_nuc++;
                                                                                            next HP_NEXT2;
                                                                                    }
                                                                                    if ($position_tmp > 0)
                                                                                    {
                                                                                        my $next_nuc = substr $extensionsb{$ext_tmp}, $position_tmp-1, 1;
                                                                                        if ($next_nuc eq "N" || $next_nuc eq "1" || $next_nuc eq "2" || $next_nuc eq "3" || $next_nuc eq "4" || $next_nuc eq "")
                                                                                        {
                                                                                            $deduct_low_quality_next_nuc++;
                                                                                            next HP_NEXT2;
                                                                                        }
                                                                                    }
                                                                                    if (exists($exlude_id_prev_nuc_hp{$ext_tmp}))
                                                                                    {
                                                                                        $deduct_low_quality_next_nuc++;
                                                                                        next HP_NEXT2;
                                                                                    }
                                                                                    if (length($extensionsb{$ext_tmp}) > $position_tmp+1)
                                                                                    {
                                                                                        my $next_nuc = substr $extensionsb{$ext_tmp}, $position_tmp+1, 1;
                                                                                        if ($next_nuc eq "N" || $next_nuc eq "1" || $next_nuc eq "2" || $next_nuc eq "3" || $next_nuc eq "4" || $next_nuc eq "")
                                                                                        {
                                                                                            $deduct_low_quality_next_nuc++;
                                                                                            next HP_NEXT2;
                                                                                        }
                                                                                    }
                                                                                    elsif (length($extensionsb{$ext_tmp}) <= $position_tmp+1)
                                                                                    {
                                                                                        $deduct_low_quality_next_nuc++;
                                                                                        next HP_NEXT2;
                                                                                    }
                                                                                    if (exists($count_ext{length($extensionsb{$ext_tmp})}))
                                                                                    {
                                                                                        my $count = $count_ext{length($extensionsb{$ext_tmp})}+1;
                                                                                        $count_ext{length($extensionsb{$ext_tmp})} = $count;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        $count_ext{length($extensionsb{$ext_tmp})} = '1';
                                                                                    }
                                                                                }
                                                                            }
                                                                            my $deduct_duplications = '0';
                                                                            foreach my $count_ext (keys %count_ext)
                                                                            {
                                                                                if ($count_ext{$count_ext} > ($nucs_count[$allele_ordered{$allele_ordered}]/($read_length-$left-$overlap))*3 && $count_ext{$count_ext} > 2)
                                                                                {
                                                                                    $deduct_duplications += $count_ext{$count_ext}-($nucs_count[$allele_ordered{$allele_ordered}]/($read_length-$left-$overlap)*1.7);
                                                                                }
                                                                            }                                                                       
                                                                            $deduct_duplications{$allele_ordered} = $nucs_count[$allele_ordered{$allele_ordered}]-$deduct_duplications-$deduct_low_quality_next_nuc-$deduct_mismatch_nuc;
                                                                            $deduct_duplications_total += ($deduct_duplications+$deduct_low_quality_next_nuc+$deduct_mismatch_nuc);
                                                                       print OUTPUT5 $deduct_duplications{$allele_ordered}." GIGI\n";      
                                                                             print OUTPUT5 $deduct_mismatch_nuc." DEDU1\n";
                                                                              print OUTPUT5 $deduct_low_quality_next_nuc." DEDU2\n";
                                                                               print OUTPUT5 $deduct_duplications." DEDU3\n";
                                                                               if ($deduct_duplications{$allele_ordered} < 1)
                                                                               {
                                                                                    delete $deduct_duplications{$allele_ordered};
                                                                               }
                                                                        }
                                                                        $s++;
                                                                    }
                                                                    my $count_AFs = keys %deduct_duplications;
                                                                    if ($count_AFs eq 1 && $variance_detection eq "" && $split_forward_tmp eq "" && $deletion eq "")
                                                                    {
                                                                        foreach my $DD (keys %deduct_duplications)
                                                                        {
                                                                            substr $best_extension_tmp, $position_tmp, 1, $nucs_order[$allele_ordered{$DD}];
                                                                            substr $best_extension, $position_tmp, 1, $nucs_order[$allele_ordered{$DD}];
                                                                            print OUTPUT5 $best_extension_tmp." TEST_EXT\n";
                                                                        }
                                                                    }
                                                                    my $new_total_nuc = $nucs_count[0]+$nucs_count[1]+$nucs_count[2]+$nucs_count[3]-$deduct_duplications_total;
                                                                    if ($new_total_nuc eq '0')
                                                                    {
                                                                        $new_total_nuc = '1';
                                                                    }
                                                                    if ($new_total_nuc < 10 && $hp_seed_assemble eq "" && $deduct_duplications_total > 0.1*($nucs_count[0]+$nucs_count[1]+$nucs_count[2]+$nucs_count[3]))
                                                                    {
                                                                        $d++;
                                                                        print OUTPUT5 $d." NEXT_NUC_HP\n";
                                                                        next NEXT_NUC_HP;
                                                                    }
                                                                    $DP = int($new_total_nuc);
                                                                     
                                                                    if ($heteroplasmy ne "")
                                                                    {
                                                                        $no_variance = "yes";
                                                                    }
                                                                    my %new_AFs;
                                                                    undef %new_AFs;
                                                                    foreach my $deduct_duplications_tmp (sort {$b <=> $a} keys %deduct_duplications)
                                                                    {   
                                                                        my $AF_tmp = sprintf("%.3g",($deduct_duplications{$deduct_duplications_tmp})/$new_total_nuc);
                                                                        $new_AFs{$AF_tmp} = $deduct_duplications_tmp;
                                                                        print OUTPUT5 $AF_tmp." NO_VARIANCE\n";
                                                                    }
                                                                    $AF_major = "";
                                                                    foreach my $new_AFs (sort {$b <=> $a} keys %new_AFs)
                                                                    {
                                                                        if ($AF_major eq "")
                                                                        {
                                                                            $AF = $new_AFs;
                                                                            $AF_save = $new_AFs;
                                                                            $AF_major = $new_AFs;
                                                                            $nucs_alt_major = $nucs_order[$allele_ordered{$new_AFs{$new_AFs}}];
                                                                            $nucs_alt = $nucs_order[$allele_ordered{$new_AFs{$new_AFs}}];
                                                                            
                                                                            if ($hp_seed_assemble ne "" && $nuc_other_than_ref eq $nucs_alt)
                                                                            {
                                                                                $nuc_other_than_ref_AF = $new_AFs;
                                                                            }
                                                                            if ($hp_seed_assemble eq "")
                                                                            {
                                                                                $variance_pos_to_nuc_to_freq{$pos_tmp2}{$nucs_alt} = $new_AFs;
                                                                            }
                                                                        }
                                                                        elsif ($new_AFs >= $heteroplasmy)
                                                                        {
                                                                            $AF .= ",".$new_AFs;
                                                                            $AF_save .= ",".$new_AFs;
                                                                            $no_variance = "";
                                                                            $nucs_alt .= ",".$nucs_order[$allele_ordered{$new_AFs{$new_AFs}}];
                                                                            
                                                                            if ($hp_seed_assemble ne "" && $nuc_other_than_ref eq $nucs_order[$allele_ordered{$new_AFs{$new_AFs}}])
                                                                            {
                                                                                $nuc_other_than_ref_AF = $new_AFs;
                                                                            }
                                                                            if ($hp_seed_assemble eq "")
                                                                            {
                                                                                $variance_pos_to_nuc_to_freq{$pos_tmp2}{$nucs_order[$allele_ordered{$new_AFs{$new_AFs}}]} = $new_AFs;
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            $AF_save .= ",".$new_AFs;
                                                                            $nucs_alt .= ",".$nucs_order[$allele_ordered{$new_AFs{$new_AFs}}];
                                                                            if ($hp_seed_assemble eq "")
                                                                            {
                                                                                $variance_pos_to_nuc_to_freq{$pos_tmp2}{$nucs_order[$allele_ordered{$new_AFs{$new_AFs}}]} = $new_AFs;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                if ($SNR_read ne "" && $no_variance ne "yes" && $last_chance_SNR eq "" && $hp_seed_assemble eq "")
                                                                {
                                                                    my $SNR_read_tmp = SNR_ahead (\%extensionsb, $pos_tmp-$prev_loc1);
                                                                    if ($SNR_read_tmp eq "yes" && $SNR_read_ahead eq $nuc_other_than_ref && $SNR_read2 eq "")
                                                                    {
                                                                        print OUTPUT5 $nuc_other_than_ref." REDO_WITH_ONLY_LAST\n";
                                                                        if ($var_recorderd < 2)
                                                                        {
                                                                            $last_chance = "yes";
                                                                            $last_chance_SNR = "yes";
                                                                            goto NO_AT;
                                                                        }
                                                                    }
                                                                }
                                                                
                                                               print OUTPUT5 $nucs_alt." NUCS_ALT1\n";
                                                                $old_nucs_alt{$pos_tmp2} = $nucs_alt;
                                                                
                                                                my $nuc_in_ext_hp = substr $best_extension, $pos_tmp-$prev_loc1, 1;
                                                                if ($variance_detection eq "yes")
                                                                {
                                                                    $variance_no_hp{$pos_tmp2} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1]."\t".$nucs_alt."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                }
                                                                else
                                                                {
                                                                    my $count_hps = $best_extension =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\.//;
                                                                    if ($hp_seed_assemble eq "" && $no_variance eq "yes" && $heteroplasmy ne "" && ($count_hps < 2 || $SNR_read2 eq "") && $no_homoplasmy eq "")
                                                                    {
                                                                        $AF = $AF_save;
                                                                        $hp_forward_data{$pos_tmp2} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1]."\t".$nucs_alt."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                        if ($ref_check[$pos_tmp-$prev_loc1] ne $nuc_in_ext_hp && ($nuc_in_ext_hp eq "A" || $nuc_in_ext_hp eq "C" || $nuc_in_ext_hp eq "T" || $nuc_in_ext_hp eq "G") && $heteroplasmy ne "")
                                                                        {
                                                                            $variance_all_homo{$pos_tmp2} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1]."\t".$nucs_alt."\t.\t.\tAF=".$AF.";DP=".$DP.$FR;
                                                                            print OUTPUT5 $nuc_in_ext_hp." HOMOHOMOPLASMY0\n";
                                                                        }
                                                                    }
                                                                    elsif ($hp_seed_assemble eq "" && ($count_hps < 2 || $SNR_read2 eq ""))
                                                                    {
                                                                        if ($variance_detection ne "yes")
                                                                        {
                                                                            my @nucs_alt_tmp = split /,/, $nucs_alt;
                                                                            my $nucs_alt_new = "";
                                                                            
                                                                            foreach my $nucs_alt_tmp (@nucs_alt_tmp)
                                                                            {
                                                                                if ($nucs_alt_tmp ne $ref_check[$pos_tmp-$prev_loc1])
                                                                                {
                                                                                    if ($nucs_alt_new eq "")
                                                                                    {
                                                                                        $nucs_alt_new = $nucs_alt_tmp;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        $nucs_alt_new .= ",".$nucs_alt_tmp;
                                                                                    }
                                                                                }
                                                                            }
                                                                            $nucs_alt = $nucs_alt_new;
                                                                        }
                                                                        if (exists($variance_all{$pos_tmp2}))
                                                                        {
                                                                            my $one;
                                                                            my $two;
                                                                            if ($variance_all{$pos_tmp2} =~ m/^\S*\s\S*\s\S*\t(\S*)\s(\S*)\s.*/)
                                                                            {
                                                                                $one = substr $1, 1;
                                                                                $two = substr $2, 1;
                                                                            }
                                                                            if ($ref_check[$pos_tmp-$prev_loc1] ne $nuc_in_ext_hp && ($nuc_in_ext_hp eq "A" || $nuc_in_ext_hp eq "C" || $nuc_in_ext_hp eq "T" || $nuc_in_ext_hp eq "G") && $heteroplasmy ne "")
                                                                            {
                                                                                $variance_all_homo{$pos_tmp2."b"} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1]."\t".$nucs_alt."\t.\t.\tAF=".$AF.";DP=".$DP.$FR;
                                                                                $variance_all_homo{$pos_tmp2} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1].$one."\t".$nucs_alt.$two."\t.\t.\tAF=".$AF.";DP=".$DP.$FR;
                                                                            }
                                                                            else
                                                                            {
                                                                                $variance_all_SNP{$pos_tmp2} = $nucs_alt;
                                                                                $variance_all{$pos_tmp2."b"} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1]."\t".$nucs_alt."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                                $variance_all{$pos_tmp2} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1].$one."\t".$nucs_alt.$two."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            if ($ref_check[$pos_tmp-$prev_loc1] ne $nuc_in_ext_hp && ($nuc_in_ext_hp eq "A" || $nuc_in_ext_hp eq "C" || $nuc_in_ext_hp eq "T" || $nuc_in_ext_hp eq "G") && $heteroplasmy ne "")
                                                                            {
                                                                                $variance_all_homo{$pos_tmp2} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1]."\t".$nucs_alt."\t.\t.\tAF=".$AF.";DP=".$DP.$FR;
                                                                                print OUTPUT5 $nuc_in_ext_hp." HOMOPLASMY\n";
                                                                            }
                                                                            else
                                                                            {
                                                                                $variance_all_SNP{$pos_tmp2} = $nucs_alt;
                                                                                $variance_all{$pos_tmp2} = $chromosome."\t".$pos_tmp2."\t".".\t".$ref_check[$pos_tmp-$prev_loc1]."\t".$nucs_alt."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;                                              
                                                                                print OUTPUT5 $variance_all{$pos_tmp2}." CHEEE\n"; 
                                                                                print OUTPUT5 $nuc_in_ext_hp." HETEROPLASMY\n";
                                                                            }
                                                                        }
                                                                    }
                                                                    elsif ($ref_check[$pos_tmp-$prev_loc1] ne $nuc_in_ext_hp && ($nuc_in_ext_hp eq "A" || $nuc_in_ext_hp eq "C" || $nuc_in_ext_hp eq "T" || $nuc_in_ext_hp eq "G") && $hp_seed_assemble ne "")
                                                                    {
                                                                        my $pos_SNPs = $position+$pos_tmp-$prev_loc1+1;                                                                   
                                                                        if (exists($variance_all_homo{$pos_tmp+$deletion_correction}) || exists($variance_all_homo{$pos_tmp}) || exists($variance_all_homo{$pos_tmp-1}))
                                                                        {}
                                                                        elsif ($del_detect eq "1" && $deletion ne "")
                                                                        {
                                                                            $hold_SNPs{$pos_SNPs} = $nuc_in_ext_hp;
                                                                            $hold_linked{$pos_tmp+$deletion_correction} = undef;
                                                                        }
                                                                        elsif ($del_detect eq "2" && $deletion ne "")
                                                                        {
                                                                            if (exists($hold_SNPs{$pos_SNPs}))
                                                                            {
                                                                                $SNPs{$pos_SNPs} = $nuc_in_ext_hp;
                                                                            }
                                                                            if (exists($hold_linked{$pos_tmp}))
                                                                            {
                                                                                $linked_SNPs{$pos_tmp+$deletion_correction} = undef;
                                                                            }
                                                                        }
                                                                        else
                                                                        {        
                                                                            $SNPs{$pos_SNPs} = $nuc_in_ext_hp;
                                                                            $linked_SNPs{$pos_tmp+$deletion_correction} = undef;
                                                                        }
                                                                        if (exists($NUMT_assembled{$pos_tmp}))
                                                                        {
                                                                            print OUTPUT5 $pos_tmp." NUMT_ALERT\n";
                                                                            $NUMT = "yes";
                                                                            delete $seed{$id};
                                                                            goto HP0;
                                                                        }
                                                                    }
                                                                    elsif ($ref_check[$pos_tmp-$prev_loc1] ne $nuc_in_ext_hp && $no_variance ne "yes" && $hp_seed_assemble ne "")
                                                                    {
                                                                        if (exists($variance_all_homo{$pos_tmp}))
                                                                        {
                                                                            print OUTPUT5 $pos_tmp." HOMO_SKIP\n";
                                                                        }
                                                                        else
                                                                        {
                                                                            my $test_c = '0';
                                                                            my @hp_splits = keys %hp_splits;
                                                                            foreach my $l_h_SNPs (keys %linked_half_SNPs)
                                                                            {
                                                                                $test_c++;
                                                                            }
                                                                            if ($test_c > 1000 && $PCR_free ne "yes")
                                                                            {
                                                                                $noforward{$id} = "stop_HP";
                                                                                print OUTPUT5 "STOP_HALF_LINKED\n";
                                                                            }
                                                                            my $pos_SNPs = $position+$pos_tmp-$prev_loc1+1;                                                                  
         
                                                                            if (($PCR_free ne "yes" && $test_c < 10 && $nuc_other_than_ref_AF > 0.65) ||
                                                                                (($nuc_other_than_ref_AF > 0.7 && ($nuc_count_ref < 5)) || $nuc_other_than_ref_AF > 0.9))
                                                                            {
                                                                                print OUTPUT5 $nuc_other_than_ref_AF." PCR_AF\n";
                                                                                if ($nuc_other_than_ref ne "")
                                                                                {
                                                                                    $SNPs{$pos_SNPs} = $nuc_other_than_ref;
                                                                                    $linked_SNPs{$pos_tmp+$deletion_correction} = undef;
                                                                                }
                                                                                substr $best_extension, $position_tmp, 1, $nuc_other_than_ref;
                                                                                substr $best_extension, $pos_tmp-$prev_loc1+1, length($best_extension)-($pos_tmp-$prev_loc1), "";
                                                                                last VAR_CHECK;
                                                                            }
                                                                            
                                                                            if ($AF_major > 0.85 && $nucs_alt_major eq $ref_check[$pos_tmp-$prev_loc1] && $count_hp_SNPS < 2)
                                                                            {
                                                                                if (exists($variance_all{$pos_SNPs}))
                                                                                {}
                                                                                else
                                                                                {
                                                                                    substr $best_extension, $pos_tmp-$prev_loc1, 1, $ref_check[$pos_tmp-$prev_loc1];
                                                                                }
                                                                            }
                                                                            elsif ($PCR_free eq "yes" && @hp_splits < 100000000)
                                                                            {
                                                                                $linked_half_SNPs{$pos_tmp+$deletion_correction} = $pos_SNPs;
                                                                                $pos_of_last_hp_split_option = $position;
                                                                                
                                                                                 my $pos_tmp_start = $pos_tmp-20;
                                                                                my $found_homo = "";
                                                                                while ($pos_tmp_start < $pos_tmp+20)
                                                                                {
                                                                                    if (exists($variance_all_homo{$pos_tmp_start}) && $SNR_read2 ne "")
                                                                                    {
                                                                                        $found_homo = "yes";
                                                                                        last VAR_CHECK;
                                                                                    }
                                                                                    $pos_tmp_start++;
                                                                                }
                                                                                if ($nuc_other_than_ref ne "" && $split_hp_options ne "" && ($SNP_to_assemble{$nuc_other_than_ref} > 0 || $last_half_linked eq ""))
                                                                                {
                                                                                    print OUTPUT5 $pos_SNPs." ADD_EXTRA_SPLIT\n";
                                                                                    my $best_extension_tmpi = $best_extension;
                                                                                    substr $best_extension_tmpi, $pos_tmp-$prev_loc1, 1, $ref_check[$pos_tmp-$prev_loc1];
                                                                                    substr $best_extension_tmpi, $pos_tmp-$prev_loc1+1, length($best_extension_tmpi)-($pos_tmp-$prev_loc1), "";
                                                                                    hp_select_best_ext ($best_extension_tmpi, \%SNPs, \%linked_SNPs, \%linked_half_SNPs, \%not_linked_SNPs, $position, $position_back, $pos_tmp, $pos_SNPs);
                                                                                    $last_half_linked = $position+length($best_extension_tmpi);
                                                                                    $SNPs{$pos_SNPs} = $nuc_other_than_ref;
                                                                                    $linked_SNPs{$pos_tmp+$deletion_correction} = undef;
                                                                                    substr $best_extension, $pos_tmp-$prev_loc1, 1, $nuc_other_than_ref;
                                                                                    substr $best_extension, $pos_tmp-$prev_loc1+1, length($best_extension)-($pos_tmp-$prev_loc1), "";
                                                                                    last VAR_CHECK;
                                                                                }     
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                print OUTPUT5 $pos_tmp." POS_TMP\n\n";
                                                            }
                                                        }
                                                        $next = '0';
                                                        undef @pos;
                                                    }
                                                    elsif ($hp_seed_assemble ne "" && ($deletion eq "" || (@pos < 2 && $d > 2)) && $large_variance_tmp eq "")
                                                    {
                                                        foreach my $pos_tmp (keys %variance_all_SNP)
                                                        {
                                                            if (exists($variance_all_SNP_seed{$pos_tmp}))
                                                            {}
                                                            elsif ($pos_tmp eq $prev_loc1_tmp+$d)
                                                            {
                                                                $not_linked_SNPs{$pos_tmp} = undef;
                                                                print OUTPUT5 $pos_tmp." NOT_LINKED\n";
                                                                $not_linked_tmp{$pos_tmp} = $d;
                                                            }                                    
                                                        }
                                                    }
                                                    elsif ($hp_seed_assemble eq "")
                                                    {
                                                        my $pos_tmp2 = $prev_loc1+$th+$deletion_correction;
                                                        $hp_forward_data2{$pos_tmp2} = $allele_percentage{$th};
                                                    }
                                                }
                                                elsif (($next < $max_SNP || $deletion_found eq "yes") && exists($HP_exclude{$prev_loc1+$th}))
                                                {
                                                    $variance_all_SNP{$prev_loc1+$th} = $line[$d];
                                                }
                                                elsif (($next < $max_SNP || $deletion_found eq "yes") && $check_for_DEL ne "yes")
                                                {
                                                    if ($deletion ne "" && $check_for_DEL eq "" && $deletion_found eq "")
                                                    {
                                                        $check_for_DEL = "yes";
                                                    }
                                                    elsif ($deletion ne "" && $check_for_DEL eq "yes")
                                                    {
                                                        $check_for_DEL = "yes2";
                                                    }
                                                    if ($y > $startprint2)
                                                    {
                                                        print OUTPUT5 $ref_check[$th]." VAR_DETECT\n";
                                                    }
                                                    if (($pos_first eq '0' || $SNR_read ne "") && $need_longer_ext eq "" && length($best_extension) < 9 && $deletion eq "")
                                                    {
                                                        $need_longer_ext = "yes";
                                                        goto NO_AT;
                                                    }
                                                    
                                                    $pos = $prev_loc1+$th;
                                                    $next++;
                                                    if ($line[$d] ne "A" && $line[$d] ne "C" && $line[$d] ne "T" && $line[$d] ne "G")
                                                    {
                                                        $max_SNP++;
                                                    }
                                                    elsif (exists($large_variance_forward{$id}) && $first_without_LV ne "yes2" && $d ne '0' && $next/($d+1) < 0.13)
                                                    {
                                                        $max_SNP++;
                                                    }
                                                    my $count_pos_tmp = @pos;
                                                    
                                                    push @pos, $prev_loc1+$th;
                                                    if ($pos_first eq "")
                                                    {
                                                        $pos_first = $d;
                                                    }
                                                    if ($d > length($best_extension_tmp)-6 && length($best_extension_tmp) > 6 && $count_pos_tmp eq '0' && $no_large_variance_forward eq "" && $deletion eq "" && $d ne '0')
                                                    {
                                                        $best_extension = substr $best_extension, 0, $d;
                                                        last VAR_CHECK;
                                                    }
                                                    elsif ($d eq length($best_extension_tmp)-1 && (length($best_extension_tmp) < 10 || $no_large_variance_forward ne ""))
                                                    {
                                                        $write_last_SNP = "yes";
                                                        $d--;
                                                    }
                                                    if (($d eq '0' || $deletion ne "" || exists($large_variance_forward{$id})) && $no_large_variance_forward eq "")
                                                    {
                                                        $max_SNP = length($best_extension)/4;
                                                        if ($max_SNP < 3)
                                                        {
                                                            $max_SNP = 3;
                                                        }
                                                        if (length($best_extension) > 15 && $max_SNP < 6)
                                                        {
                                                            $max_SNP = 6;
                                                        }
                                                        if (length($best_extension) > 25 && $max_SNP < 7)
                                                        {
                                                            $max_SNP = 7;
                                                        }
                                                    }
                                                    $hp_forward_data2{$pos} = $allele_percentage{$th};
                                                }
                                                elsif ($next > 0 && ($pos_first ne '0' || $var_recorderd > 0) && $deletion eq "" && $large_variance_tmp eq "")
                                                {
                                                    my $best_extension_tmp = $best_extension;
                                                    if ($pos_last eq "")
                                                    {
                                                        $pos_last = $pos_first;
                                                    }
                                                    $best_extension = substr $best_extension_tmp, 0, $pos_last;
                                                    foreach my $not_linked (keys %not_linked_tmp)
                                                    {
                                                        if ($not_linked_tmp{$not_linked} >= $prev_loc1+$pos_last)
                                                        {
                                                            delete $not_linked_SNPs{$not_linked};
                                                            delete $not_linked_tmp{$not_linked};
                                                        }
                                                    }
                                                    if ($y > $startprint2)
                                                    {
                                                        print OUTPUT5 $best_extension." BEST_EXT_CUT\n";
                                                    }
                                                    last VAR_CHECK;
                                                }
                                                elsif ((($next >= $max_SNP && ($pos_first eq '0' || ($pos_first < '3' && $deletion ne "") || exists($large_variance_forward{$id})) && $deletion_found ne "yes") || $check_for_DEL eq "yes") && ($large_variance_tmp eq "" || length($best_extension) > 15))
                                                {
                                                    if ($check_for_DEL eq "yes")
                                                    {
                                                        $check_for_DEL = "yes2";
                                                    }
                                                    foreach my $not_linked (keys %not_linked_tmp)
                                                    {
                                                        delete $not_linked_SNPs{$not_linked};
                                                        delete $not_linked_tmp{$not_linked};
                                                    }
                                                    my @check_deletion;
                                                    undef @check_deletion;
                                                    @check_deletion = check_deletion($best_extension_tmp, $ref_check_tmp,"","","yes", "");
                                                    
                                                    my $var_deletion = $check_deletion[0];
                                                    my $one_or_two = $check_deletion[1];
                                                    my $shorter = $check_deletion[2];
                                                    my $deletion_length0 = $check_deletion[3];
                                                    print OUTPUT5 $var_deletion." VAR_DEL_DETECT\n";
      
                                                    if ($var_deletion =~ m/(.*)\*(.*)?/)
                                                    { 
                                                        if ($heteroplasmy ne "" && $best_p_from_del ne $deletion_length0 && $best_p_from_del ne '0' && $hp_seed_assemble eq "" && $deletion ne "")
                                                        {
                                                            print OUTPUT5 "GOTO_REF\n";
                                                            $best_extension = "";
                                                            $deletion = "";
                                                            $before = "yes";
                                                            delete $last_ref_pos_forward{$id};
                                                            delete $last_ref_seq_forward{$id};
                                                            goto REF_GUIDED;
                                                        }
                                                        
                                                        my $deletion_tmp = $1;
                                                        my $after_deletion = $2;
                                                        $deletion_tmp =~ tr/\*//d;
                                                        my $last_nuc = substr $read_end, -1;
                                                        my $loc_in_ref = $prev_loc1-$gh;
                                                        
                                                        if (exists($large_variance_forward{$id}) && $first_without_LV ne "")
                                                        {          
                                                            my $deletion_length = $prev_loc1-$large_variance_forward{$id};
                                                            my $deletion_length_tmp = length($deletion_tmp);
                                                            
                                                            my $deleted_part = substr $read_short_end2, -$deletion_length;
                                                            $loc_in_ref = $large_variance_forward{$id};
                                                                   
                                                            if (length($best_extension) < 13)
                                                            {
                                                                $deletion_length_tmp = $overlap - length($deletion_tmp);
                                                            }
                                                            if ($one_or_two eq "one")
                                                            {
                                                                $deletion_length += $deletion_length_tmp;
                                                                $deleted_part .= $deletion;
                                                                $loc_in_ref -= 1;
                                                            }
                                                            else
                                                            {
                                                                $deletion_length -= $deletion_length_tmp;
                                                                substr $deleted_part, -$deletion_length_tmp, $deletion_length_tmp, "";
                                                            }
                                                            
                                                            if (length($best_extension) < 13)
                                                            {
                                                                if ($overlap > length($deletion_tmp))
                                                                {
                                                                    $deleted_part = substr $read_short_end2, -($deletion_length-$deletion_length_tmp), -$deletion_length_tmp;
                                                                }
                                                            }
                                                            print OUTPUT5 $deletion_length." DELETION_LENGTH\n";
                                                            print OUTPUT5 $deletion_length_tmp." DELETION_LENGTH2\n";
                                                            
                                                            $deletion_tmp = $deleted_part;
                                                            $last_nuc = substr $hashref2{$large_variance_forward{$id}-1}, 0, 1;
                                                            
                                                            $deletion_length0 = $deletion_length;
                                                            print OUTPUT5 $deletion_length." DELETION_LENGTHb\n";
                                                            print OUTPUT5 $large_variance_length_forward{$id}." DELETION_LENGTH2b\n";
                                                            if ($large_variance_length_forward{$id} > $deletion_length_tmp)
                                                            {
                                                                if ($one_or_two eq "two")
                                                                {
                                                                    $loc_in_ref -= 1;
                                                                }
                                                                $one_or_two = "one";
                                                            }
                                                            elsif ($large_variance_length_forward{$id} < $deletion_length_tmp)
                                                            {
                                                                $one_or_two = "two";
                                                            }
                                                            print OUTPUT5 $deleted_part." LARGE_INSERTION\n";
                                                        }
                                                        elsif (exists($large_variance_forward{$id}) && $first_without_LV eq "")
                                                        {
                                                            goto NO_LARGE_VARIANCE;
                                                        }
                                                        my $tmp = '0';
                                                        my $check_rep = substr $hashref2{$loc_in_ref-60}.$hashref2{$loc_in_ref-30}, -length($deletion_tmp)-$tmp, length($deletion_tmp);
                                                        while ($check_rep eq $deletion_tmp && $deletion_tmp ne "" && $check_rep ne "")
                                                        { 
                                                            $tmp++;
                                                            $check_rep = substr $hashref2{$loc_in_ref-60}.$hashref2{$loc_in_ref-30}, -length($deletion_tmp)-$tmp, length($deletion_tmp);
                                                        }
                                                        if ($tmp ne '0')
                                                        {
                                                            $tmp += length($deletion_tmp);
                                                        }
                                                        my $pos_tmp = $loc_in_ref-1;
                                                        my $last_nucb = $last_nuc;
                                                        my $tmpie = $loc_in_ref-$tmp;
                                                        if ($hp_seed_assemble eq "")
                                                        {
                                                            if (exists($variance_all{$pos_tmp}))
                                                            {
                                                                if ($variance_all{$pos_tmp} =~ m/^\S*\s\S*\s\S*\s(\S*)\s(\S*)\s.*/)
                                                                {
                                                                    my $last_nuc_prev = $1;
                                                                    my $last_nucb_prev = $2;
                                                                    print OUTPUT5 $variance_all{$pos_tmp}." ALLb\n";
                                                                        print OUTPUT5 $last_nuc_prev." ONEb\n";
                                                                        print OUTPUT5 $last_nuc." LAST_NUC\n";
                                                                        print OUTPUT5 $last_nucb_prev." TWOb\n";
                                                                    if ($last_nuc eq $last_nuc_prev && $split_forward_tmp ne "")
                                                                    {
                                                                        my @check_deletion_tmp;
                                                                        undef @check_deletion_tmp;
                                                                        print OUTPUT5 $deletion_tmp." DEL_TMP\n";
                                                                        @check_deletion_tmp = check_deletion($last_nucb_prev, $last_nucb.$deletion_tmp,"","","","","yes");
                                                                        
                                                                        my $var_deletion_tmp = $check_deletion_tmp[0];
                                                                        my $one_or_two_tmp = $check_deletion_tmp[1];
                                                                        my $shorter_tmp = $check_deletion_tmp[2];
                                                                        my $deletion_length0_tmp = $check_deletion_tmp[3];
                                                                   print OUTPUT5 $var_deletion_tmp." VAR_DEL\n";     
                                                                        if ($var_deletion_tmp =~ m/(.*)\*(.*)?/)
                                                                        {
                                                                            my $deletion_tmp_tmp = $1;
                                                                            my $after_deletion_tmp = $2;
                                                                            $deletion_tmp_tmp =~ tr/\*//d;
                                                                            
                                                                            $variance_all_homo{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc."\t".$after_deletion_tmp."\t.\t.\tAF=".$AF.";DP=".$DP.$FR;
                                                                            delete $variance_all{$pos_tmp};
                                                                            $variance_all{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc."\t".$last_nuc.$deletion_tmp_tmp."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                            print OUTPUT5 $variance_all{$pos_tmp}." HEHO\n";
                                                                            goto SKIP_HETERO_HOMO;
                                                                        }
                                                                    }
                                                                }
                                                                $variance_all{$pos_tmp."b"} = $variance_all{$pos_tmp};
                                                                delete $variance_all{$pos_tmp};
                                                            }
                                                            $deletion_tmp =~ tr/\./N/;
                                                            if ($one_or_two eq "one") #INSERTION
                                                            {
                                                                if ($variance_detection eq "yes")
                                                                {
                                                                    $variance_no_hp{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc."\t".$last_nucb.$deletion_tmp."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                } 
                                                                elsif ($split_forward_tmp eq "" && $heteroplasmy ne "" && $deletion eq "")
                                                                {
                                                                    $variance_all_homo{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc."\t".$last_nucb.$deletion_tmp."\t.\t.\tAF=".$AF.";DP=".$DP.$FR;
                                                                }
                                                                else
                                                                {      
                                                                    $DP = $hp_indel_ratio{"A"}+$hp_indel_ratio{"C"}+$hp_indel_ratio{"T"}+$hp_indel_ratio{"G"};                                                                   
                                                                    my $first_nuc = substr $deletion_tmp, 0, 1;
                                                                    $AF = sprintf("%.3g",(($DP-$hp_indel_ratio{$first_nuc})/$DP));
                                                                    my $AF_tmp = sprintf("%.3g",($hp_indel_ratio{$first_nuc}/$DP));
                                                                    $AF .= ",".$AF_tmp;
                                                                    if ($last_chance ne "yes")
                                                                    {
                                                                        $DP *= 2;
                                                                    }
                                                                    if ($hp_seed_assemble eq "")
                                                                    {
                                                                        $variance_pos_to_nuc_to_freq{$pos_tmp}{$last_nucb.$deletion_tmp} = $AF_tmp;
                                                                    }
                                                                    
                                                                    $variance_all{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc."\t".$last_nucb.$deletion_tmp."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                    $variance_indels{$pos_tmp} = undef;
                                                                    if ($deletion ne "yes")
                                                                    {
                                                                        $variance_forward{$id."*".$tmpie} = length($deletion_tmp);
                                                                    }
                                                                    print OUTPUT5 $variance_all{$pos_tmp}." CHEEE1\n";
                                                                }
                                                                
                                                            }
                                                            elsif($one_or_two eq "two") #DELETION
                                                            {
                                                                if ($variance_detection eq "yes")
                                                                {
                                                                    $variance_no_hp{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc.$deletion_tmp."\t".$last_nucb."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                }   
                                                                elsif ($split_forward_tmp eq "" && $heteroplasmy ne "" && $deletion eq "")
                                                                {
                                                                    $variance_all_homo{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc.$deletion_tmp."\t".$last_nucb."\t.\t.\tAF=".$AF.";DP=".$DP.$FR;
                                                                }
                                                                else
                                                                {    
                                                                    $DP = $hp_indel_ratio{"A"}+$hp_indel_ratio{"C"}+$hp_indel_ratio{"T"}+$hp_indel_ratio{"G"};                                                             
                                                                    my $first_nuc = substr $deletion_tmp, 0, 1;
                                                                    $AF = sprintf("%.3g",($hp_indel_ratio{$first_nuc}/$DP));
                                                                    my $AF_tmp = sprintf("%.3g",(($DP-$hp_indel_ratio{$first_nuc})/$DP));
                                                                    $AF .= ",".$AF_tmp;
                                                                    if ($last_chance ne "yes")
                                                                    {
                                                                        $DP *= 2;
                                                                    }
                                                                    if ($hp_seed_assemble eq "")
                                                                    {
                                                                        $variance_pos_to_nuc_to_freq{$pos_tmp}{$last_nucb} = $AF_tmp;
                                                                    }
                                                                    
                                                                    $variance_all{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc.$deletion_tmp."\t".$last_nucb."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                    $variance_indels{$pos_tmp} = undef;
                                                                    if ($deletion ne "yes")
                                                                    {
                                                                        $variance_forward{$id."*".$tmpie} = -length($deletion_tmp);
                                                                    }
                                                                    print OUTPUT5 $variance_all{$pos_tmp}." CHEEE2\n"; 
                                                                }
                                                            }
                                                        }
                                                        elsif ($deletion eq "")
                                                        {
                                                            my $pos_SNPs = $position+1;
                                                            my $first_nuc = substr $best_extension, 0, 1;
                                                            my $second_nuc = substr $best_extension, 1, 1;
                                                            my $pos_tmp_start = $pos_tmp-20;
                                                            my $found_homo = "";
                                                            while ($pos_tmp_start < $pos_tmp+20)
                                                            {
                                                                if (exists($variance_all_homo{$pos_tmp_start}))
                                                                {
                                                                    $found_homo = "yes";
                                                                }
                                                                $pos_tmp_start++;
                                                            }
                                                            if ($found_homo eq "yes")
                                                            {}
                                                            elsif ($first_nuc eq "A" || $first_nuc eq "C" || $first_nuc eq "T" || $first_nuc eq "G")
                                                            {
                                                                $SNPs{$pos_SNPs} = $first_nuc;
                                                                $linked_SNPs{$prev_loc1} = undef;
                                                            }
                                                            else
                                                            {
                                                                my $m = '0';
                                                                my $first_nuc_ref = substr $ref_check_tmp, 0, 1;
                                                                $first_nuc =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                                $first_nuc_ref =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                                while ($first_nuc_ref eq $first_nuc || $first_nuc eq ".")
                                                                {
                                                                    $m++;
                                                                    $first_nuc = substr $best_extension, $m, 1;
                                                                    $first_nuc_ref = substr $ref_check_tmp, $m, 1;
                                                                    $first_nuc =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                                    $first_nuc_ref =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                                }
                                                                if ($first_nuc ne "" && $first_nuc_ref ne "" && $first_nuc_ref ne $first_nuc && $m > 0)
                                                                {
                                                                    my $best_ext_tmp = substr $best_extension, 0, $m;
                                                                    $best_extension = $best_ext_tmp;
                                                                    last VAR_CHECK;
                                                                }
                                                            }
                                                            
                                                            print OUTPUT5 $prev_loc1." VAR_DEL_HP\n";
                                                            if ($one_or_two eq "one")
                                                            {
                                                                $variance_forward{$id."*".$tmpie} = length($deletion_tmp);
                                                            }
                                                            elsif($one_or_two eq "two")
                                                            {
                                                                $variance_forward{$id."*".$tmpie} = -length($deletion_tmp);
                                                            }
                                                        }
 SKIP_HETERO_HOMO:                                                       
                                                        my $check_dot = $after_deletion =~ tr/\./\./;
                                                        if ($shorter > 0)
                                                        {
                                                            substr $best_extension, -$shorter, $shorter, "";
                                                            print OUTPUT5 $best_extension." BEST_EXTENSION_SHORTER\n";
                                                        }
                                                        
                                                        my $deletion_length0_tmp = $deletion_length0;
                                                        if($one_or_two eq "one")
                                                        {
                                                            $deletion_length0_tmp = -$deletion_length0;
                                                        }
                                                        print OUTPUT5 $deletion_length0." DEL_LENGTH0\n";
                                                        my $length = length($best_extension)+$deletion_length0_tmp;
                                                        my $extra_seq = substr $ref_check_forward, 0, $length;
                                                        print OUTPUT5 $extra_seq." EXTRA_SEQ\n";
                                                        $last_ref_seq_forward{$id} = $last_seq_ref.$extra_seq;
                                                        if (exists($last_ref_pos_forward{$id}))
                                                        {
                                                            $last_ref_pos_forward{$id} = $last_ref_pos_forward{$id}+length($extra_seq);
                                                        }
                                                        $save_seq_ref_forward = "no2";
                                                        $deletion_length0_tmp_save = $deletion_length0_tmp;
                                                        $extra_seq_save = $extra_seq;
                                                        if (exists($large_variance_forward{$id}) && $deletion_length0 < $large_variance_length_forward{$id} && $first_without_LV ne "" )
                                                        {
                                                            if ($one_or_two eq "one")
                                                            {
                                                                $best_extension_tmp = substr $read_short_end2, -$large_variance_length_forward{$id}+$deletion_length0;
                                                                $best_extension_tmp .= $best_extension;
                                                                $prev_loc1 = $prev_loc1-($prev_loc1-$large_variance_forward{$id});
                                                            }
                                                            elsif($one_or_two eq "two")
                                                            {
                                                                $ref_check_tmp = substr $ref_check, length($deletion_tmp);
                                                            }
                                                            $deletion_found = "yes";
                                                            delete $large_variance_forward{$id};
                                                            delete $large_variance_length_forward{$id};
                                                            goto VAR_START;
                                                        }
                                                        delete $large_variance_forward{$id};
                                                        delete $large_variance_length_forward{$id};
                                                        if ($check_dot > 0)
                                                        {
                                                            if ($one_or_two eq "one")
                                                            {
                                                                $best_extension_tmp = substr $best_extension, length($deletion_tmp);
                                                            }
                                                            elsif($one_or_two eq "two")
                                                            {
                                                                $ref_check_tmp = substr $ref_check, length($deletion_tmp);
                                                                $prev_loc1_tmp_correction = length($deletion_tmp);
                                                                print OUTPUT5 $prev_loc1_tmp_correction." ONE_OR_TWO\n";
                                                                $deletion_correction = length($deletion_tmp);
                                                            }
                                                            $deletion_found = "yes";
                                                            if ($loop_check eq "")
                                                            {
                                                                $loop_check = "yes";
                                                                goto VAR_START;
                                                            }
                                                        }
                                                    }
                                                    if ($var_deletion ne "")
                                                    {
                                                        last VAR_CHECK;
                                                    }
                                                    elsif ($max_SNP eq '1')
                                                    {
                                                        $max_SNP = length($best_extension)/4;
                                                        if ($max_SNP < 3)
                                                        {
                                                            $max_SNP = 3;
                                                        }
                                                        if (length($best_extension) > 15 && $max_SNP < 6)
                                                        {
                                                            $max_SNP = 6;
                                                        }
                                                        if (length($best_extension) > 25 && $max_SNP < 7)
                                                        {
                                                            $max_SNP = 7;
                                                        }
                                                        undef @pos;
                                                        goto VAR_START;
                                                    }
                                                    elsif ($split eq "" && $deletion eq "")
                                                    {               
                                                        if (exists($large_variance_forward{$id}))
                                                        {
                                                            if ($first_without_LV eq "" && $var_recorderd eq '0')
                                                            {
                                                                $first_without_LV = "yes";
                                                                goto WITHOUT_LV;
                                                            }
                                                            elsif ($first_without_LV eq "yes" && $var_recorderd eq '0')
                                                            {
                                                                $first_without_LV = "yes2";
                                                                goto REFERENCE;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            print OUTPUT5 $prev_loc1-$gh."\tLARGE_VARIANCE_FORWARD\n";
                                                            $large_variance_forward{$id} = $prev_loc1;
                                                            $large_variance_tmp = "yes";
                                                            $first_without_LV = "no";
                                                            $save_seq_ref_forward = "";
                                                            delete $no_large_variance_forward{$id};
                                                        }
                                                        last VAR_CHECK;
                                                    }
                                                }
                                                elsif (exists($large_variance_forward{$id}) && $first_without_LV eq "" && $var_recorderd eq '0')
                                                {
                                                    $first_without_LV = "yes";
                                                    goto WITHOUT_LV;    
                                                }
                                                elsif (exists($large_variance_forward{$id}) && $first_without_LV eq "yes" && $var_recorderd eq '0')
                                                {
                                                    $first_without_LV = "yes2";
                                                    goto REFERENCE;
                                                } 
                                                else
                                                {
                                                    $gh++;
                                                    last VAR_CHECK;
                                                }
                                                $d++    
                                            }
                                            last VAR_CHECK;
                                        }
                                        my $length_tmpi = length($best_extension) + $deletion_length0_tmp_save;
                                        
                                        if ($length_tmpi ne $extra_seq_save && $deletion_found ne "")
                                        {
                                            my $diff_length = $extra_seq_save-$length_tmpi;
                                            my $new_extra_seq = substr $extra_seq_save,  0, -$diff_length;
                                            $last_ref_seq_forward{$id} = $last_seq_ref.$new_extra_seq;
                                            if (exists($last_ref_pos_forward{$id}))
                                            {
                                                $last_ref_pos_forward{$id} = $last_ref_pos_forward{$id}+length($new_extra_seq);
                                            }
                                        }
                                        elsif ($deletion ne "")
                                        {
                                            delete $last_ref_seq_forward{$id};
                                            delete $last_ref_pos_forward{$id};
                                        }
NO_LARGE_VARIANCE:
                                        if (exists($large_variance_forward{$id}) && $first_without_LV eq "" && length($best_extension) > 9)
                                        {
                                            $best_extension = substr $read, -($prev_loc1_tmp-$large_variance_forward{$id}),($prev_loc1_tmp-$large_variance_forward{$id});
                                            substr $read, -($prev_loc1_tmp-$large_variance_forward{$id}),($prev_loc1_tmp-$large_variance_forward{$id}),"";
                                            $position -= ($prev_loc1_tmp-$large_variance_forward{$id});
                                            $no_large_variance_forward{$id} = $prev_loc1_tmp;
                                            $position{$id} = $position;   

                                            my $new_last_seq_ref;
                                            my $cc = $large_variance_forward{$id};
                                            while ($cc <= $prev_loc1_tmp-30)
                                            {
                                                $new_last_seq_ref .= $hashref2{$cc};
                                                $cc += 30;
                                            }
                                            my $last_bit = substr $hashref2{$cc}, 0, $prev_loc1_tmp-$cc;
                                            $new_last_seq_ref .= $last_bit;
                                            $last_ref_seq_forward{$id} = $new_last_seq_ref;
                                            delete $last_ref_pos_forward{$id};
                                            $no_large_variance_forward = "yes";
                                            print OUTPUT5 $new_last_seq_ref." NEW_LAST_SEQ_REF\n";
                                            print OUTPUT5 $best_extension." NEW_BEST_EXT\n";
                                            delete $large_variance_forward{$id};
                                            delete $large_variance_length_forward{$id};
                                            $best_extension_tmp = $best_extension;
                                            $ref_check_tmp = $new_last_seq_ref;
                                            $max_SNP = length($best_extension_tmp);
                                            $no_large_variance_forward = $prev_loc1_tmp;
                                            $large_variance_tmp = "";
                                            $save_seq_ref_forward = "no2";
                                            goto VAR_START;
                                        }

                                        if ($save_seq_ref_forward eq "" && $split_forward_tmp eq "")
                                        {
                                            $last_ref_seq_forward{$id} = $last_seq_ref;
                                        }
                                        if ($deletion eq "yes" && $del_detect eq '1')
                                        {
                                            $del_detect = '2';
                                            goto DEL_DETECT;
                                        }
                                        if ($deletion eq "yes")
                                        {
                                            $best_extension = $best_extension_del;
                                            
                                            foreach my $not_linked (keys %not_linked_SNPs)
                                            {
                                                if (exists($linked_SNPs{$not_linked}))
                                                {
                                                    delete $not_linked_SNPs{$not_linked};
                                                    delete $linked_SNPs{$not_linked};
                                                    my $pos_SNPs = $position+$not_linked-$prev_loc1+1;
                                                    $linked_half_SNPs{$not_linked} = $pos_SNPs;
                                                }
                                            }
                                        }
                                        $best_extension_prev{$id} = $best_extension;  
                                        goto AFTER_EXT;
                                    }
                                    print OUTPUT5 $before." BEF_TEST\n";
                                    print OUTPUT5 $deletion." DEL_TEST\n";
                                    my $star_check_end = $read_end =~ tr/\*/\*/;
REF_GUIDED:
                                    if ($hp_seed_assemble eq "" && ($before ne "" || $star_check_end > 0) && ($deletion eq "" || $heteroplasmy eq ""))
                                    {
                                        print OUTPUT5 "FOLLOW_REF\n";
                                        
                                        my $best_extension1_tmp;
                                        my $best_extension2_tmp;
                                        my $best_extension3_tmp;
                                        my $best_extension4_tmp;
                                        if (length($best_extension_old1) > length($best_extension1))
                                        {
                                            $best_extension1_tmp = $best_extension_old1;
                                        }
                                        else
                                        {
                                            $best_extension1_tmp = $best_extension1;
                                        }
                                        if (length($best_extension_old2) > length($best_extension2))
                                        {
                                            $best_extension2_tmp = $best_extension_old2;
                                        }
                                        else
                                        {
                                            $best_extension2_tmp = $best_extension2;
                                        }
                                        if (length($best_extension_old3) > length($best_extension3))
                                        {
                                            $best_extension3_tmp = $best_extension_old3;
                                        }
                                        else
                                        {
                                            $best_extension3_tmp = $best_extension3;
                                        }
                                        if (length($best_extension_old4) > length($best_extension4))
                                        {
                                            $best_extension4_tmp = $best_extension_old4;
                                        }
                                        else
                                        {
                                            $best_extension4_tmp = $best_extension4;
                                        }
                                        
                                        my $best_extension1_part = substr $best_extension1_tmp, 0, 25;
                                        my $best_extension2_part = substr $best_extension2_tmp, 0, 25;
                                        my $best_extension3_part = substr $best_extension3_tmp, 0, 25;
                                        my $best_extension4_part = substr $best_extension4_tmp, 0, 25;
                                        my $best_extension1_partb = substr $best_extension1_tmp, 5, 25;
                                        my $best_extension2_partb = substr $best_extension2_tmp, 5, 25;
                                        my $best_extension3_partb = substr $best_extension3_tmp, 5, 25;
                                        my $best_extension4_partb = substr $best_extension4_tmp, 5, 25;
                                        
                                        my $reference_guided1 = '0';
                                        my $reference_guided2 = '0';
                                        my $reference_guided3 = '0';
                                        my $reference_guided4 = '0';
                                        
                                        my %extensionsb_group1_old_tmp = %extensionsb_group1_old;
                                        my %extensionsb_group2_old_tmp = %extensionsb_group2_old;
                                        my $single_check = "";
                                        my $count_ext1_tmp = '0';
                                        my $count_ext2_tmp = '0';
                                        my $count_ext3_tmp = '0';
                                        my $count_ext4_tmp = '0';
                                        
                                        my %hash_tmp1;
                                        undef %hash_tmp1;
EXT1_PART_single:
                                        foreach my $h_tmp1 (%hash_tmp1)
                                        {
                                            delete $extensionsb_group1_old_tmp{$h_tmp1};
                                        }

                                        if (length($best_extension1_part) > 8)
                                        {
                                            my $ref_check_tmp = $ref_check;
                                            my $best_extension1_part_tmp = $best_extension1_part;
                                            my $steps = '0';
                                            my $cut_ext = '0';
EXT1_PART0:                                 $best_extension1_part_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                            my @line = split //,$best_extension1_part_tmp;
                                            my @ref_check = split //, $ref_check_tmp;
                                            my $gh = '0';
                                            my $th = '0';
    
EXT1_PART:                                  while ($gh < length($ref_check_tmp)-length($best_extension1_part_tmp))
                                            {
                                                my $d = '0';
                                                my $next = '0';
                                                
                                                while ($d < length($best_extension1_part_tmp))
                                                {
                                                    $th = $d + $gh;
                                                    if ($line[$d] eq $ref_check[$th])
                                                    {
                                                    }
                                                    elsif ($ref_check[$th] eq ".")
                                                    {
                                                    }
                                                    elsif ($line[$d] eq ".")
                                                    {
                                                    }
                                                    elsif ($next < length($best_extension1_part_tmp)*0.25)
                                                    {
                                                        $next++;
                                                    }
                                                    else
                                                    {
                                                        $gh++;
                                                        goto EXT1_PART;
                                                    }
                                                    $d++    
                                                }
                                                
                                                $reference_guided1 += $next+($gh/2)+1+$cut_ext;
                                                
                                                if ($reference_guided1 < 25)
                                                {
                                                    $reference_guided = "yes1";
                                                    print OUTPUT5 $reference_guided1." REFERENCE_GUIDED1\n";
                                                    print OUTPUT5 $best_extension1_part_tmp." BEST_EXTENSION1\n\n";
                                                    $best_extension = $best_extension1_tmp;
                                                    last EXT1_PART;
                                                }
                                                else
                                                {
                                                    $reference_guided1 = '0';
                                                    $gh++;
                                                    goto EXT1_PART;
                                                }
                                            }
                                            if ($reference_guided eq "" && $star2 > 0 && ($steps < 1 || ($steps < 2 && $best_extension1_part_tmp eq $best_extension1_partb)))
                                            {
                                                $ref_check_tmp = $ref_check_star;
                                                $steps++;
                                                goto EXT1_PART0;
                                            }
                                            if ($reference_guided eq "" && $cut_ext < 5 && length($best_extension1_tmp)-$cut_ext > 10 && $heteroplasmy eq "" && $single_check eq "")
                                            {
                                                $ref_check_tmp = $ref_check;
                                                $cut_ext++;
                                                $best_extension1_part_tmp = substr $best_extension1_tmp, $cut_ext, 25;
                                                if ($cut_ext eq 5)
                                                {
                                                    $steps += 2;
                                                    if ($star2 > 0)
                                                    {
                                                        $steps--;
                                                    }
                                                }
                                                goto EXT1_PART0;
                                            }
                                        }
                                        if ($reference_guided ne "yes1" && $count_ext1_tmp < 25)
                                        {
                                            foreach my $extensions_group1_id (%extensionsb_group1_old_tmp)
                                            {
                                                my $extensions_group1 = $extensionsb_group1_old_tmp{$extensions_group1_id};
                                                $count_ext1_tmp++;
                                                $hash_tmp1{$extensions_group1_id} = undef;
                                                if (length($extensions_group1) > 15)
                                                {
                                                    my $best_extension1_tmp_6 = substr $best_extension1_tmp, 0, 6;
                                                    if ($extensions_group1 =~ s/$best_extension1_tmp_6/$best_extension1_tmp_6/)
                                                    {
                                                        $best_extension1_part = substr $extensions_group1, 0, 25;
                                                        $single_check = "yes";
                                                        goto EXT1_PART_single;
                                                    }
                                                }  
                                            }
                                        }
                                        $single_check = "";
                                        my %hash_tmp2;
                                        undef %hash_tmp2;
EXT2_PART_single:
                                        foreach my $h_tmp2 (%hash_tmp2)
                                        {
                                            delete $extensionsb_group2_old_tmp{$h_tmp2};
                                        }
                                        if (length($best_extension2_part) > 8)
                                        {
                                            my $ref_check_tmp = $ref_check;
                                            my $best_extension2_part_tmp = $best_extension2_part;
                                            my $steps = '0';
                                            my $cut_ext = '0';
EXT2_PART0:                                 $best_extension2_part_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                            my @line = split //,$best_extension2_part_tmp;
                                            my @ref_check = split //, $ref_check_tmp;
                                            my $gh = '0';
                                            my $th = '0';
    
EXT2_PART:                                  while ($gh < length($ref_check_tmp)-length($best_extension2_part_tmp))
                                            {
                                                my $d = '0';
                                                my $next = '0';
                                                
                                                while ($d < length($best_extension2_part_tmp))
                                                {
                                                    $th = $d + $gh;
                                                    if ($line[$d] eq $ref_check[$th])
                                                    {
                                                    }
                                                    elsif ($ref_check[$th] eq ".")
                                                    {
                                                    }
                                                    elsif ($line[$d] eq ".")
                                                    {
                                                    }
                                                    elsif ($next < length($best_extension2_part_tmp)*0.25)
                                                    {
                                                        $next++;
                                                    }
                                                    else
                                                    {
                                                        $gh++;
                                                        goto EXT2_PART;
                                                    }
                                                    $d++    
                                                }
                                                $reference_guided2 += $next+($gh/2)+1+$cut_ext;
                                                
                                                if ($reference_guided2 > 24)
                                                {
                                                    $reference_guided2 = '0';
                                                    $gh++;
                                                    goto EXT2_PART; 
                                                }
                                                
                                                if ($reference_guided ne "" && ($reference_guided2 > 7*$reference_guided1 || ($reference_guided2 > 4*$reference_guided1 && $reference_guided1 < 2)))
                                                {
                                                    last EXT2_PART;
                                                }
                                                elsif ($reference_guided ne "" && $reference_guided1 > 7*$reference_guided2)
                                                {
                                                    $reference_guided = "";
                                                }
                                                if ($reference_guided eq "")
                                                {
                                                    $reference_guided = "yes2";
                                                }
                                                else
                                                {
                                                    $reference_guided = "yes_both";
                                                }
                                                
                                                print OUTPUT5 $reference_guided2." REFERENCE_GUIDED2\n";
                                                print OUTPUT5 $best_extension2_part_tmp." BEST_EXTENSION2\n\n";
                                                $best_extension = $best_extension2_tmp;
                                                last EXT2_PART;
                                            }
                                            if ($reference_guided2 eq 0 && $star2 > 0 && ($steps < 1 || ($steps < 2 && $best_extension2_part_tmp eq $best_extension2_partb)))
                                            {
                                                $ref_check_tmp = $ref_check_star;
                                                $steps++;
                                                goto EXT2_PART0;
                                            }
                                            if ($reference_guided2 eq 0 && $cut_ext < 5 && length($best_extension2_tmp)-$cut_ext > 10 && $single_check eq "")
                                            {
                                                $ref_check_tmp = $ref_check;
                                                $cut_ext++;
                                                $best_extension2_part_tmp = substr $best_extension2_tmp, $cut_ext, 25;
                                                if ($cut_ext eq 5)
                                                {
                                                    $steps += 2;
                                                    if ($star2 > 0)
                                                    {
                                                        $steps--;
                                                    }
                                                }
                                                goto EXT2_PART0;
                                            }
                                        }
                                        if ($reference_guided ne "yes2" && $reference_guided ne "yes_both" && $count_ext2_tmp < 25)
                                        {
                                            foreach my $extensions_group2_id (%extensionsb_group2_old_tmp)
                                            {
                                                my $extensions_group2 = $extensionsb_group2_old_tmp{$extensions_group2_id};
                                                $count_ext2_tmp++;
                                                $hash_tmp2{$extensions_group2_id} = undef;
                                                if (length($extensions_group2) > 15)
                                                {
                                                    my $best_extension2_tmp_6 = substr $best_extension2_tmp, 0, 6;
                                                    if ($extensions_group2 =~ s/$best_extension2_tmp_6/$best_extension2_tmp_6/)
                                                    {
                                                        $best_extension2_part = substr $extensions_group2, 0, 25;
                                                        $single_check = "yes";
                                                        goto EXT2_PART_single;
                                                    }
                                                }
                                            }
                                        }
                                        if ($count_split > 2)
                                        {
                                            if (length($best_extension3_part) > 8)
                                            {
                                                my $ref_check_tmp = $ref_check;
                                                my $best_extension3_part_tmp = $best_extension3_part;
                                                my $steps = '0';
                                                my $cut_ext = '0';
        EXT3_PART0:                             $best_extension3_part_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                my @line = split //,$best_extension3_part_tmp;
                                                my @ref_check = split //, $ref_check_tmp;
                                                my $gh = '0';
                                                my $th = '0';
        
        EXT3_PART:                              while ($gh < length($ref_check_tmp)-length($best_extension3_part_tmp))
                                                {
                                                    my $d = '0';
                                                    my $next = '0';
                                                    
                                                    while ($d < length($best_extension3_part_tmp))
                                                    {
                                                        $th = $d + $gh;
                                                        if ($line[$d] eq $ref_check[$th])
                                                        {
                                                        }
                                                        elsif ($ref_check[$th] eq ".")
                                                        {
                                                        }
                                                        elsif ($line[$d] eq ".")
                                                        {
                                                        }
                                                        elsif ($next < length($best_extension3_part_tmp)*0.25)
                                                        {
                                                            $next++;
                                                        }
                                                        else
                                                        {
                                                            $gh++;
                                                            goto EXT3_PART;
                                                        }
                                                        $d++    
                                                    }
                                                    $reference_guided3 += $next+($gh/2)+1+$cut_ext;
                                                    
                                                    if ($reference_guided3 > 24)
                                                    {
                                                        $reference_guided3 = '0';
                                                        $gh++;
                                                        goto EXT3_PART; 
                                                    }
                                                
                                                    if ($reference_guided ne "" && $reference_guided3 > 7*$reference_guided1 && $reference_guided3 > 7*$reference_guided2)
                                                    {
                                                        last EXT3_PART;
                                                    }
                                                    elsif ($reference_guided eq "yes1" && $reference_guided1 > 7*$reference_guided3)
                                                    {
                                                        $reference_guided = "";
                                                    }
                                                    elsif ($reference_guided eq "yes2" && $reference_guided2 > 7*$reference_guided3)
                                                    {
                                                        $reference_guided = "";
                                                    }
                                                    if ($reference_guided eq "")
                                                    {
                                                        $reference_guided = "yes3";
                                                    }
                                                    else
                                                    {
                                                        $reference_guided = "yes_both";
                                                    }
                                                    
                                                    print OUTPUT5 $reference_guided3." REFERENCE_GUIDED3\n";
                                                    print OUTPUT5 $best_extension3_part_tmp." BEST_EXTENSION3\n\n";
                                                    $best_extension = $best_extension3_tmp;
                                                    last EXT3_PART;
                                                }
                                                if ($reference_guided3 eq 0 && $star2 > 0 && ($steps < 1 || ($steps < 2 && $best_extension3_part_tmp eq $best_extension3_partb)))
                                                {
                                                    $ref_check_tmp = $ref_check_star;
                                                    $steps++;
                                                    goto EXT3_PART0;
                                                }
                                                if ($reference_guided3 eq 0 && $cut_ext < 5 && length($best_extension3_tmp)-$cut_ext > 10)
                                                {
                                                    $ref_check_tmp = $ref_check;
                                                    $cut_ext++;
                                                    $best_extension3_part_tmp = substr $best_extension3_tmp, $cut_ext, 25;
                                                    if ($cut_ext eq 5)
                                                    {
                                                        $steps += 2;
                                                        if ($star2 > 0)
                                                        {
                                                            $steps--;
                                                        }
                                                    }
                                                    goto EXT3_PART0;
                                                }
                                            }
                                            if ($reference_guided ne "yes3" && $reference_guided ne "yes_both")
                                            {
    EXT3_PART_single:                           foreach my $extensions_group3_id (%extensionsb_group3_old)
                                                {
                                                    my $extensions_group3 = $extensionsb_group3_old{$extensions_group3_id};
                                                    if (length($extensions_group3) > 15)
                                                    {
                                                        my $best_extension3_tmp_6 = substr $best_extension3_tmp, 0, 6;
                                                        if ($extensions_group3 =~ s/$best_extension3_tmp_6/$best_extension3_tmp_6/)
                                                        {
                                                            my $extensions_group3_part = substr $extensions_group3, 0, 25;
                                                            my @ref2_single = build_partialb_4dots $extensions_group3_part;
                                                            foreach my $best_extension3_part2_single (@ref2_single)
                                                            {                                    
                                                                my $ref_check_tmp = $ref_check;
                                                                my $ref_check_tmp2 = $ref_check_star;
                                                                if ($ref_check_tmp =~ s/$best_extension3_part2_single/$best_extension3_part2_single/ || $ref_check_tmp2 =~ s/$best_extension3_part2_single/$best_extension3_part2_single/)
                                                                {   
                                                                    if ($reference_guided eq "")
                                                                    {
                                                                        $reference_guided = "yes3";
                                                                    }
                                                                    else
                                                                    {
                                                                        $reference_guided = "yes_both";
                                                                    }
                                                                    print OUTPUT5 "REFERENCE_GUIDED3c\n";
                                                                    print OUTPUT5 $extensions_group3." BEST_EXTENSION3_single\n\n";
                                                                    $best_extension = $best_extension3_tmp;
                                                                    last EXT3_PART_single;
                                                                }
                                                            }
                                                            undef @ref2_single;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if ($count_split > 3)
                                        {
                                            if (length($best_extension4_part) > 12)
                                            {
                                                my $ref_check_tmp = $ref_check;
                                                my $best_extension4_part_tmp = $best_extension4_part;
                                                my $steps = '0';
                                                my $cut_ext = '0';
    EXT4_PART0:                                 $best_extension4_part_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                my @line = split //,$best_extension4_part_tmp;
                                                my @ref_check = split //, $ref_check_tmp;
                                                my $gh = '0';
                                                my $th = '0';
        
    EXT4_PART:                                  while ($gh < length($ref_check_tmp)-length($best_extension4_part_tmp))
                                                {
                                                    my $d = '0';
                                                    my $next = '0';
                                                    
                                                    while ($d < length($best_extension4_part_tmp))
                                                    {
                                                        $th = $d + $gh;
                                                        if ($line[$d] eq $ref_check[$th])
                                                        {
                                                        }
                                                        elsif ($ref_check[$th] eq ".")
                                                        {
                                                        }
                                                        elsif ($line[$d] eq ".")
                                                        {
                                                        }
                                                        elsif ($next < length($best_extension4_part_tmp)*0.25)
                                                        {
                                                            $next++;
                                                        }
                                                        else
                                                        {
                                                            $gh++;
                                                            goto EXT4_PART;
                                                        }
                                                        $d++    
                                                    }
                                                    $reference_guided4 += $next+($gh/2)+1+$cut_ext;
                                                    
                                                    if ($reference_guided4 > 24)
                                                    {
                                                        $reference_guided4 = '0';
                                                        $gh++;
                                                        goto EXT4_PART; 
                                                    }
                                                    
                                                    if ($reference_guided ne "" && $reference_guided4 > 7*$reference_guided1 && $reference_guided4 > 7*$reference_guided2)
                                                    {
                                                        last EXT4_PART;
                                                    }
                                                    elsif ($reference_guided eq "yes1" && $reference_guided1 > 7*$reference_guided4)
                                                    {
                                                        $reference_guided = "";
                                                    }
                                                    elsif ($reference_guided eq "yes2" && $reference_guided2 > 7*$reference_guided4)
                                                    {
                                                        $reference_guided = "";
                                                    }
                                                    elsif ($reference_guided eq "yes3" && $reference_guided3 > 7*$reference_guided4)
                                                    {
                                                        $reference_guided = "";
                                                    }
                                                    if ($reference_guided eq "")
                                                    {
                                                        $reference_guided = "yes4";
                                                    }
                                                    else
                                                    {
                                                        $reference_guided = "yes_both";
                                                    }
                                                    
                                                    print OUTPUT5 $reference_guided4." REFERENCE_GUIDED4\n";
                                                    print OUTPUT5 $best_extension4_part_tmp." BEST_EXTENSION4\n\n";
                                                    $best_extension = $best_extension4_tmp;
                                                    last EXT4_PART;
                                                }
                                                if ($reference_guided4 eq 0 && $star2 > 0 && ($steps < 1 || ($steps < 2 && $best_extension4_part_tmp eq $best_extension4_partb)))
                                                {
                                                    $ref_check_tmp = $ref_check_star;
                                                    $steps++;
                                                    goto EXT4_PART0;
                                                }
                                                if ($reference_guided4 eq 0 && $cut_ext < 5 && length($best_extension4_tmp)-$cut_ext > 10)
                                                {
                                                    $ref_check_tmp = $ref_check;
                                                    $cut_ext++;
                                                    $best_extension4_part_tmp = substr $best_extension4_tmp, $cut_ext, 25;
                                                    if ($cut_ext eq 5)
                                                    {
                                                        $steps += 2;
                                                        if ($star2 > 0)
                                                        {
                                                            $steps--;
                                                        }
                                                    }
                                                    goto EXT4_PART0;
                                                }
                                            }
                                            if ($reference_guided ne "yes4" && $reference_guided ne "yes_both")
                                            {
    EXT4_PART_single:                           foreach my $extensions_group4_id (%extensionsb_group4_old)
                                                {
                                                    my $extensions_group4 = $extensionsb_group4_old{$extensions_group4_id};
                                                    if (length($extensions_group4) > 15)
                                                    {
                                                        my $best_extension4_tmp_6 = substr $best_extension4_tmp, 0, 6;
                                                        if ($extensions_group4 =~ s/$best_extension4_tmp_6/$best_extension4_tmp_6/)
                                                        {
                                                            my $extensions_group4_part = substr $extensions_group4, 0, 25;
                                                            my @ref2_single = build_partialb_4dots $extensions_group4_part;
                                                            foreach my $best_extension4_part2_single (@ref2_single)
                                                            {                                    
                                                                my $ref_check_tmp = $ref_check;
                                                                my $ref_check_tmp2 = $ref_check_star;
                                                                if ($ref_check_tmp =~ s/$best_extension4_part2_single/$best_extension4_part2_single/ || $ref_check_tmp2 =~ s/$best_extension4_part2_single/$best_extension4_part2_single/)
                                                                {   
                                                                    if ($reference_guided eq "")
                                                                    {
                                                                        $reference_guided = "yes4";
                                                                    }
                                                                    else
                                                                    {
                                                                        $reference_guided = "yes_both";
                                                                    }
                                                                    print OUTPUT5 "REFERENCE_GUIDED4c\n";
                                                                    print OUTPUT5 $extensions_group4." BEST_EXTENSION4_single\n\n";
                                                                    $best_extension = $best_extension4_tmp;
                                                                    last EXT4_PART_single;
                                                                }
                                                            }
                                                            undef @ref2_single;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if ($reference_guided eq "yes_both")
                                        {
                                            $best_extension = "";
                                            $reference_guided = "";
                                            goto INDELa0
                                        }
                                        elsif ($reference_guided ne "")
                                        {
                                            if ($reference_guided eq "yes1")
                                            {
                                                $best_extension2 = "";
                                                $best_extension3 = "";
                                                $best_extension4 = "";
                                            }
                                            elsif ($reference_guided eq "yes2")
                                            {
                                                $best_extension1 = "";
                                                $best_extension3 = "";
                                                $best_extension4 = "";
                                            }
                                            elsif ($reference_guided eq "yes3")
                                            {
                                                $best_extension1 = "";
                                                $best_extension2 = "";
                                                $best_extension4 = "";
                                            }
                                            elsif ($reference_guided eq "yes4")
                                            {
                                                $best_extension1 = "";
                                                $best_extension3 = "";
                                                $best_extension2 = "";
                                            }
                                            $reference_guided = "yes";
                                            $split = "";
                                            delete $jump_rep{$id};
                                            goto AFTER_EXT;
                                        }
                                        else
                                        {
                                            $best_extension = "";
                                        }
                                    }
                                }
                            }
                            last CHECK_REF;
                        }
                        elsif (length($read) > 1100 && @ref_id3 > 1 && $p < $p_prev-15)
                        {
CHECK_BACK_REF0:            $p_prev = $p;
                            my $length_back = '1000';
                            if ($further eq "yes")
                            {
                                $length_back = '5000';
                            }
                            elsif ($further eq "yes2")
                            {
                                $length_back = '10000';
                            }
                            elsif ($further eq "yes3")
                            {
                                $length_back = '20000';
                            }
                            my $read_part_back = substr $read, -$length_back-$p-150, 200;
                            my @ref_id3_new;
                            undef  @ref_id3_new;
                            my $ref_part_tmp2;
CHECK_BACK_REF:             foreach my $ref_id (@ref_id3)
                            {
                                $ref_part_tmp2 = $ref_id3{$ref_id};
                                if (exists($hashref2{$ref_id-$length_back}))
                                {
                                    my $ref_part_back  = $hashref2{$ref_id-$length_back};
                                    print OUTPUT5 $ref_part_back. " REF_PART_BACK\n";
                                    my @ref_part_back = build_partialb_4dots $ref_part_back;
                                    foreach my $ref_part_back_tmp (@ref_part_back)
                                    {
                                        my $found = $read_part_back =~ s/$ref_part_back_tmp/$ref_part_back_tmp/;
                                        if ($found > 0)
                                        {                                           
                                            push @ref_id3_new, $ref_id;
                                            next CHECK_BACK_REF;
                                        }
                                    }
                                    undef @ref_part_back;
                                }
                            }
                            if (@ref_id3_new eq 1)
                            {
                                undef @ref_id3;
                                @ref_id3 = @ref_id3_new;
                                $found_further_back = "yes";
                                $ref_part_prev = $ref_part_tmp2;
                            }
                            elsif ($further eq "" && length($read) > 5200-$p)
                            {
                                $further = "yes";
                                goto CHECK_BACK_REF0;
                            }
                            elsif ($further eq "yes" && length($read) > 10200-$p)
                            {
                                $further = "yes2";
                                goto CHECK_BACK_REF0;
                            }
                            elsif ($further eq "yes2" && length($read) > 20200-$p)
                            {
                                $further = "yes3";
                                goto CHECK_BACK_REF0;
                            }
                            else
                            {
                                undef @ref_id3;
                            }
                        } 
                        $p--;
                    }
                    if ($reference_next_seed eq "yes")
                    {
                        $noforward = "stop";
                        $noforward{$id} = "stop";
                        print OUTPUT5 "REFERENCE_NEXT_SEED\n";
                        goto FINISH;
                    }
                    if (($variance_detection eq "yes" || $heteroplasmy ne "") && $split eq "" && $repetitive_detect eq "")
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 $best_extension." BEST_EXTENSION\n\n";
                        }
                        $best_extension_prev{$id} = $best_extension;
                        goto AFTER_EXT;
                    }
                }
                elsif ($best_extension ne "")
                {
                    delete $last_ref_seq_forward{$id};
                    delete $last_ref_pos_forward{$id} 
                }
INDELa0:
                if (((length($best_extension1) > 4 && length($best_extension2) > 4) || (length($best_extension_old1) > 4 && length($best_extension_old2) > 4)) && $cp_input ne "" && $type eq "mito_plant" && $reference_guided eq "" && $deletion eq "")
                {
                    my $p = -35;
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "CHECK_CHLOROPLAST SEQUENCE\n\n";
                    }                   
                    while ($p > (-35*2))
                    {
                        my $ref_part2 = substr $read_short_end2, $p, 35;
                        my %ref_part = build_partial3b $ref_part2, "";
                        
                        foreach my $ref_part (keys %ref_part)
                        {
                            if (exists($cp_ref{$ref_part}))
                            {                            
                                my $ref_loc = -$p;
                                
                                my $ref_id3 = $cp_ref{$ref_part};      
                                my $ref_id2 = substr $ref_id3, 1;
                                my @ref_id3 = split /,/,$ref_id2;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $ref_part." EXISTS ".$ref_loc." LOC ".$ref_id3." LOC_REF\n";
                                }
                           
                                foreach my $ref_id (@ref_id3)
                                {
                                    my $prev_loc1 = $ref_id + $ref_loc;
                                    
                                    if (exists($cp_ref2{$prev_loc1}))
                                    {
                                        my $ref_check = $cp_ref2{$prev_loc1};
                                        print OUTPUT5 $ref_check." EXISTSREF1\n";
                                        
                                        my $best_extension1_tmp;
                                        my $best_extension2_tmp;
                                        if (length($best_extension_old1) > length($best_extension1) && length($best_extension_old2) > length($best_extension2))
                                        {
                                            $best_extension1_tmp = $best_extension_old1;
                                            $best_extension2_tmp = $best_extension_old2;
                                        }
                                        else
                                        {
                                            $best_extension1_tmp = $best_extension1;
                                            $best_extension2_tmp = $best_extension2;
                                        }
                                        my $best_extension1_part = substr $best_extension1_tmp, 0, 25;
                                        my $best_extension2_part = substr $best_extension2_tmp, 0, 25;
                                     
                                        if (length($best_extension1_part) > 10)
                                        {                                  
                                            my $ref_check_tmp = $ref_check;
                                            if ($ref_check_tmp =~ s/$best_extension1_part/$best_extension1_part/)
                                            {    
                                                print OUTPUT5 "REFERNCE_GUIDED_CP\n";
                                                print OUTPUT5 $best_extension2_tmp." BEST_EXTENSION2n\n";
                                                $best_extension = $best_extension2_tmp;
                                                $reference_guided = "yes1";
                                            }
                                        }
                                        if (length($best_extension2_part) > 10)
                                        {
                                            my $ref_check_tmp = $ref_check;
                                            if ($ref_check_tmp =~ s/$best_extension2_part/$best_extension2_part/)
                                            {                                           
                                                $best_extension = $best_extension1_tmp;
                                                if ($reference_guided eq "")
                                                {
                                                    $reference_guided = "yes2";
                                                }
                                                else
                                                {
                                                    $reference_guided = "yes_both";
                                                }
                                                print OUTPUT5 $reference_guided." REFERNCE_GUIDED_CP\n";
                                                print OUTPUT5 $best_extension1_tmp." BEST_EXTENSION1\n\n";
                                            }
                                        }
                                        if ($reference_guided eq "yes_both")
                                        {
                                            $best_extension = "";
                                            $reference_guided = "";
                                            goto INDEL;
                                        }
                                        elsif ($reference_guided ne "")
                                        {
                                            if ($reference_guided eq "yes1")
                                            {
                                                $best_extension2 = "";
                                            }
                                            elsif ($reference_guided eq "yes2")
                                            {
                                                $best_extension1 = "";
                                            }
                                            $reference_guided = "yes";
                                            $split = "";
                                            goto AFTER_EXT;
                                        }
                                        else
                                        {
                                            $best_extension = "";
                                        }
                                    }
                                }                        
                            }
                        }
                        $p--;
                    }
                }

INDEL:
                $split_forward  = "yes";
                my $star_check_end = $read_end =~ tr/\*/\*/;
                
                if ($jump_rep eq "yes" || $jump_rep_because_stuck eq "yes" || ($extensions_before ne "yes" && $contig_end ne "yes" && ($delete_first eq "" || $delete_second eq "" || $delete_third eq "")
                && $before ne "yes" && $reference_guided ne "yes" && $SNR_critical eq "" && ($heteroplasmy eq "" || $hp_seed_assemble ne "" || $SNP_active ne "")) && $star_check_end eq '0')
                {                   
                    $before{$id} = "yes";
                    $before = "yes";
                    $count1b_tmp = '0';
                    $count2b_tmp = '0';
                    $count3b_tmp = '0';
                    $count4b_tmp = '0';
                    my $before_shorter = "";
                    my $max_overhang_hp = '0';
                    if ($hp_seed_assemble ne "")
                    {
                        foreach my $SNP_tmp (keys %SNPs)
                        {
                            if ($SNP_tmp > $position-$read_length && ($read_length-($position-$SNP_tmp)-1) > $max_overhang_hp)
                            {
                                $max_overhang_hp = $read_length-($position-$SNP_tmp)-1
                            }
                        }
                    }
                    my $overhangb = ($read_length/$ext_total)*8;
                    if ($overhangb < 1+($read_length/40))
                    {
                        $overhangb = 1+($read_length/40);
                    }
                    if ($overhangb > 1+($read_length/1.5))
                    {
                        $overhangb = 1+($read_length/1.5);
                    }
                    if ($type eq "mito_plant" && $hp_seed_assemble eq "")
                    {
                        $overhangb += 2;
                        if ($ext_total > $average_coverage_ext*2)
                        {
                            $overhangb += 4;
                        }
                    }
                    my $overhang = sprintf("%.0f", $overhangb);
                    delete $jump_rep{$id};
                    
                    my $overhang_for_pairs = $overhang;
                    if ($overhang_for_pairs > 35 && $average_coverage_ext > 20)
                    {
                        $overhang = 35;
                    }
                    if ($overhang_for_pairs > 20 && $average_coverage_ext > 65)
                    {
                        $overhang = 20;
                    }     
                    if ($overhang < 10)
                    {
                        $overhang = 10;
                    }
                    $overhang_check = $overhang;
BEFORE:
                    my $s = '0';
                    
                    if ($before_shorter eq "yes")
                    {
                        $overhang += 5;
                    }
                    if ($before_shorter eq "yes2")
                    {
                        $overhang += 20;
                    }
                    $before_shorter = "";

                    print OUTPUT5 $overhang." OVERHANG\n";
                    my @extensions_yuyu;
                    my %extensions_yuyu;
                    my %before1F;
                    my %before2F;
                    my %before3F;
                    my %before4F;
                    my %before1B;
                    my %before2B;
                    my %before3B;
                    my %before4B;
                    my %filter_before1;
                    my %filter_before2;
                    my %filter_before3;
                    my %filter_before4;
                    undef @extensions_yuyu;
                    undef %extensions_yuyu;
                    undef %before1F;
                    undef %before2F;
                    undef %before3F;
                    undef %before4F;
                    undef %before1B;
                    undef %before2B;
                    undef %before3B;
                    undef %before4B;
                    undef %filter_before1;
                    undef %filter_before2;
                    undef %filter_before3;
                    undef %filter_before4;
                    undef %repetitive_pair;
                    
                    my $skip_overhang = "";
                    if ($AT_rich_before eq "yes")
                    {
                        my $before_split_tmp = substr $read_short_end2, -($read_length-$overhang);
                        $skip_overhang = AT_rich_test ($before_split_tmp, '3');
                        if ($skip_overhang eq "yes")
                        {
                            print OUTPUT5 $skip_overhang." SKIP OVERHANG\n";
                            $overhang -= 5;
                        }
                    }
                    my $first_nuc1 = substr $best_extension1, 0, 1;
                    my $first_nuc2 = substr $best_extension2, 0, 1;
                    my $first_nuc3 = substr $best_extension3, 0, 1;
                    my $first_nuc4 = substr $best_extension4, 0, 1;

                    foreach my $id_tmp (keys %extensions_for_before)
                    {
                        if (length($extensions_for_before{$id_tmp}) <= $overhang)
                        {
                            my $extensions_for_before2 = $extensions_for_before_match{$id_tmp};
                            if ($use_quality ne "")
                            {
                                if (exists($merged_match1{$id_tmp}))
                                {
                                    $extensions_for_before2 =~ tr/1234ACTG/TGACTGAC/;
                                }
                                elsif (exists($merged_match2{$id_tmp}))
                                {
                                    $extensions_for_before2 =~ tr/1234/ACTG/;
                                }
                            }
                            elsif (exists($merged_match1{$id_tmp}))
                            {
                                $extensions_for_before2 =~ tr/ACTG1234/TGACTGAC/;
                            }
                            substr $extensions_for_before2, -length($extensions_for_before{$id_tmp}),length($extensions_for_before{$id_tmp}),"";
                            
                            my $first_nuc = substr $extensions_for_before{$id_tmp}, 0, 1;
                            if ($first_nuc eq $first_nuc1 && $first_nuc ne "")
                            {
                                $before1B{$id_tmp} = reverse($extensions_for_before2);
                                $extensions_yuyu{$id_tmp} = $extensions_for_before{$id_tmp};
                            }
                            elsif ($first_nuc eq $first_nuc2 && $first_nuc ne "")
                            {
                                $before2B{$id_tmp} = reverse($extensions_for_before2);
                                $extensions_yuyu{$id_tmp} = $extensions_for_before{$id_tmp}
                            }
                            elsif ($first_nuc eq $first_nuc3 && $count_split > 2 && $first_nuc ne "")
                            {
                                $before3B{$id_tmp} = reverse($extensions_for_before2);
                                $extensions_yuyu{$id_tmp} = $extensions_for_before{$id_tmp}
                            }
                            elsif ($first_nuc eq $first_nuc4 && $count_split > 3 && $first_nuc ne "")
                            {
                                $before4B{$id_tmp} = reverse($extensions_for_before2);
                                $extensions_yuyu{$id_tmp} = $extensions_for_before{$id_tmp}
                            }
                        }        
                    }   
                    if ($last_chance ne "yes")
                    { 
                        my $overhang_tmp = $overhang;
                        if ($hp_seed_assemble ne "")
                        {
                            $overhang_tmp = $max_overhang_hp;
                        }
                        $s = '0';
                        my $before_split = substr $read_short_end2, -($read_length-$left-1), $overhang_tmp+$overlap;
                        my $star3 = '0';
                        if ($containX_short_end2 > 0)
                        {
                            my $before_split2 = substr $read_short_end2, -($read_length-$left-1);
                            $star3 = $before_split2 =~ tr/\*//;
                            if ($star3 > 0)
                            {
                                $before_split = substr $read_short_end2, -($read_length-$left-1+($star3*2)), $overhang_tmp+$overlap+($star3*2);
                            }
                        }
                        while ($s <= length($before_split)-$overlap)
                        {
                            my $line_tmp = substr $before_split, $s, $overlap;
                            if ($star3 > 0)
                            {
                                my $star = $line_tmp =~ tr/\*//;
                                $line_tmp = substr $before_split, $s, $overlap+($star*2);
                                my $star2 = $line_tmp =~ tr/\*//;                                                
                                while ($star2 > $star)
                                {
                                    $line_tmp = substr $before_split, $s, $overlap+($star2*2);
                                    $star = $star2;
                                    $star2 = $line_tmp =~ tr/\*//;
                                }   
                            }
                            my %line_tmp = build_partial3b $line_tmp, "";
                            foreach my $line (keys %line_tmp)
                            {
                                if (exists($hash2b{$line}))
                                {                       
                                    my $search0 = $hash2b{$line};
                                    my $search_rev;
                                    $search0 = substr $search0, 1;
                                    my @search = split /,/,$search0;
                                                                                
                                    foreach my $search (@search)
                                    {                             
                                        my $search_tmp = substr $search, 0, -1;
                                        my $search_end = substr $search, -1;
                                        if (exists($hash{$search_tmp}))
                                        {
                                            my @search_tmp = split /,/,$hash{$search_tmp};
                                            my $found;
                                            my $found_rev;
                                            if ($search_end eq "1")
                                            {
                                                $found = $search_tmp[0];
                                                $found_rev = $search_tmp[1];
                                                $search_rev = $search_tmp."2";
                                            }
                                            elsif ($search_end eq "2")
                                            {
                                                $found = $search_tmp[1];
                                                $found_rev = $search_tmp[0];
                                                $search_rev = $search_tmp."1";
                                            }
                                            if ($use_quality ne "")
                                            {
                                                $found =~ tr/1234/ACTG/;
                                                $found_rev =~ tr/1234/ACTG/;
                                            }
                                            if ($encrypt eq "yes")
                                            {
                                                $found = decrypt $found;
                                                $found_rev = decrypt $found_rev;
                                            }
                   
                                            my $found_new;
                                            my $first_nuc;
                                            my $last_10 = substr $found, -(11+$s), 10;
                                            my $last_10b = substr $found,  -(11+$s-($star3)), 10;
                                            my $last_10c = substr $found,  -(11+$s-($star3*2)), 10;
                                            
                                            my $last_10_read_end = substr $read_end, -9;
                                            my $check_last10 = $last_10 =~ s/(.)$last_10_read_end/$1$last_10_read_end/;
                                            my $check_last10b = $last_10b =~ s/(.)$last_10_read_end/$1$last_10_read_end/;
                                            my $check_last10c = $last_10c =~ s/(.)$last_10_read_end/$1$last_10_read_end/;
                                            if ($check_last10 > 0)
                                            {
                                                $found_new = substr $found, 0, -(1+$s), "";
                                                $first_nuc = substr $found, 0, 1;
                                            }
                                            elsif ($check_last10b > 0)
                                            {
                                                $found_new = substr $found, 0, -(1+$s-($star3)),"";
                                                $first_nuc = substr $found,  0, 1;
                                            }
                                            elsif ($check_last10c > 0)
                                            {
                                                $found_new = substr $found, 0, -(1+$s-($star3*2)),"";
                                                $first_nuc = substr $found,  0, 1;
                                            }
                                            if ($check_last10 > 0 || $check_last10b > 0 || $check_last10c > 0)
                                            {
                                                my $first_nuc1 = substr $best_extension1, 0, 1;
                                                my $first_nuc2 = substr $best_extension2, 0, 1;
                                                my $first_nuc3 = substr $best_extension3, 0, 1;
                                                my $first_nuc4 = substr $best_extension4, 0, 1;
                                                my $extension_yuyu = $found;
                                                $extensions_yuyu{$search} = $extension_yuyu;
    
                                                if ($first_nuc eq $first_nuc1 && ($check_last10 > 0 || $check_last10b > 0 || $check_last10c > 0) && $first_nuc ne "")
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                    }
                                                    my $found_tmp = reverse($found_new);
                                                    $before1F{$search} = $found_tmp;
                                                    $found_rev  =~ tr/ACTG/TGAC/;
                                                    my $found_rev2 = reverse($found_rev);
                                                    $repetitive_pair{$found_rev2} = $search_rev;
                                                }
                                                elsif ($first_nuc eq $first_nuc2 && ($check_last10 > 0 || $check_last10b > 0 || $check_last10c > 0) && $first_nuc ne "")
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                    }
                                                    my $found_tmp = reverse($found_new);
                                                    $before2F{$search} = $found_tmp;
                                                    $found_rev  =~ tr/ACTG/TGAC/;
                                                    my $found_rev2 = reverse($found_rev);
                                                    $repetitive_pair{$found_rev2} = $search_rev;
                                                }
                                                elsif ($first_nuc eq $first_nuc3 && ($check_last10 > 0 || $check_last10b > 0 || $check_last10c > 0) && $first_nuc ne "")
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                    }
                                                    my $found_tmp = reverse($found_new);
                                                    $before3F{$search} = $found_tmp;
                                                    $found_rev  =~ tr/ACTG/TGAC/;
                                                    my $found_rev2 = reverse($found_rev);
                                                    $repetitive_pair{$found_rev2} = $search_rev;
                                                }
                                                elsif ($first_nuc eq $first_nuc4 && ($check_last10 > 0 || $check_last10b > 0 || $check_last10c > 0) && $first_nuc ne "")
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                    }
                                                    my $found_tmp = reverse($found_new);
                                                    $before4F{$search} = $found_tmp;
                                                    $found_rev  =~ tr/ACTG/TGAC/;
                                                    my $found_rev2 = reverse($found_rev);
                                                    $repetitive_pair{$found_rev2} = $search_rev;
                                                }
                                                if ($save_reads ne "")
                                                {                                  
                                                    my $add_read = $search_tmp;
                                                    $save_reads{$add_read} = undef;
                                                }
    
                                            }
                                        }
                                    }
                                }
                            }
                            $s++;
                        }
                    }
                    my %before_all1 = (%before1B, %before1F);
                    my %before_all2 = (%before2B, %before2F);
                    my %before_all3 = (%before3B, %before3F);
                    my %before_all4 = (%before4B, %before4F);
                    my @keys1 = keys %before_all1;
                    my @keys2 = keys %before_all2;
                    my @keys3 = keys %before_all3;
                    my @keys4 = keys %before_all4;

                    if ($y > $startprint2)
                    {
                        print OUTPUT5 @keys1." COUNT_TEST1\n";
                        print OUTPUT5 @keys2." COUNT_TEST2\n";
                        print OUTPUT5 @keys3." COUNT_TEST3\n";
                        print OUTPUT5 @keys4." COUNT_TEST4\n";
                    }


                    my $end_short_tmp = substr $read_short_end2, -($read_length+20);

BEFORE_EXTRA:       
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $end_short_tmp." END_SHORT_TMP\n\n";
                        print OUTPUT5 reverse($end_short_tmp)." REVERSE_END_SHORT_TMP\n\n";
                    }
                    my $first_yuyu2 = '0';
                    my $second_yuyu2 = '0';
                    my $third_yuyu2 = '0';
                    my $fourth_yuyu2 = '0';
                    my $count1_pair = '0';
                    my $count2_pair = '0';
                    my $count3_pair = '0';
                    my $count4_pair = '0';
                    my @filter_dot_before1;
                    my @filter_dot_before2;
                    my @filter_dot_before3;
                    my @filter_dot_before4;
                    my @extensions_before;
                    my @extensions_before1;
                    my @extensions_before2;
                    my @extensions_before3;
                    my @extensions_before4;
                    undef @filter_dot_before1;
                    undef @filter_dot_before2;
                    undef @filter_dot_before3;
                    undef @filter_dot_before4;
                    undef @extensions_before;
                    undef @extensions_before1;
                    undef @extensions_before2;
                    undef @extensions_before3;
                    undef @extensions_before4;

                                       
                    foreach my $search (keys %before_all2)
                    {
                        my $yuyu0 = $before_all2{$search};
                        my $yuyu2 = reverse($yuyu0);
                        $yuyu2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        if (length($yuyu2) >= $read_length-$overhang)
                        {
                            my $end_short_tmp_part = substr $end_short_tmp, -length($yuyu2)+1;
                            my $end_short_tmp_part2;
                            my $star = $end_short_tmp_part =~ tr/\*//;
                            my $check_yuyuy2b2 = '0';
                            if ($star > 0)
                            {
                                $end_short_tmp_part = substr $end_short_tmp, -length($yuyu2)+1-($star*2);
                                $end_short_tmp_part2 = substr $end_short_tmp, -length($yuyu2)+1-($star);
                                my $yuyu2_tmp2 = $yuyu2;
                                $check_yuyuy2b2 = $yuyu2_tmp2 =~ s/.$end_short_tmp_part2/$end_short_tmp_part2/;
                            }      
                            my $yuyu2_tmp3 = $yuyu2;
                            my $check_yuyuy2b = $yuyu2_tmp3 =~ s/.$end_short_tmp_part/$end_short_tmp_part/;
                            if ($check_yuyuy2b > 0 || $check_yuyuy2b2 > 0)
                            {
                                $second_yuyu2++;
                                push @filter_dot_before2, $yuyu0;
                                if (exists($extensions_yuyu{$search}))
                                {     
                                    if ($y > $startprint2)
                                    {
                                    }
                                    push @extensions_before, $extensions_yuyu{$search};
                                    push @extensions_before2, $extensions_yuyu{$search};
                                }
                                if (exists($extensions_for_before_match_pair{$search}))
                                {
                                    my $temp = $extensions_for_before_match_pair{$search};
                                    if ($use_quality ne "")
                                    {
                                        $temp =~ tr/1234/ACTG/;
                                    }
                                    $filter_before2{$search} = $temp;
                                    $count2_pair++;
                                    if ($y > $startprint2 && @keys2 < 100)
                                    {
                                    }
                                }
                            }
                        }
                    }
                    foreach my $search (keys %before_all1)
                    {
                        my $yuyu0 = $before_all1{$search};
                        my $yuyu1 = reverse($yuyu0);
                        
                        if (length($yuyu1) >= $read_length-$overhang)
                        {
                            $yuyu1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                            my $end_short_tmp_part = substr $end_short_tmp, -length($yuyu1)+1;
                            my $star = $end_short_tmp_part =~ tr/\*//;
                            my $check_yuyuy1b2 = '0';
                            my $end_short_tmp_part2;
                            if ($star > 0)
                            {
                                $end_short_tmp_part = substr $end_short_tmp, -length($yuyu1)+1-($star*2);
                                $end_short_tmp_part2 = substr $end_short_tmp, -length($yuyu1)+1-($star);
                                my $yuyu1_tmp2 = $yuyu1;
                                $check_yuyuy1b2 = $yuyu1_tmp2 =~ s/.$end_short_tmp_part2/$end_short_tmp_part2/;
                            }
                            my $yuyu1_tmp3 = $yuyu1;
                            my $check_yuyuy1b = $yuyu1_tmp3 =~ s/.$end_short_tmp_part/$end_short_tmp_part/;
                            if ($check_yuyuy1b > 0 || $check_yuyuy1b2 > 0)
                            {
                                $first_yuyu2++;
                                push @filter_dot_before1, $yuyu0;
                                if (exists($extensions_yuyu{$search}))
                                {
                                    if ($y > $startprint2)
                                    {
                                    }
                                    push @extensions_before, $extensions_yuyu{$search};
                                    push @extensions_before1, $extensions_yuyu{$search};
                                }
                                if (exists($extensions_for_before_match_pair{$search}))
                                {
                                    my $temp = $extensions_for_before_match_pair{$search};
                                    if ($use_quality ne "")
                                    {
                                        $temp =~ tr/1234/ACTG/;
                                    }
                                    $filter_before1{$search} = $temp;
                                    $count1_pair++;
                                    if ($y > $startprint2 && @keys1 < 100)
                                    {
                                    }
                                }
                            }
                        }
                    }
                    foreach my $search (keys %before_all3)
                    {
                        my $yuyu0 = $before_all3{$search};
                        my $yuyu3 = reverse($yuyu0);
                        if (length($yuyu3) >= $read_length-$overhang-5-1)
                        {
                            $yuyu3 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;        
                            my $end_short_tmp_part = substr $end_short_tmp, -length($yuyu3)+1;
                            my $star = $end_short_tmp_part =~ tr/\*//;
                            my $check_yuyuy3b2 = '0';
                            my $end_short_tmp_part2;
                            if ($star > 0)
                            {
                                $end_short_tmp_part = substr $end_short_tmp, -length($yuyu3)+1-($star*2);
                                $end_short_tmp_part2 = substr $end_short_tmp, -length($yuyu3)+1-($star);
                                my $yuyu3_tmp2 = $yuyu3;
                                $check_yuyuy3b2 = $yuyu3_tmp2 =~ s/.$end_short_tmp_part2/$end_short_tmp_part2/;
                            }
                            my $yuyu3_tmp3 = $yuyu3;
                            my $check_yuyuy3b = $yuyu3_tmp3 =~ s/.$end_short_tmp_part/$end_short_tmp_part/;
                            if ($check_yuyuy3b > 0 || $check_yuyuy3b2 > 0)
                            {
                                $third_yuyu2++;
                                push @filter_dot_before3, $yuyu0;
                                if (exists($extensions_yuyu{$search}))
                                {
                                    if ($y > $startprint2)
                                    {
                                    }
                                    push @extensions_before, $extensions_yuyu{$search};
                                    push @extensions_before3, $extensions_yuyu{$search};
                                }
                                if (exists($extensions_for_before_match_pair{$search}))
                                {
                                    my $temp = $extensions_for_before_match_pair{$search};
                                    if ($use_quality ne "")
                                    {
                                        $temp =~ tr/1234/ACTG/;
                                    }
                                    $filter_before3{$search} = $temp;
                                    $count3_pair++;
                                    if ($y > $startprint2 && @keys3 < 100)
                                    {
                                    }
                                }
                            }
                        }
                    }
                    foreach my $search (keys %before_all4)
                    {
                        my $yuyu0 = $before_all4{$search};
                        my $yuyu4 = reverse($yuyu0);
                        if (length($yuyu4) >= $read_length-$overhang-5-1)
                        {
                            $yuyu4 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                            my $end_short_tmp_part = substr $end_short_tmp, -length($yuyu4)+1;
                            my $star = $end_short_tmp_part =~ tr/\*//;
                            my $check_yuyuy4b2 = '0';
                            my $end_short_tmp_part2;
                            if ($star > 0)
                            {
                                $end_short_tmp_part = substr $end_short_tmp, -length($yuyu4)+1-($star*2);
                                $end_short_tmp_part2 = substr $end_short_tmp, -length($yuyu4)+1-($star);
                                my $yuyu4_tmp2 = $yuyu4;
                                $check_yuyuy4b2 = $yuyu4_tmp2 =~ s/.$end_short_tmp_part2/$end_short_tmp_part2/;
                            }
                            my $yuyu4_tmp3 = $yuyu4;
                            my $check_yuyuy4b = $yuyu4_tmp3 =~ s/.$end_short_tmp_part/$end_short_tmp_part/;
                            if ($check_yuyuy4b > 0 || $check_yuyuy4b2 > 0)
                            {
                                $fourth_yuyu2++;
                                push @filter_dot_before4, $yuyu0;
                                if (exists($extensions_yuyu{$search}))
                                {
                                    if ($y > $startprint2)
                                    {
                                    }
                                    push @extensions_before, $extensions_yuyu{$search};
                                    push @extensions_before4, $extensions_yuyu{$search};
                                }
                                if (exists($extensions_for_before_match_pair{$search}))
                                {
                                    my $temp = $extensions_for_before_match_pair{$search};
                                    if ($use_quality ne "")
                                    {
                                        $temp =~ tr/1234/ACTG/;
                                    }
                                    $filter_before4{$search} = $temp;
                                    $count4_pair++;
                                    if ($y > $startprint2 && @keys4 < 100)
                                    {
                                    }
                                }
                            }
                        }
                    }

                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $first_yuyu2." FIRST_YUYU\n";
                        print OUTPUT5 $second_yuyu2." SECOND_YUYU\n";
                        print OUTPUT5 $third_yuyu2." THIRD_YUYU\n";
                        print OUTPUT5 $fourth_yuyu2." FOURTH_YUYU\n";
                        
                        print OUTPUT5 $count1_pair." PAIR1\n";
                        print OUTPUT5 $count2_pair." PAIR2\n";
                        print OUTPUT5 $count3_pair." PAIR3\n";
                        print OUTPUT5 $count4_pair." PAIR4\n";
                    }
                    my $correction = '0';
                    my $count_all = '0';
                    $count_all = (@filter_dot_before1) + (@filter_dot_before2) + (@filter_dot_before3) + (@filter_dot_before4);
                    my $end_short_tmp2 = substr $read_short_end2, -($read_length-$overhang-5-1);
                    my $check_dot = $end_short_tmp2 =~ tr/\./\./;
                    if ($check_dot eq "")
                    {
                        $check_dot = '0'
                    }
                    my $check_star = $end_short_tmp2 =~ tr/\*/\*/;
                    my $check_star2 = "";
                    my $deletion = "";
print OUTPUT5 $check_star." CHECK_STAR\n";
print OUTPUT5 $count_all." COUNT_ALL\n";
                    my $no_correction = "";
                    if ($count_all > 2 && ($check_dot > 0 || $check_star > 0) && $type ne "mito_plant" && $heteroplasmy eq "")
                    {
                        my @split_dot = split /\./, reverse($end_short_tmp2);
                        my $size = '0';
                        my $size2 = '1';
                        my $length_total = '0';
                        my @filter_dot_before_all;
                        undef @filter_dot_before_all;
                        @filter_dot_before_all = (@filter_dot_before1, @filter_dot_before2, @filter_dot_before3, @filter_dot_before4);
                        
                        if ($check_star > 0)
                        {
                            my @deletion = split //, reverse($end_short_tmp2);
                            my $found_star = "";
                            foreach my $nuc (@deletion)
                            {
                                if ($found_star eq "yes")
                                {
                                    $found_star = "";
                                    $deletion .= $nuc;
                                }
                                if ($nuc eq "*")
                                {
                                    $found_star = "yes";
                                }
                            }
                            print OUTPUT5 $deletion." NUC0\n";
                        }
                        foreach my $dot_split (@split_dot)
                        {
                           $size++; 
                        }
                        foreach my $dot_split (@split_dot)
                        {
                            if ($size2 ne $size)
                            {
                                $length_total += length($dot_split);
                                my $A = '0';
                                my $C = '0';
                                my $T = '0';
                                my $G = '0';
                                my $check_star2_part = "";
                                if ($check_star > 0)
                                {
                                    $check_star2_part = substr reverse($end_short_tmp2), 0, $length_total;
                                    $check_star2 = $check_star2_part =~ tr/\*/\*/;
                                    print OUTPUT5 $check_star2." CHECK_STAR2\n";
                                }
                                foreach my $dot_before2 (@filter_dot_before_all)
                                {  
                                    my $dot = substr $dot_before2, $length_total, 1;
                                    if ($check_star2 > 0)
                                    {
                                        print OUTPUT5 $deletion." DEL_DOT\n";
                                        my $check_star2_part_tmp1 = $check_star2_part;
                                        $check_star2_part_tmp1 =~ tr/\*//d;
                                        my $dot_before2_tmp = $dot_before2;
                                        my $check_star1 = $dot_before2_tmp =~ s/.$check_star2_part_tmp1/$check_star2_part_tmp1/;
                                        if ($check_star1 > 0)
                                        {
                                            $dot = substr $dot_before2, $length_total-$check_star2, 1;
                                        }
                                        else
                                        {
                                            $dot = substr $dot_before2, $length_total-($check_star2*2), 1;
                                        }
                                    }
                                    if ($dot eq "A")
                                    {
                                        $A++;
                                    }
                                    elsif ($dot eq "C")
                                    {
                                        $C++;
                                    }
                                    elsif ($dot eq "T")
                                    {
                                        $T++;
                                    }
                                    elsif ($dot eq "G")
                                    {
                                        $G++;
                                    } 
                                }
                                if (($A > 2 && ($C+$T+$G) eq 0) || ($A > ($C+$T+$G)*10 && $repetitive_detect eq ""))
                                {
                                    substr $read, -$length_total-1, 1, "A";
                                    print OUTPUT5 "DOT AAAAAAAAAAAA\n";
                                    $correction++;
                                }
                                if (($C > 2 && ($A+$T+$G) eq 0) || ($C > ($A+$T+$G)*10 && $repetitive_detect eq ""))
                                {
                                    substr $read, -$length_total-1, 1, "C";
                                    print OUTPUT5 "DOT CCCCCCCCCCCC\n";
                                    $correction++;
                                }
                                if (($T > 2 && ($C+$A+$G) eq 0) || ($T > ($C+$A+$G)*10 && $repetitive_detect eq ""))
                                {
                                    substr $read, -$length_total-1, 1, "T";
                                    print OUTPUT5 "DOT TTTTTTTTTTTT\n";
                                    $correction++;
                                }
                                if (($G > 2 && ($C+$T+$A) eq 0) || ($G > ($C+$T+$A)*10 && $repetitive_detect eq ""))
                                {
                                    substr $read, -$length_total-1, 1, "G";
                                    print OUTPUT5 "DOT GGGGGGGGGGGGG\n";
                                    $correction++;
                                }
                                $length_total += 1;
                            }
                            $size2++;
                        }
                    }
                    else
                    {
                        $no_correction = "yes";
                    }
                    my %count1234;
                    my %count1234b;
                    undef %count1234;
                    undef %count1234b;
                    
                    $count1234{'1'} = $count1_pair;
                    $count1234{'2'} = $count2_pair;
                    $count1234{'3'} = $count3_pair;
                    $count1234{'4'} = $count4_pair;
                    
                    my $morethan3 = '0';
                    my $difference = "";
                    
                    foreach my $count1234 (keys %count1234)
                    {
                        if ($count1234{$count1234} > 3)
                        {
                            $morethan3++;
                        }
                    }
                        
                    my $h = '8';
                    if ($type eq "mito_plant" && ($first_yuyu2+$second_yuyu2+$third_yuyu2+$fourth_yuyu2) > $average_coverage_ext*0.8)
                    {
                        $h = '20';
                    }
                    if ($type eq "mito_plant" && ($first_yuyu2+$second_yuyu2+$third_yuyu2+$fourth_yuyu2) > $average_coverage_ext*4)
                    {
                        $h = ($first_yuyu2+$second_yuyu2+$third_yuyu2+$fourth_yuyu2)/($average_coverage_ext/6);
                    }
              
                    if (($first_yuyu2 > 3 && ($second_yuyu2+$third_yuyu2+$fourth_yuyu2) eq '0' || ($first_yuyu2 > ($second_yuyu2+$third_yuyu2+$fourth_yuyu2)*$h && ($second_yuyu2+$third_yuyu2+$fourth_yuyu2) ne '0' && $repetitive_detect2 ne "yes")) && ($correction eq $check_dot || $no_correction ne ""|| $overhang >= $read_length-($overlap+15)) && $jump_rep_because_stuck ne "yes")
                    {
                        if (@extensions_before > 3000000)
                        {
                            $ext_before = "yes";
                            @extensions_before = @extensions_before1;
                            goto EXT_BEFORE;
                        }
                        $best_extension2 = "";
                        $best_extension3 = "";
                        $best_extension4 = "";
                        $best_extension = $best_extension1;
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nONLY FIRST\n\n";
                        }
                        delete $SNP_active{$id};
                        delete $before{$id};
                        delete $before_shorter_skip{$id};
                        if ($last_150 eq "" && $split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep eq "" && $repetitive_detect eq "")
                        {
                            $split = "";
                            $before = "yes";
                            goto REFERENCE;
                        }
                        goto AFTER_EXT;
                    }
                    elsif (($second_yuyu2 > 3 && ($first_yuyu2+$third_yuyu2+$fourth_yuyu2) eq '0' || ($second_yuyu2 > ($first_yuyu2+$third_yuyu2+$fourth_yuyu2)*$h && ($first_yuyu2+$third_yuyu2+$fourth_yuyu2) ne '0' && $repetitive_detect2 ne "yes")) && ($correction eq $check_dot || $no_correction ne ""|| $overhang >= $read_length-($overlap+15)) && $jump_rep_because_stuck ne "yes")
                    {
                        if (@extensions_before > 3000000)
                        {
                            $ext_before = "yes";
                            @extensions_before = @extensions_before2;
                            goto EXT_BEFORE;
                        }
                        $best_extension1 = "";
                        $best_extension3 = "";
                        $best_extension4 = "";
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nONLY SECOND\n\n";
                        }
                        delete $SNP_active{$id};
                        delete $before{$id};
                        delete $before_shorter_skip{$id};
                        $best_extension = $best_extension2;
                        
                        if ($last_150 eq "" && $split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep eq "" && $repetitive_detect eq "")
                        {
                            $split = "";
                            $before = "yes";
                            goto REFERENCE;
                        }
                        goto AFTER_EXT;
                    }
                    elsif (($third_yuyu2 > 3 && ($first_yuyu2+$second_yuyu2+$fourth_yuyu2) eq '0' || ($third_yuyu2 > ($first_yuyu2+$second_yuyu2+$fourth_yuyu2)*$h && ($first_yuyu2+$second_yuyu2+$fourth_yuyu2) ne '0' && $repetitive_detect2 ne "yes")) && ($correction eq $check_dot || $no_correction ne ""|| $overhang >= $read_length-($overlap+15)) && $jump_rep_because_stuck ne "yes")
                    {
                        if (@extensions_before > 300000)
                        {
                            $ext_before = "yes";
                            @extensions_before = @extensions_before3;
                            goto EXT_BEFORE;
                        }
                        $best_extension1 = "";
                        $best_extension2 = "";
                        $best_extension4 = "";
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nONLY THIRD\n\n";
                        }
                        delete $SNP_active{$id};
                        delete $before{$id};
                        delete $before_shorter_skip{$id};
                        $best_extension = $best_extension3;
                        
                        if ($last_150 eq "" && $split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep eq "" && $repetitive_detect eq "")
                        {
                            $split = "";
                            $before = "yes";
                            goto REFERENCE;
                        }
                        goto AFTER_EXT;
                    }
                    elsif (($fourth_yuyu2 > 3 && ($first_yuyu2+$third_yuyu2+$second_yuyu2) eq '0' || ($fourth_yuyu2 > ($first_yuyu2+$third_yuyu2+$second_yuyu2)*$h && ($first_yuyu2+$third_yuyu2+$second_yuyu2) ne '0' && $repetitive_detect2 ne "yes")) && ($correction eq $check_dot || $no_correction ne ""|| $overhang >= $read_length-($overlap+15)) && $jump_rep_because_stuck ne "yes")
                    {
                        if (@extensions_before > 3000000)
                        {
                            $ext_before = "yes";
                            @extensions_before = @extensions_before4;
                            goto EXT_BEFORE;
                        }
                        $best_extension1 = "";
                        $best_extension2 = "";
                        $best_extension3 = "";
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nONLY FOURTH\n\n";
                        }
                        delete $SNP_active{$id};
                        delete $before{$id};
                        delete $before_shorter_skip{$id};
                        $best_extension = $best_extension4;
                        
                        if ($last_150 eq "" && $split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep eq "" && $repetitive_detect eq "")
                        {
                            $split = "";
                            $before = "yes";
                            goto REFERENCE;
                        }
                        goto AFTER_EXT;
                    }
                    elsif($count_all < 3 && $overhang < $read_length-($overlap+15) && $skip_overhang ne "yes" && $jump_rep_because_stuck ne "yes")
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nMAKE BEFORE SHORTER\n\n";
                        }
                        $before_shorter = "yes";
                        goto BEFORE;   
                    }
                    elsif((($morethan3 eq 0 && $overhang < $read_length-($overlap*1.3)) || ($morethan3 > 0 && length($read) <= $insert_size && $overhang < 30) || ($morethan3 eq '1' && $overhang < $read_length-($overlap*1.3))) && $skip_overhang ne "yes" && length($read) > $read_length*1.3)
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nMAKE BEFORE SHORTER2\n\n";
                        }
                        $before_shorter = "yes";
                        goto BEFORE;
                    }
                    elsif ($overhang_for_pairs > $overhang && $average_coverage_ext < 80 && $skip_overhang eq "" && $hp_seed_assemble eq "")
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nINCREASE_OVERHANG\n\n";
                        }
                        $overhang = $overhang_for_pairs;
                        goto BEFORE;
                    }
                    else
                    {
                        if ($jump_rep_because_stuck eq "yes")
                        {
                            goto JUMP_REP;
                        }          
                        my $SNR_check1;
                        my $SNR_check2;
                        if (length($best_extension1) > 6)
                        {
                            my $SNR_check1 = AT_rich_test ($best_extension1,length($best_extension1)/2.5);
                        }
                        if (length($best_extension2) > 6)
                        {
                            my $SNR_check2 = AT_rich_test ($best_extension2,length($best_extension2)/2.5);
                        }
                        if ($morethan3 > 0 && length($read) > $insert_size)
                        {
                            my $count1b = '0';
                            my $count2b = '0';
                            my $count3b = '0';
                            my $count4b = '0';
                            my $count1b_no = '0';
                            my $count2b_no = '0';
                            my $count3b_no = '0';
                            my $count4b_no = '0';
                                                                                                   
                            my $size = keys %read_short_end_tmp;
                            undef @extensions_before;
                            undef @extensions_before1;
                            undef @extensions_before2;
                            undef @extensions_before3;
                            undef @extensions_before4;                          

                            my $read_short_end_tempie_long = substr $read, -($insert_size*2.1);
                            $read_short_end_tempie_long =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                            my $last_nuc_tmp = substr $read_short_end_tempie_long, -1, 1;
                            my $last_nuc_tmp2 = substr $read_short_end_tempie_long, -2, 1;
                            while ($last_nuc_tmp eq "*" || $last_nuc_tmp2 eq "*")
                            {              
                                chop $read_short_end_tempie_long;
                                if ($last_nuc_tmp eq "*")
                                {
                                    chop $read_short_end_tempie_long;
                                }
                                $last_nuc_tmp = substr $read_short_end_tempie_long, -1, 1;
                            }

                            undef %read_short_end_tmp;

                            my %read_short_end_tmp_long = build_partial3c ($read_short_end_tempie_long,"","no_delete");
                            my $star_groups = keys %read_short_end_tmp_long;
                            $star_groups--;
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $read_short_end_tempie_long." READ_SHORT\n";
                            }
                        
                            my $ff = '0';
                            my %hash_read_short_end_for_before;
                            undef %hash_read_short_end_for_before;
                            foreach my $read_short_end_tempie (keys %read_short_end_tmp_long)
                            {
                                $ff = '0';
                                while ($ff < (length($read_short_end_tempie)-$read_length+30+2))
                                {
                                    my $read_short_end_part = substr $read_short_end_tempie, $ff, $read_length-30;
                                    if ($star_groups eq '1')
                                    {
                                        my @split_tmp = split /\+/, $read_short_end_tmp_long{$read_short_end_tempie};
                                        if ($ff > $split_tmp[1])
                                        {
                                            $ff += $split_tmp[0];
                                        }
                                    }                               
                                    $hash_read_short_end_for_before{$read_short_end_part} = $ff;
                                    $ff++;
                                }
                            }                          
                           
                            my $w = '0';
                            my $kmer_tmp = '13';
                            my %hash_read_short_end_for_before_short;
                            undef %hash_read_short_end_for_before_short;

                            while (length($read_short_end_tempie_long)-$w-$kmer_tmp > 0)
                            {
                                my $seq_part = substr $read_short_end_tempie_long, $w, $kmer_tmp;
                                if (exists($hash_read_short_end_for_before_short{$seq_part}))
                                {
                                    $hash_read_short_end_for_before_short{$seq_part} .= ",$w";
                                }
                                else
                                {
                                    $hash_read_short_end_for_before_short{$seq_part} = $w;
                                }
                                $w++;
                            }
                            
                            my %hash_read_short_end_for_before_full;
                            undef %hash_read_short_end_for_before_full;
                            
                            foreach my $read_short_end_tempie (keys %read_short_end_tmp_long)
                            {
            print OUTPUT5 $star_groups." TESTh\n";
                                my $ff2 = '0';
                                while ($ff2 < (length($read_short_end_tempie)-$read_length))
                                {
                                    my $read_short_end_part = substr $read_short_end_tempie, $ff2, $read_length;
                                    if ($star_groups eq '1')
                                    {
                                        my @split_tmp = split /\+/, $read_short_end_tmp_long{$read_short_end_tempie};
                                        if ($ff2 > $split_tmp[1])
                                        {
                                            $ff2 += $split_tmp[0];
                                        }
                                    }
                                    $hash_read_short_end_for_before_full{$read_short_end_part} = $ff2;
                                    $ff2++;
                                }
                            }
                                                      
                            my %matches_read_short_end_long1_pos;
                            my %matches_read_short_end_long2_pos;
                            my %matches_read_short_end_long3_pos;
                            my %matches_read_short_end_long4_pos;
                            my %matches_read_short_end_long1_neg;
                            my %matches_read_short_end_long2_neg;
                            my %matches_read_short_end_long3_neg;
                            my %matches_read_short_end_long4_neg;
                            undef %matches_read_short_end_long1_pos;
                            undef %matches_read_short_end_long2_pos;
                            undef %matches_read_short_end_long3_pos;
                            undef %matches_read_short_end_long4_pos;
                            undef %matches_read_short_end_long1_neg;
                            undef %matches_read_short_end_long2_neg;
                            undef %matches_read_short_end_long3_neg;
                            undef %matches_read_short_end_long4_neg;
                            
                            my $xx = '1';
                            while ($xx < length($read_short_end_tempie_long))
                            {
                                $matches_read_short_end_long1_pos{$xx} = '0';
                                $matches_read_short_end_long1_neg{$xx} = '0';
                                $matches_read_short_end_long2_pos{$xx} = '0';
                                $matches_read_short_end_long2_neg{$xx} = '0';
                                $matches_read_short_end_long3_pos{$xx} = '0';
                                $matches_read_short_end_long3_neg{$xx} = '0';
                                $matches_read_short_end_long4_pos{$xx} = '0';
                                $matches_read_short_end_long4_neg{$xx} = '0';
                                $xx++;
                            }
                            
                            my @read_short_end_tempie_long = split //, $read_short_end_tempie_long;
          
                            foreach my $exb0 (keys %filter_before1)
                            { 
                                my $exb = $filter_before1{$exb0};                        
                                my $is_a_match = "";

                                if (exists($hash_read_short_end_for_before_full{$exb}))
                                {
                                    $is_a_match = "yes";
                                    my $xx_tmp = '1';
                                    while ($xx_tmp < length($exb) && $star_groups < 2)
                                    {
                                        my $pos_tmp = $xx_tmp+$hash_read_short_end_for_before_full{$exb};
                                        my $count_tmp = $matches_read_short_end_long1_pos{$pos_tmp}+1;
                                        $matches_read_short_end_long1_pos{$pos_tmp} = $count_tmp;
                                        $xx_tmp++;
                                    }
                                }
                                else
                                {
                                    my $th = '0';
                                    my $no_match = "";
                                    my $d = '0';
                                    my @read_pair_tmp = split //, $exb;
                                                                         
                                    my $match_pair_middle = substr $exb, 15, length($exb)-30;
                                    if (exists($hash_read_short_end_for_before{$match_pair_middle}))
                                    {
                                        $th = $hash_read_short_end_for_before{$match_pair_middle}-15;
                                        $is_a_match = "yes";
                                    }
                                    else
                                    {
                                        my $o = '0';
                                        my $start_pos_read = "";
                                        my $start_pos_ref = "";
                                        my $current_pos = "";
                                        my $match_tmp = "";
                                        
                                        while ($o < length($exb)-13)
                                        {
                                            my $part_tmp = substr $exb, $o, 13;
                                            if (exists($hash_read_short_end_for_before_short{$part_tmp}))
                                            {
                                                my @split_pos = split /,/, $hash_read_short_end_for_before_short{$part_tmp};
                                                if (@split_pos eq '1' && $start_pos_ref eq "")
                                                {
                                                    $start_pos_ref = $split_pos[0];
                                                    $start_pos_read = $o;
                                                    $current_pos = $split_pos[0];
                                                    $match_tmp = "yes";
                                                }
                                                elsif ($start_pos_ref ne "")
                                                {
                                                    foreach my $split_pos (@split_pos)
                                                    {
                                                        if ($split_pos > $current_pos && $split_pos < $current_pos+15 && $start_pos_ref-$start_pos_read eq $split_pos-$o)
                                                        {
                                                            $current_pos = $split_pos;
                                                            $match_tmp = "yes";
                                                        }
                                                    }
                                                }
                                            }
                                            elsif ($match_tmp eq "yes")
                                            {
                                                $match_tmp = "no";
                                                $o += 11;
                                            }
                                            $o++;
                                        }
                                        if ($current_pos-$start_pos_ref > length($exb)*0.75)
                                        {
                                            $th = $start_pos_ref-$start_pos_read;
                                        }
                                        else
                                        {
                                            $no_match = "yes";
                                        }
                                    }
                                    if ($no_match ne "yes")
                                    {
                                        $d = '0';
                                        my $count_matches = '0';
                                        my $star_detect = "";
                                        if ($y > $startprint2 && $count1_pair < 100)
                                        {
                                            print OUTPUT5 $exb." FOUND1_PAIR ".$extensions_yuyu{$exb0}." EXT1\n";
                                        }
                                        
                                        while ($d < length($exb))
                                        {
                                            my $pos_tmp = $d+$th+1;
                                            if ($pos_tmp > 0 && $pos_tmp <= length($read_short_end_tempie_long))
                                            {
                                                if ($read_short_end_tempie_long[$d+$th+1] eq "*")
                                                {
                                                    if ($read_pair_tmp[$d] eq $read_short_end_tempie_long[$d+$th])
                                                    {
                                                        $star_detect = "1";
                                                    }
                                                    else
                                                    {
                                                        while ($read_short_end_tempie_long[$d+$th+1] eq "*")
                                                        {
                                                            $th += 2;
                                                        }
                                                    }
                                                }
                                                
                                                if ($read_pair_tmp[$d] eq $read_short_end_tempie_long[$d+$th])
                                                {
                                                    my $count_tmp = $matches_read_short_end_long1_pos{$pos_tmp}+1;
                                                    $matches_read_short_end_long1_pos{$pos_tmp} = $count_tmp;
                                                    $count_matches++;
                                                }
                                                elsif ($read_pair_tmp[$d] eq "N")
                                                {
                                                }
                                                elsif ($read_short_end_tempie_long[$d+$th] eq ".")
                                                {
                                                }          
                                                else
                                                {
                                                    if ($read_short_end_tempie_long[$d+$th] eq "*" && $star_detect eq "1")
                                                    {
                                                        $d--;
                                                        $th++;
                                                    }
                                                    else
                                                    {
                                                        my $count_tmp = $matches_read_short_end_long1_neg{$pos_tmp}-1;
                                                        $matches_read_short_end_long1_neg{$pos_tmp} = $count_tmp;
                                                    }
                                                }
                                            }
                                            $d++  
                                        }
                                        if ($count_matches > length($exb)*0.9)
                                        {
                                            $is_a_match = "yes";
                                        }
                                    }
                                }
                                if ($is_a_match eq "yes")
                                {
                                    if ($y > $startprint2 && $count1_pair < 100)
                                    {
                                    }
                                    if (exists($extensions_yuyu{$exb0}))
                                    {
                                        push @extensions_before, $extensions_yuyu{$exb0};
                                        push @extensions_before1, $extensions_yuyu{$exb0};
                                    }
                                    $count1b++;
                                }
                                else
                                {
                                    $count1b_no++;
                                }
                            }
                                             
                            
                            foreach my $exb0 (keys %filter_before2)
                            { 
                                my $exb = $filter_before2{$exb0};
                                my $is_a_match = "";
                                
                                if (exists($hash_read_short_end_for_before_full{$exb}))
                                {
                                    $is_a_match = "yes";
                                    my $xx_tmp = '1';
                                    while ($xx_tmp < length($exb) && $star_groups < 2)
                                    {
                                        my $pos_tmp = $xx_tmp+$hash_read_short_end_for_before_full{$exb};
                                        my $count_tmp = $matches_read_short_end_long2_pos{$pos_tmp}+1;
                                        $matches_read_short_end_long2_pos{$pos_tmp} = $count_tmp;
                                        $xx_tmp++;
                                    }
                                }
                                else
                                {
                                    my $th = '0';
                                    my $no_match = "";
                                    my $d = '0';
                                    my @read_pair_tmp = split //, $exb;
                                                                         
                                    my $pos_middle = sprintf("%.0f",length($exb)/2)-25;
                                    my $match_pair_middle = substr $exb, 15, length($exb)-30;
                                    if (exists($hash_read_short_end_for_before{$match_pair_middle}))
                                    {
                                        $th = $hash_read_short_end_for_before{$match_pair_middle}-15;
                                        $is_a_match = "yes";
                                    }
                                    else
                                    {
                                        my $o = '0';
                                        my $start_pos_read = "";
                                        my $start_pos_ref = "";
                                        my $current_pos = "";
                                        my $match_tmp = "";
                                        while ($o < length($exb)-13)
                                        {
                                            my $part_tmp = substr $exb, $o, 13;
                                            if (exists($hash_read_short_end_for_before_short{$part_tmp}))
                                            {
                                                my @split_pos = split /,/, $hash_read_short_end_for_before_short{$part_tmp};
                                                if (@split_pos eq '1' && $start_pos_ref eq "")
                                                {
                                                    $start_pos_ref = $split_pos[0];
                                                    $start_pos_read = $o;
                                                    $current_pos = $split_pos[0];
                                                    $match_tmp = "yes";
                                                }
                                                elsif ($start_pos_ref ne "")
                                                {
                                                    foreach my $split_pos (@split_pos)
                                                    {
                                                        if ($split_pos > $current_pos && $split_pos < $current_pos+15 && $start_pos_ref-$start_pos_read eq $split_pos-$o)
                                                        {
                                                            $current_pos = $split_pos;
                                                            $match_tmp = "yes";
                                                        }
                                                    }
                                                }
                                            }
                                            elsif ($match_tmp eq "yes")
                                            {
                                                $match_tmp = "no";
                                                $o += 11;
                                            }
                                            $o++;
                                        }
                                        if ($current_pos-$start_pos_ref > length($exb)*0.75)
                                        {
                                            $th = $start_pos_ref-$start_pos_read;
                                        }
                                        else
                                        {
                                            $no_match = "yes";
                                        }
                                    }
                                    if ($no_match ne "yes")
                                    {
                                        $d = '0';
                                        my $count_matches = '0';
                                        my $star_detect = "";
                                        while ($d < length($exb))
                                        {
                                            my $pos_tmp = $d+$th+1;
                                            if ($pos_tmp > 0 && $pos_tmp <= length($read_short_end_tempie_long))
                                            {
                                                if ($read_short_end_tempie_long[$d+$th+1] eq "*")
                                                {
                                                    if ($read_pair_tmp[$d] eq $read_short_end_tempie_long[$d+$th])
                                                    {
                                                        $star_detect = "1";
                                                    }
                                                    else
                                                    {
                                                        while ($read_short_end_tempie_long[$d+$th+1] eq "*")
                                                        {
                                                            $th += 2;
                                                        }
                                                    }
                                                }
                                                
                                                if ($read_pair_tmp[$d] eq $read_short_end_tempie_long[$d+$th])
                                                {
                                                    my $count_tmp = $matches_read_short_end_long2_pos{$pos_tmp}+1;
                                                    $matches_read_short_end_long2_pos{$pos_tmp} = $count_tmp;
                                                    $count_matches++;
                                                }
                                                elsif ($read_pair_tmp[$d] eq "N")
                                                {
                                                }
                                                elsif ($read_short_end_tempie_long[$d+$th] eq ".")
                                                {
                                                }          
                                                else
                                                {
                                                    if ($read_short_end_tempie_long[$d+$th] eq "*" && $star_detect eq "1")
                                                    {
                                                        $d--;
                                                        $th++;
                                                    }
                                                    else
                                                    {
                                                        my $count_tmp = $matches_read_short_end_long2_neg{$pos_tmp}-1;
                                                        $matches_read_short_end_long2_neg{$pos_tmp} = $count_tmp;
                                                    }
                                                }
                                            }
                                            $d++  
                                        }
                                        if ($count_matches > length($exb)*0.9)
                                        {
                                            $is_a_match = "yes";
                                        }
                                    }       
                                }
                                if ($is_a_match eq "yes")
                                {
                                    if ($y > $startprint2 && $count2_pair < 100)
                                    {
                                    }
                                    if (exists($extensions_yuyu{$exb0}))
                                    {
                                        push @extensions_before, $extensions_yuyu{$exb0};
                                        push @extensions_before2, $extensions_yuyu{$exb0};
                                    }
                                    $count2b++;
                                }
                                else
                                {
                                    $count2b_no++;
                                }
                            }
                            
                            foreach my $exb0 (keys %filter_before3)
                            { 
                                my $exb = $filter_before3{$exb0};                        
                                my $is_a_match = "";
                                
                                if (exists($hash_read_short_end_for_before_full{$exb}))
                                {
                                    $is_a_match = "yes";
                                    my $xx_tmp = '1';
                                    while ($xx_tmp < length($exb))
                                    {
                                        my $pos_tmp = $xx_tmp+$hash_read_short_end_for_before_full{$exb};
                                        my $count_tmp = $matches_read_short_end_long3_pos{$pos_tmp}+1;
                                        $matches_read_short_end_long3_pos{$pos_tmp} = $count_tmp;
                                        $xx_tmp++;
                                    }
                                }
                                else
                                {
                                    my $th = '0';
                                    my $no_match = "";
                                    my $d = '0';
                                    my @read_pair_tmp = split //, $exb;
                                                                         
                                    my $match_pair_middle = substr $exb, 15, length($exb)-30;
                                    if (exists($hash_read_short_end_for_before{$match_pair_middle}))
                                    {
                                        $th = $hash_read_short_end_for_before{$match_pair_middle}-15;
                                        $is_a_match = "yes";
                                    }
                                    else
                                    {
                                        my $o = '0';
                                        my $start_pos_read = "";
                                        my $start_pos_ref = "";
                                        my $current_pos = "";
                                        my $match_tmp = "";
                                        while ($o < length($exb)-13)
                                        {
                                            my $part_tmp = substr $exb, $o, 13;
                                            if (exists($hash_read_short_end_for_before_short{$part_tmp}))
                                            {
                                                my @split_pos = split /,/, $hash_read_short_end_for_before_short{$part_tmp};
                                                if (@split_pos eq '1' && $start_pos_ref eq "")
                                                {
                                                    $start_pos_ref = $split_pos[0];
                                                    $start_pos_read = $o;
                                                    $current_pos = $split_pos[0];
                                                    $match_tmp = "yes";
                                                }
                                                elsif ($start_pos_ref ne "")
                                                {
                                                    foreach my $split_pos (@split_pos)
                                                    {
                                                        if ($split_pos > $current_pos && $split_pos < $current_pos+15 && $start_pos_ref-$start_pos_read eq $split_pos-$o)
                                                        {
                                                            $current_pos = $split_pos;
                                                            $match_tmp = "yes";
                                                        }
                                                    }
                                                }
                                            }
                                            elsif ($match_tmp eq "yes")
                                            {
                                                $match_tmp = "no";
                                                $o += 11;
                                            }
                                            $o++;
                                        }
                                        
                                        if ($current_pos-$start_pos_ref > length($exb)*0.75)
                                        {
                                            $th = $start_pos_ref-$start_pos_read;
                                        }
                                        else
                                        {
                                            $no_match = "yes";
                                        }
                                    }
                                    if ($no_match ne "yes")
                                    {
                                        $d = '0';
                                        my $count_matches = '0';
                                        
                                        while ($d < length($exb))
                                        {
                                            my $pos_tmp = $d+$th+1;                                          
                                            if ($pos_tmp > 0 && $pos_tmp <= length($read_short_end_tempie_long))
                                            {
                                                if ($read_pair_tmp[$d] eq $read_short_end_tempie_long[$d+$th])
                                                {
                                                    my $count_tmp = $matches_read_short_end_long3_pos{$pos_tmp}+1;
                                                    $matches_read_short_end_long3_pos{$pos_tmp} = $count_tmp;
                                                    $count_matches++;
                                                }
                                                elsif ($read_pair_tmp[$d] eq "N")
                                                {
                                                }
                                                elsif ($read_short_end_tempie_long[$d+$th] eq ".")
                                                {
                                                }          
                                                else
                                                {
                                                    my $count_tmp = $matches_read_short_end_long3_neg{$pos_tmp}-1;
                                                    $matches_read_short_end_long3_neg{$pos_tmp} = $count_tmp;
                                                }
                                            }
                                            $d++  
                                        }
                                        if ($count_matches > length($exb)*0.9)
                                        {
                                            $is_a_match = "yes";
                                        }
                                    }  
                                }
                                
                                if ($is_a_match eq "yes")
                                {
                                    if ($y > $startprint2 && $count3_pair < 100)
                                    {
                                    }
                                    if (exists($extensions_yuyu{$exb0}))
                                    {
                                        push @extensions_before, $extensions_yuyu{$exb0};
                                        push @extensions_before3, $extensions_yuyu{$exb0};
                                    }
                                    $count3b++;
                                }
                                else
                                {
                                    $count3b_no++;
                                }
                            }
                            
                            foreach my $exb0 (keys %filter_before4)
                            { 
                                my $exb = $filter_before4{$exb0};                        
                                my $is_a_match = "";
                                
                                if (exists($hash_read_short_end_for_before_full{$exb}))
                                {
                                    $is_a_match = "yes";
                                    my $xx_tmp = '1';
                                    while ($xx_tmp < length($exb))
                                    {
                                        my $pos_tmp = $xx_tmp+$hash_read_short_end_for_before_full{$exb};
                                        my $count_tmp = $matches_read_short_end_long4_pos{$pos_tmp}+1;
                                        $matches_read_short_end_long4_pos{$pos_tmp} = $count_tmp;
                                        $xx_tmp++;
                                    }
                                }
                                else
                                {
                                    my $th = '0';
                                    my $no_match = "";
                                    my $d = '0';
                                    my @read_pair_tmp = split //, $exb;
                                                                         
                                    my $match_pair_middle = substr $exb, 15, length($exb)-30;
                                    if (exists($hash_read_short_end_for_before{$match_pair_middle}))
                                    {
                                        $th = $hash_read_short_end_for_before{$match_pair_middle}-15;
                                        $is_a_match = "yes";
                                    }
                                    else
                                    {
                                        my $o = '0';
                                        my $start_pos_read = "";
                                        my $start_pos_ref = "";
                                        my $current_pos = "";
                                        my $match_tmp = "";
                                        while ($o < length($exb)-13)
                                        {
                                            my $part_tmp = substr $exb, $o, 13;
                                            if (exists($hash_read_short_end_for_before_short{$part_tmp}))
                                            {
                                                my @split_pos = split /,/, $hash_read_short_end_for_before_short{$part_tmp};
                                                if (@split_pos eq '1' && $start_pos_ref eq "")
                                                {
                                                    $start_pos_ref = $split_pos[0];
                                                    $start_pos_read = $o;
                                                    $current_pos = $split_pos[0];
                                                    $match_tmp = "yes";
                                                }
                                                elsif ($start_pos_ref ne "")
                                                {
                                                    foreach my $split_pos (@split_pos)
                                                    {
                                                        if ($split_pos > $current_pos && $split_pos < $current_pos+15 && $start_pos_ref-$start_pos_read eq $split_pos-$o)
                                                        {
                                                            $current_pos = $split_pos;
                                                            $match_tmp = "yes";
                                                        }
                                                    }
                                                }
                                            }
                                            elsif ($match_tmp eq "yes")
                                            {
                                                $match_tmp = "no";
                                                $o += 11;
                                            }
                                            $o++;
                                        }
                                        
                                        if ($current_pos-$start_pos_ref > length($exb)*0.75)
                                        {
                                            $th = $start_pos_ref-$start_pos_read;
                                        }
                                        else
                                        {
                                            $no_match = "yes";
                                        }
                                    }
                                    if ($no_match ne "yes")
                                    {
                                        $d = '0';
                                        my $count_matches = '0';
                                        
                                        while ($d < length($exb))
                                        {
                                            my $pos_tmp = $d+$th+1;                                          
                                            if ($pos_tmp > 0 && $pos_tmp <= length($read_short_end_tempie_long))
                                            {
                                                if ($read_pair_tmp[$d] eq $read_short_end_tempie_long[$d+$th])
                                                {
                                                    my $count_tmp = $matches_read_short_end_long4_pos{$pos_tmp}+1;
                                                    $matches_read_short_end_long4_pos{$pos_tmp} = $count_tmp;
                                                    $count_matches++;
                                                }
                                                elsif ($read_pair_tmp[$d] eq "N")
                                                {
                                                }
                                                elsif ($read_short_end_tempie_long[$d+$th] eq ".")
                                                {
                                                }          
                                                else
                                                {
                                                    my $count_tmp = $matches_read_short_end_long4_neg{$pos_tmp}-1;
                                                    $matches_read_short_end_long4_neg{$pos_tmp} = $count_tmp;
                                                }
                                            }
                                            $d++  
                                        }
                                        if ($count_matches > length($exb)*0.9)
                                        {
                                            $is_a_match = "yes";
                                        }
                                    }  
                                }
                                
                                if ($is_a_match eq "yes")
                                {
                                    if ($y > $startprint2 && $count4_pair < 100)
                                    {
                                    }
                                    if (exists($extensions_yuyu{$exb0}))
                                    {
                                        push @extensions_before, $extensions_yuyu{$exb0};
                                        push @extensions_before4, $extensions_yuyu{$exb0};
                                    }
                                    $count4b++;
                                }
                                else
                                {
                                    $count4b_no++;
                                }
                            }
                            
                            print OUTPUT5 "\nREF__";
                            foreach my $nuc_tmp (@read_short_end_tempie_long)
                            {
                                print OUTPUT5 $nuc_tmp;
                            }
                            print OUTPUT5 "\nNEG1_";
                            my $corr = '0';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long1_neg)
                            {      
                                if ($matches_read_short_end_long1_neg{$pos_tmp} < 0)
                                {
                                    print OUTPUT5 $matches_read_short_end_long1_neg{$pos_tmp}."";
                                    $corr += length($matches_read_short_end_long1_neg{$pos_tmp})-1;
                                }
                                elsif ($corr > 0)
                                {
                                    $corr--;
                                }
                                else
                                {
                                    print OUTPUT5 "_";
                                }
                            }
                            print OUTPUT5 "\nNEG2_";
                            $corr = '0';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long2_neg)
                            {
                                if ($matches_read_short_end_long2_neg{$pos_tmp} < 0)
                                {
                                    print OUTPUT5 $matches_read_short_end_long2_neg{$pos_tmp}."";
                                    $corr += length($matches_read_short_end_long2_neg{$pos_tmp})-1;
                                }
                                elsif ($corr > 0)
                                {
                                    $corr--;
                                }
                                else
                                {
                                    print OUTPUT5 "_";
                                }
                            }
                            
                            my $twenty = '1';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long1_neg)
                            {
                                print OUTPUT5 $matches_read_short_end_long1_neg{$pos_tmp}."\t";  
                                if ($twenty eq '25')
                                {
                                    $twenty = '0';
                                    print OUTPUT5 "\n";
                                }
                                $twenty++;
                            }
                            print OUTPUT5 "\n\n";
                            $twenty = '1';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long1_neg)
                            {
                                print OUTPUT5 $matches_read_short_end_long1_pos{$pos_tmp}+$matches_read_short_end_long1_neg{$pos_tmp}."\t";
                                if ($matches_read_short_end_long1_neg{$pos_tmp} < '-1')
                                {
                                    if (($matches_read_short_end_long2_pos{$pos_tmp} > 0 || $matches_read_short_end_long3_pos{$pos_tmp} > 0 || $matches_read_short_end_long4_pos{$pos_tmp} > 0)
                                        && ($matches_read_short_end_long1_pos{$pos_tmp} eq '0' ||
                                        ($matches_read_short_end_long1_pos{$pos_tmp} < '5' && $matches_read_short_end_long1_neg{$pos_tmp} < $matches_read_short_end_long1_pos{$pos_tmp}*(-5))))
                                    {
                                        $count1b = '0';
                                    }
                                }
                                if ($twenty eq '25')
                                {
                                    $twenty = '0';
                                    print OUTPUT5 "\n";
                                }
                                $twenty++;
                            }
                            print OUTPUT5 "\n\n";
                            
                            $twenty = '1';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long2_neg)
                            {
                                print OUTPUT5 $matches_read_short_end_long2_neg{$pos_tmp}."\t";  
                                if ($twenty eq '25')
                                {
                                    $twenty = '0';
                                    print OUTPUT5 "\n";
                                }
                                $twenty++;
                            }
                            print OUTPUT5 "\n\n";
                            
                            $twenty = '1';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long2_neg)
                            {
                                print OUTPUT5 $matches_read_short_end_long2_pos{$pos_tmp}+$matches_read_short_end_long2_neg{$pos_tmp}."\t";
                                if ($matches_read_short_end_long2_neg{$pos_tmp} < '-1')
                                {
                                    if (($matches_read_short_end_long1_pos{$pos_tmp} > 0 || $matches_read_short_end_long3_pos{$pos_tmp} > 0 || $matches_read_short_end_long4_pos{$pos_tmp} > 0)
                                        && ($matches_read_short_end_long2_pos{$pos_tmp} eq '0' ||
                                        ($matches_read_short_end_long2_pos{$pos_tmp} < '5' && $matches_read_short_end_long2_neg{$pos_tmp} < $matches_read_short_end_long2_pos{$pos_tmp}*(-5))))
                                    {
                                        $count2b = '0';
                                    }
                                }
                                if ($twenty eq '25')
                                {
                                    $twenty = '0';
                                    print OUTPUT5 "\n";
                                }
                                $twenty++;
                            }
                            print OUTPUT5 "\n\n";
                            
                            if ($third_yuyu2 > 0)
                            {
                                $twenty = '1';
                                foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long3_neg)
                                {
                                    print OUTPUT5 $matches_read_short_end_long3_neg{$pos_tmp}."\t";  
                                    if ($twenty eq '25')
                                    {
                                        $twenty = '0';
                                        print OUTPUT5 "\n";
                                    }
                                    $twenty++;
                                }
                                print OUTPUT5 "\n\n";
                                
                                $twenty = '1';
                                foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long3_neg)
                                {
                                    print OUTPUT5 $matches_read_short_end_long3_pos{$pos_tmp}+$matches_read_short_end_long3_neg{$pos_tmp}."\t";
                                    if ($matches_read_short_end_long3_neg{$pos_tmp} < '-1')
                                    {
                                        if (($matches_read_short_end_long1_pos{$pos_tmp} > 0 || $matches_read_short_end_long2_pos{$pos_tmp} > 0 || $matches_read_short_end_long4_pos{$pos_tmp} > 0)
                                            && ($matches_read_short_end_long3_pos{$pos_tmp} eq '0' ||
                                            ($matches_read_short_end_long3_pos{$pos_tmp} < '5' && $matches_read_short_end_long3_neg{$pos_tmp} < $matches_read_short_end_long3_pos{$pos_tmp}*(-5))))
                                        {
                                            $count3b = '0';
                                        }
                                    }
                                    if ($twenty eq '25')
                                    {
                                        $twenty = '0';
                                        print OUTPUT5 "\n";
                                    }
                                    $twenty++;
                                }
                                print OUTPUT5 "\n\n";
                            }
                            
                            if ($fourth_yuyu2 > 0)
                            {
                                $twenty = '1';
                                foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long4_neg)
                                {
                                    print OUTPUT5 $matches_read_short_end_long4_neg{$pos_tmp}."\t";  
                                    if ($twenty eq '25')
                                    {
                                        $twenty = '0';
                                        print OUTPUT5 "\n";
                                    }
                                    $twenty++;
                                }
                                print OUTPUT5 "\n\n";
                                
                                $twenty = '1';
                                foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_end_long4_neg)
                                {
                                    print OUTPUT5 $matches_read_short_end_long4_pos{$pos_tmp}+$matches_read_short_end_long4_neg{$pos_tmp}."\t";
                                    if ($matches_read_short_end_long4_neg{$pos_tmp} < '-1')
                                    {
                                        if (($matches_read_short_end_long1_pos{$pos_tmp} > 0 || $matches_read_short_end_long2_pos{$pos_tmp} > 0 || $matches_read_short_end_long3_pos{$pos_tmp} > 0)
                                            && ($matches_read_short_end_long4_pos{$pos_tmp} eq '0' ||
                                            ($matches_read_short_end_long4_pos{$pos_tmp} < '5' && $matches_read_short_end_long4_neg{$pos_tmp} < $matches_read_short_end_long4_pos{$pos_tmp}*(-5))))
                                        {
                                            $count4b = '0';
                                        }
                                    }
                                    if ($twenty eq '25')
                                    {
                                        $twenty = '0';
                                        print OUTPUT5 "\n";
                                    }
                                    $twenty++;
                                }
                                print OUTPUT5 "\n\n";
                            }
                            
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $count1b." COUNT1B\n";
                                print OUTPUT5 $count2b." COUNT2B\n";
                                print OUTPUT5 $count3b." COUNT3B\n";
                                print OUTPUT5 $count4b." COUNT4B\n";
                                print OUTPUT5 $count1b_no." COUNT1B_NO\n";
                                print OUTPUT5 $count2b_no." COUNT2B_NO\n";
                                print OUTPUT5 $count3b_no." COUNT3B_NO\n";
                                print OUTPUT5 $count4b_no." COUNT4B_NO\n";
                            }
                            $count1b_tmp = $count1b;
                            $count2b_tmp = $count2b;
                            $count3b_tmp = $count3b;
                            $count4b_tmp = $count4b;
                            my $f = '6';
                            if ($SNR_check1 ne "" || $SNR_check2 ne "")
                            {
                                $f = '8';
                            }
                            if ($repetitive_detect ne "")
                            {
                                $f = '10';
                            }
                            if ($type eq "mito_plant")
                            {
                                $f = '10';
                            }
                            if ($type eq "mito_plant" && ($count1b+$count2b+$count3b+$count4b) > $average_coverage_ext/2)
                            {
                                $f = '25';
                            }
                            if ($type eq "mito_plant" && ($count1b+$count2b+$count3b+$count4b) > $average_coverage_ext)
                            {
                                $f = '32';
                            }
                            my $dup = "";
                            my $r = '4';
                            if ($type eq "mito_plant" && ($count1b+$count2b+$count3b+$count4b) > $average_coverage_ext*3)
                            {
                                $dup = "yes";
                                $r = 9;
                            }
                            if ($type eq "mito_plant" && ($count1b+$count2b+$count3b+$count4b) > $average_coverage_ext*3)
                            {
                                $dup = "yes";
                                $r = 12;
                            }
                            
                            $count1234b{'1'} = $count1b;
                            $count1234b{'2'} = $count2b;
                            $count1234b{'3'} = $count3b;
                            $count1234b{'4'} = $count4b;
                            
                            my $differenceb1 = "";
                            my $differenceb2 = "";
                            my $differenceb3 = "";
                            my $differenceb4 = "";
                            
                            foreach my $count1234b (keys %count1234b)
                            {    
                                if ($count1234b ne '1' && $count1234b{$count1234b} > 0 && $count1b > $f*$count1234b{$count1234b} && $differenceb1 ne "no")
                                {
                                    $differenceb1 = "yes";
                                }
                                elsif ($count1234b ne '1' && $count1234b{$count1234b} > 0 && $count1b <= $f*$count1234b{$count1234b})
                                {
                                    $differenceb1 = "no";
                                }
                                if ($count1234b ne '2' && $count1234b{$count1234b} > 0 && $count2b > $f*$count1234b{$count1234b} && $differenceb2 ne "no")
                                {
                                    $differenceb2 = "yes";
                                }
                                elsif ($count1234b ne '2' && $count1234b{$count1234b} > 0 && $count2b <= $f*$count1234b{$count1234b})
                                {
                                    $differenceb2 = "no";
                                }
                                if ($count1234b ne '3' && $count1234b{$count1234b} > 0 && $count3b > $f*$count1234b{$count1234b} && $differenceb3 ne "no")
                                {
                                    $differenceb3 = "yes";
                                }
                                elsif ($count1234b ne '3' && $count1234b{$count1234b} > 0 && $count3b <= $f*$count1234b{$count1234b})
                                {
                                    $differenceb3 = "no";
                                }
                                if ($count1234b ne '4' && $count1234b{$count1234b} > 0 && $count4b > $f*$count1234b{$count1234b} && $differenceb4 ne "no")
                                {
                                    $differenceb4 = "yes";
                                }
                                elsif ($count1234b ne '4' && $count1234b{$count1234b} > 0 && $count4b <= $f*$count1234b{$count1234b})
                                {
                                    $differenceb4 = "no";
                                }
                            }
                            if ((($count1b > 2 && ($count2b+$count3b+$count4b) eq '0') || ($differenceb1 eq "yes" && $differenceb2 eq "" && $differenceb3 eq "" && $differenceb4 eq "")) && ($dup ne "yes" || ($count2b+$count3b+$count4b) < $average_coverage_ext/$r))
                            {
                                if (@extensions_before > 3000000)
                                {
                                    $ext_before = "yes";
                                    @extensions_before = @extensions_before1;
                                    goto EXT_BEFORE;
                                }
                                $best_extension2 = "";
                                $best_extension3 = "";
                                $best_extension4 = "";
                                $best_extension = $best_extension1;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nREVERSE_DELETE SPLIT_BEFORE5\n\n";
                                }
                                delete $SNP_active{$id};
                                delete $before{$id};
                                delete $before_shorter_skip{$id};
                                
                                if ($last_150 eq "" && $split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep eq "" && $repetitive_detect eq "")
                                {
                                    $split = "";
                                    $before = "yes";
                                    goto REFERENCE;
                                }
                                goto AFTER_EXT;
                            }
                            elsif ((($count2b > 2 && ($count1b+$count3b+$count4b) eq '0') || ($differenceb2 eq "yes" && $differenceb1 eq "" && $differenceb3 eq "" && $differenceb4 eq "")) && ($dup ne "yes" || ($count1b+$count3b+$count4b) < $average_coverage_ext/$r))
                            {
                                if (@extensions_before > 3000000)
                                {
                                    $ext_before = "yes";
                                    @extensions_before = @extensions_before2;
                                    goto EXT_BEFORE;
                                }
                                $best_extension1 = "";
                                $best_extension3 = "";
                                $best_extension4 = "";
                                $best_extension = $best_extension2;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nREVERSE_DELETE SPLIT_BEFORE6\n\n";
                                }
                                delete $SNP_active{$id};
                                delete $before_shorter_skip{$id};
                                delete $before{$id};
                                
                                if ($last_150 eq "" && $split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep eq "" && $repetitive_detect eq "")
                                {
                                    $split = "";
                                    $before = "yes";
                                    goto REFERENCE;
                                }
                                goto AFTER_EXT;

                            }
                            elsif ((($count3b > 2 && ($count1b+$count2b+$count4b) eq '0') || ($differenceb3 eq "yes" && $differenceb2 eq "" && $differenceb1 eq "" && $differenceb4 eq "")) && ($dup ne "yes" || ($count2b+$count1b+$count4b) < $average_coverage_ext/$r))
                            {
                                if (@extensions_before > 300000)
                                {
                                    $ext_before = "yes";
                                    @extensions_before = @extensions_before3;
                                    goto EXT_BEFORE;
                                }
                                $best_extension1 = "";
                                $best_extension2 = "";
                                $best_extension4 = "";
                                $best_extension = $best_extension3;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nREVERSE_DELETE SPLIT_BEFORE7\n\n";
                                }
                                delete $SNP_active{$id};
                                delete $before{$id};
                                delete $before_shorter_skip{$id};
                                
                                if ($last_150 eq "" && $split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep eq "" && $repetitive_detect eq "")
                                {
                                    $split = "";
                                    $before = "yes";
                                    goto REFERENCE;
                                }
                                goto AFTER_EXT;
                            }
                            elsif ((($count4b > 2 && ($count1b+$count2b+$count3b) eq '0') || ($differenceb4 eq "yes" && $differenceb2 eq "" && $differenceb3 eq "" && $differenceb1 eq "")) && ($dup ne "yes" || ($count2b+$count3b+$count1b) < $average_coverage_ext/$r))
                            {
                                if (@extensions_before > 300000)
                                {
                                    $ext_before = "yes";
                                    @extensions_before = @extensions_before4;
                                    goto EXT_BEFORE;
                                }
                                $best_extension1 = "";
                                $best_extension2 = "";
                                $best_extension3 = "";
                                $best_extension = $best_extension4;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nREVERSE_DELETE SPLIT_BEFORE8\n\n";
                                }
                                delete $SNP_active{$id};
                                delete $before{$id};
                                delete $before_shorter_skip{$id};
                                
                                if ($last_150 eq "" && $split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep eq "" && $repetitive_detect eq "")
                                {
                                    $split = "";
                                    $before = "yes";
                                    goto REFERENCE;
                                }
                                goto AFTER_EXT;
                            }
                            elsif ($overhang < $read_length-$overlap-5  && $before_shorter_skip ne "yes" && $skip_overhang ne "yes")
                            {
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nMAKE BEFORE SHORTER3\n\n";
                                }
                                $before_shorter = "yes2";
                                goto BEFORE;
                            }
                            elsif (($count1b+$count2b+$count3b+$count4b) > 9 && $extensions_before ne "yes" && $repetitive_detect2 ne "yes" && $before_shorter_skip ne "yes" && (length($best_extension1) < 7 || length($best_extension2) < 7) && $hp_seed_assemble eq "")
                            {
                                $l = 0;
                                my $ll1 = '0';
                                my $ll2 = '0';
                                if ($count1b ne 0)
                                { 
                                    foreach my $ext1 (@extensions_before1)
                                    {
                                        if (length($ext1) > $ll1)
                                        {
                                            $ll1 = length($ext1);
                                        }
                                    }
                                    $ll = $ll1;
                                }
                                if ($count2b ne 0)
                                { 
                                    foreach my $ext2 (@extensions_before2)
                                    {
                                        if (length($ext2) > $ll2)
                                        {
                                            $ll2 = length($ext2);
                                        }
                                    }
                                    if ($ll2 < $ll1)
                                    {
                                        $ll = $ll2;
                                    } 
                                }
                                $best_extension = "";
                                $SNP = "";
                                $ext = '0';
                                foreach my $ext_b (@extensions_before)
                                {
                                    $ext++;
                                    $extensionsb{$ext} = $ext_b;
                                }

                                $extensions_before = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nEXTENSIONS FROM BEFORE0\n\n";
                                }
                                $read_new = $read;                                           
                                $read_new1 = $read;
                                $best_extension_old1 = $best_extension1;
                                $best_extension_old2 = $best_extension2;
                                $best_extension_old3 = $best_extension3;
                                $best_extension_old4 = $best_extension4;
                                $SNP_active = "yes";
                                $before_shorter_skip{$id} = "yes";
                                $best_extension1 = "";
                                $best_extension2 = "";
                                $best_extension3 = "";
                                $best_extension4 = "";
                                $split = "";
                                undef %extensionsb_group1;
                                undef %extensionsb_group2;
                                undef %extensionsb_group3;
                                undef %extensionsb_group4;
                                goto NUCLEO;
                            }          
                        }
                        elsif (@extensions_before > 10 && $jump_rep ne "yes" && (length($best_extension1) < 7 || length($best_extension2) < 7))
                        {
                            $ext_before = "yes";
                        }
EXT_BEFORE:             if ($ext_before eq "yes" && $hp_seed_assemble eq "")
                        {
                            $l = 0;
                            $best_extension = "";
                            $SNP = "";
                            $ext = '0';
                            foreach my $ext_b (@extensions_before)
                            {
                                $ext++;
                                $extensionsb{$ext} = $ext_b;
                            }
                            $extensions_before = "yes";
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "\nEXTENSIONS FROM BEFORE\n\n";
                            }
                            $read_new = $read;                                           
                            $read_new1 = $read;
                            $best_extension_old1 = $best_extension1;
                            $best_extension_old2 = $best_extension2;
                            $best_extension_old3 = $best_extension3;
                            $best_extension_old4 = $best_extension4;
                            $SNP_active = "yes";
                            $before_shorter_skip{$id} = "yes";
                            $best_extension1 = "";
                            $best_extension2 = "";
                            $best_extension3 = "";
                            $best_extension4 = "";
                            $split = "";
                            undef %extensionsb_group1;
                            undef %extensionsb_group2;
                            undef %extensionsb_group3;
                            undef %extensionsb_group4;
                            goto NUCLEO;
                        }
JUMP_REP:               if ($repetitive_detect ne "" && ($jump_rep eq "yes" || $jump_rep_because_stuck eq "yes"))
                        {
                            my $mm2;
                            delete $jump_rep{$id};
                            my $end_repetitive = substr $read, -$insert_size-150;
                            if (length($read) < 1000)
                            {
                                $end_repetitive = $read;
                            }
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $end_repetitive." END_REP\n";
                            }
                            my $second_try = "";
                            my %repetitive_pair_tmp = %repetitive_pair;
                            my %rep_pair;
                            my %rep_pair_exclude;
REP_PAIR0:                  undef %rep_pair;
                            undef %rep_pair_exclude;
REP_PAIR:                   foreach my $rep_pair (keys %repetitive_pair)
                            {
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $rep_pair." REP_PAIR_TEST\n";
                                }
                                my $part1 = substr $rep_pair, 0, ($read_length/3)*2;
                                my $part2 = substr $rep_pair, ($read_length/3)*2-5;
                                my $r = '0';
                                my $end_repetitive_tmp = $end_repetitive;
                                while ($r < length($part1)-15)
                                {
                                    my $testit = substr $part1, $r, 15;
                                    my $found8 = $end_repetitive_tmp =~ s/$testit/$testit/;
                                    
                                    if (($found8 > 0 || $second_try eq "yes2" || $second_try eq "yes3") && length($rep_pair) > 0.9*$read_length)
                                    {
                                        my $s = '0';
                                        while ($s < length($part2)-15)
                                        {
                                            my $testit2 = substr $part2, $s, 15;
                                            my $found7 = $end_repetitive_tmp =~ s/$testit2/$testit2/;
                                            my $found9 = $part1 =~ s/$testit2/$testit2/;
                                            if ($found7 > 0 || $found9 > 0)
                                            {
                                                next REP_PAIR;
                                            }
                                            $s = $s+2;
                                        }
                                        $rep_pair{$rep_pair} = $repetitive_pair{$rep_pair};
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $rep_pair." REP_PAIR_FOUND\n";
                                        }
                                        next REP_PAIR;
                                    }
                                    $r = $r+5;
                                }
                            }
                            my $hg = '0';
                            foreach (keys %rep_pair)
                            {
                                $hg++;
                            }
                            my %temp_rep;
                            undef %temp_rep;
                            my $search_rev;
                            if ($hg eq '0')
                            {
PAIR_OF_PAIR:                   foreach my $rep_pair (keys %repetitive_pair)
                                {
                                    my $ft = '0';
                                    while ($ft < length($rep_pair) - $overlap)
                                    {
                                        my $part_rep = substr $rep_pair, $ft, $overlap;
                                        if (exists($hash2b{$part_rep}))
                                        {                       
                                            my $search = $hash2b{$part_rep};
                                            $search = substr $search, 1;
                                            my @search = split /,/,$search;
                                                                                        
                                            foreach my $search (@search)
                                            {                             
                                                my $search_tmp = substr $search, 0, -1;
                                                my $search_end = substr $search, -1;
                                                if (exists($hash{$search_tmp}))
                                                {
                                                    my @search_tmp = split /,/,$hash{$search_tmp};
                                                    my $found;
                                                    if ($search_end eq "1")
                                                    {
                                                        $found = $search_tmp[1];
                                                        $search_rev = $search_tmp."2";
                                                    }
                                                    elsif ($search_end eq "2")
                                                    {
                                                        $found = $search_tmp[0];
                                                        $search_rev = $search_tmp."1";
                                                    }
                                                    if ($encrypt eq "yes")
                                                    {
                                                        $found = decrypt $found;
                                                    }
                                                    $found =~ tr/ACTG/TGAC/;
                                                    my $found_reverse = reverse($found);
                                                    delete $repetitive_pair{$rep_pair};
                                                    $temp_rep{$found_reverse} = $search_rev;
                                                    next PAIR_OF_PAIR;
                                                }
                                            }
                                        }
                                        $ft++;
                                    }
                                    delete $repetitive_pair{$rep_pair};
                                }
                                %repetitive_pair = %temp_rep;
                                my $mm = '0';
                                foreach (keys %repetitive_pair)
                                {
                                    $mm++;
                                }
                                if ($mm > 0)
                                {
                                    if ($y > $startprint2)
                                    {
                                        print OUTPUT5 "\n"
                                    }
                                    if ($second_try eq "yes")
                                    {
                                        $second_try = "yes2";
                                    }
                                    elsif ($second_try eq "")
                                    {
                                        $second_try = "yes";
                                    }
                                    elsif ($second_try eq "yes2")
                                    {
                                         $second_try = "yes3";
                                    }
                                    elsif ($second_try eq "yes3")
                                    {
                                         goto REP_PAIR1;
                                    }
                                    goto REP_PAIR0;
                                }
                            }
REP_PAIR1a:                 my $most_match_max = '0';
                            my $id_rep = "";
                            my $rep_pair2;
REP_PAIR1:                  foreach my $rep_pair (keys %rep_pair)
                            {
                                if (exists($rep_pair_exclude{$rep_pair}))
                                {
                                    next REP_PAIR1;
                                }
                                my $part2 = substr $rep_pair, ($read_length/3)*2;
                                my $s = '0';
                                my $most_match_total = '0';
                                while ($s < length($part2)-12)
                                {
                                    my $part2b = substr $rep_pair, $s, 12;
                                    foreach my $rep_pair (keys %rep_pair)
                                    {
                                        my $check = $rep_pair =~ s/$part2b/$part2b/;
                                        if ($check > 0)
                                        {
                                            $most_match_total++;
                                        }
                                    }
                                    $s += 5;
                                }
                                if ($most_match_total > $most_match_max)
                                {
                                    $most_match_max = $most_match_total;
                                    $id_rep = $rep_pair{$rep_pair};
                                    while (exists($seed{$id_rep}))
                                    {
                                        $id_rep = "0".$id_rep;
                                    }
                                    foreach my $test (keys %contigs)                                                
                                    {
                                        if ($test =~ m/.*\+$id_rep$/)
                                        {
                                            $id_rep = "0".$id_rep;
                                        }
                                        if ($test =~ m/.*\+0$id_rep$/)
                                        {
                                            $id_rep = "00".$id_rep;
                                        }
                                    }
                                    $rep_pair2 = $rep_pair;
                                }
                            }
                            if ($id_rep ne "")
                            {
                                $noforward{$id} = "stop";
                                $noforward = "stop";
                                my $rep_pair2_tmp = $rep_pair2;
                                $rep_pair2 = correct ($rep_pair2, \%repetitive_pair);
                                if ($rep_pair2 eq "")
                                {
                                    $rep_pair_exclude{$rep_pair2_tmp} = undef;
                                    $id_rep = "";
                                    goto REP_PAIR1;
                                }
                                while (exists($seed{$id_rep}))
                                {
                                    $id_rep = '0'.$id_rep;
                                }
                                $seed{$id_rep} = $rep_pair2;
                                $seeds_check{$id_rep} = undef;
                                $nosecond{$id} = undef;
                                $nosecond = "yes";
                                $insert_size2{$id_rep} = $insert_size;
                                $position{$id_rep} = length($rep_pair2);
                                $old_id{$id_rep} = $id;
                                $old_id2{$id_rep} = undef;
                                $old_rep{$id_rep} = undef;
                                $old_rep_old{$id} = undef;
                                $seed_old{$id} = $read;
                                
                                $read_new = $read;     
                                $read_new1 = $read_new;
                                
                                if (exists($old_id{$id}))
                                {
                                    $merge_now = "yes";
                                    goto MERGE;
                                }
                                print OUTPUT5 $id_rep." ID_REP\n";
                                if ($noback eq "stop")
                                {  
                                    print OUTPUT5 ">".$id."\n";
                                    print OUTPUT5 $read."\n";
                                    delete $seed{$id};
                                    if (exists($seed_old{$id}))
                                    {
                                        $seed_old{$id} = $read;
                                    }
                                    if (!keys %seed)
                                    {
                                        $circle = "contigs";
                                        goto FINISH;
                                    }
                                    else
                                    {
                                        goto ITERATION;
                                    }
                                }
                                else
                                {
                                    print OUTPUT5 ">1\n";
                                    $noforward = "stop";
                                    $noforward{$id} = "stop";
                                    $seed_split{$id} = undef;
                                    $best_extension = "";
                                    goto BACK;
                                }
                            }
                            if ($mm2 eq "")
                            {
                                $mm2 = '0';    
                                my %rep_check;
                                undef %rep_check;

REP_CHECK0:                     foreach my $exts (keys %extensionsb_original)
                                {
                                    my $search_tmp = substr $exts, 0, -1;
                                    my $search_end = substr $exts, -1;
                                    if (exists($hash{$search_tmp}))
                                    {
                                        my @search_tmp = split /,/,$hash{$search_tmp};
                                        my $found;
                                        if ($search_end eq "1")
                                        {
                                            $found = $search_tmp[0];
                                        }
                                        elsif ($search_end eq "2")
                                        {
                                            $found = $search_tmp[1];
                                        }
                                        if ($encrypt eq "yes")
                                        {
                                            $found = decrypt $found;
                                        }
                                        $found =~ tr/ACTG/TGAC/;
                                        my $found2 = reverse($found);
                                 if ($y > $startprint2)
                                {
                                    print OUTPUT5 $found2." REP_PAIR_TEST_B\n";
                                }                       
                                        $rep_check{$found2} = $exts;
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $found2." REP_PAIR_FOUND_B\n";
                                        }
                                        next REP_CHECK0;
                                    }
                                }
                            
                                foreach (keys %rep_check)
                                {
                                    $mm2++;
                                }
                                if ($mm2 > 0)
                                {
                                    %repetitive_pair = %rep_check;
                                    goto REP_PAIR0;
                                }
                            }
                            $noforward{$id} = "stop";
                        }
                        $before_shorter_skip{$id} = "yes";
                        if ($before_shorter_skip eq "yes")
                        {
                            $before{$id} = "yes";
                        }
                        $best_extension = "";
                        $read_new = $read;     
                        $read_new1 = $read_new;

                        if ($count_split > 2)
                        {
                            my $tmp = '0';
                            if ($first_yuyu2 eq '0' || (($count1b_tmp+$count2b_tmp+$count3b_tmp+$count4b_tmp) > 4 && $count1b_tmp eq '0'))
                            {
                                $yuyu_option{$id.$firstSNP_max[$tmp]} = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $firstSNP_max[$tmp]." FIRST_YUYU\n";
                                }
                            }
                            $tmp++;
                            if ($second_yuyu2 eq '0' || (($count1b_tmp+$count2b_tmp+$count3b_tmp+$count4b_tmp) > 4 && $count2b_tmp eq '0'))
                            {
                                $yuyu_option{$id.$firstSNP_max[$tmp]} = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $firstSNP_max[$tmp]." SECOND_YUYU\n";
                                }
                            }
                            $tmp++;
                            if ($third_yuyu2 eq '0' || (($count1b_tmp+$count2b_tmp+$count3b_tmp+$count4b_tmp) > 4 && $count3b_tmp eq '0'))
                            {
                                $yuyu_option{$id.$firstSNP_max[$tmp]} = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $firstSNP_max[$tmp]." THIRD_YUYU\n";
                                }
                            }
                            $tmp++;
                            if ($fourth_yuyu2 eq '0' || (($count1b_tmp+$count2b_tmp+$count3b_tmp+$count4b_tmp) > 4 && $count4b_tmp eq '0'))
                            {
                                $yuyu_option{$id.$firstSNP_max[$tmp]} = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $firstSNP_max[$tmp]." FOURTH_YUYU\n";
                                }
                            }
                        }
                    }
                }
                my $rep_no_split = "";
                if ($jump_rep ne "yes" && $repetitive_detect ne "")
                {
                    my $read_end9 = substr $read_short_end2, -$read_length;
                    my $ext1 = substr $best_extension1, 0, 9;
                    my $ext2 = substr $best_extension2, 0, 9;
                    $ext1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                    $ext2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                    my $check_ext1 = $read_end9 =~ s/(.)$ext1/$1$ext1/;
                    my $check_ext2 = $read_end9 =~ s/(.)$ext2/$1$ext2/;
                    if ($check_ext1 > 0 || $check_ext2 > 0)
                    {
                        $rep_no_split = "yes";
                    }
                }
                if ($jump_rep ne "yes")
                {
                    my $read_end9 =  substr $read_short_end2, -($read_length+100);
                    my $ext1 = substr $best_extension1, 0, 50;
                    my $ext2 = substr $best_extension2, 0, 50;
                    $ext1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                    $ext2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                    my $check_ext1 = $read_end9 =~ s/(.)$ext1/$1$ext1/;
                    my $check_ext2 = $read_end9 =~ s/(.)$ext2/$1$ext2/;
                    if (($check_ext1 > 0 && length($best_extension1) > 20) || ($check_ext2 > 0 && length($best_extension2) > 20))
                    {
                        $rep_no_split = "yes";
                        $repetitive_detect = "yes";
                    }
                }            
                if ($SNR_read eq "" && (length($best_extension1) > 9 || length($best_extension2) > 9))
                {
                    my $test_read1 = AT_rich_test ($best_extension1, length($best_extension1)*0.3);
                    my $test_read2 = AT_rich_test ($best_extension2, length($best_extension2)*0.3);
                    if (($test_read1 eq "yes" || length($best_extension1) < 7) && ($test_read2 eq "yes" || length($best_extension2) < 7))
                    {
                        $SNR_read = "yes";
                        $SNR_read2 = "yes";
                        print OUTPUT5 "SNR_ON\n";
                    }
                }        
        
                my $count_best_ext = '0';
                if ($best_extension1 ne "")
                {
                    $count_best_ext++;
                }
                if ($best_extension2 ne "")
                {
                    $count_best_ext++;
                }
                if ($best_extension3 ne "")
                {
                    $count_best_ext++;
                }
                if ($best_extension4 ne "")
                {
                    $count_best_ext++;
                }
                if ($y > $startprint2)
                {
                    print OUTPUT5 $count_best_ext." COUNT_BEST_EXT\n";
                }
                if ($count_best_ext < 2 || $deletion ne "")
                {
                    goto AFTER_EXT;
                }
                elsif ($SNP_active eq "" && $count_best_ext > 1 && $deletion eq "")
                {
                    $best_extension = "";
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "SNP_ACTIVE\n";
                    }
                    $SNP_active{$id} = "yes";

                    $read_new = $read;     
                    $read_new1 = $read_new;
                    goto BACK;
                }
                elsif ($SNP_active eq "" && $count_best_ext > 1 && $deletion eq "" && length($read) < ($insert_size-$overlap) && $noback eq "")
                {
                    $best_extension = "";
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "WAIT FOR BACK\n";
                    }
                    $SNP_active{$id} = "yes";

                    $read_new = $read;     
                    $read_new1 = $read_new;
                    goto BACK;
                }
                
                if ($y > $startprint2)
                {
                    print OUTPUT5 "ELSE\n";
                }
                my $best_extension1_tmpi = $best_extension1;
                my $best_extension2_tmpi = $best_extension2;
                my $best_extension3_tmpi = $best_extension3;
                my $best_extension4_tmpi = $best_extension4;
                
                $best_extension1_tmpi =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                $best_extension2_tmpi =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                my $v = '0';
                my $missmatch = '0';
                while ($v < length($best_extension1_tmpi) && $v < length($best_extension2_tmpi))
                {
                    my $one = substr $best_extension1_tmpi, $v, 1;
                    my $two = substr $best_extension2_tmpi, $v, 1;
                    if ($one ne "." && $two ne "." && $one ne $two)
                    {
                        $missmatch++;
                    }
                    $v++;
                }
                
                $best_extension1_tmpi =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\.//d;
                $best_extension2_tmpi =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\.//d;
                $best_extension3_tmpi =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\.//d;
                $best_extension4_tmpi =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\.//d;
                my $vv = '14';
                if ($best_extension3 ne "")
                {
                    $vv = '21';
                }
                if ($best_extension4 ne "")
                {
                    $vv = '28';
                }

                if ($SNR_read ne "" && (length($best_extension1_tmpi)+length($best_extension2_tmpi)+length($best_extension3_tmpi)+length($best_extension4_tmpi)) < $vv)
                {
                    $SNR_next_seed = "yes";
                    $noforward{$id} = "stop";
                    delete $seed{$id};
                    $noforward = "stop";
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "SNR_NEXT_SEED\n";
                    }
                    goto BACK;
                }
 
                if ($hp_back eq "" && ($SNR_read ne "" || $SNR_critical ne "" || $SNR_critical_pos{$id} > $position-80) &&
                    ($missmatch < 2 || ($missmatch < 4 && length($best_extension1_tmpi) > 15 && length($best_extension2_tmpi) > 15) ||
                     ($SNR_read2 ne "" && $missmatch < 0.3*$v)) && $rep_no_split ne "yes")
                {
                    $SNR_next_seed = "yes";
                    $noforward{$id} = "stop";
                    $noforward = "stop";
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "SNR_NEXT_SEED\n";
                    }
                    goto BACK;
                }
                if ($hp_seed_assemble ne "")
                {
                    if (exists($large_variance_forward{$id}))
                    {
                        $NUMT = "yes";
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "NUMT_SPLIT\n";
                        }  
                    }
                    $noforward = "stop";
                    $noforward{$id} = "stop_HP";
                    goto BACK;
                }
                if ($hp_back eq "" && $jump_rep ne "yes" && $repetitive_detect ne "" && ($rep_no_split eq "yes" || $repetitive_detect2 eq "yes"))
                {
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "JUMP REP\n";
                    }
                    $jump_rep{$id} = "yes";
                    $best_extension = "";
                    $read_new = $read;     
                    $read_new1 = $read_new;
                    goto BACK;
                }
                elsif($resolve_split_manually eq "yes" || ($heteroplasmy eq "" && $hp_back eq "" && $deletion ne "yes" && $reference_guided ne "yes" &&
                     ($repetitive_detect eq "" || $long_repeat_forward eq "yes") && $hp_seed_assemble eq "" && $SNP_active eq "yes" && $count_best_ext > 1))
                {
                    if($resolve_split_manually eq "yes")
                    {
                        print "\n\n";
                        my $count_group1 = '0';
                        my $count_group2 = '0';
                            foreach my $extensions_tmp (keys %extensionsb_group1_old)
                            {  
                                print $extensionsb_group1_old{$extensions_tmp}."\n";
                                $count_group1++;
                            }
                        print "\n\n";
                            foreach my $extensions_tmp (keys %extensionsb_group2_old)
                            {  
                                print $extensionsb_group2_old{$extensions_tmp}."\n";
                                $count_group2++;
                            }
                        print "\n\n".$read_end." READ END\n\n";
                        print $ref_check_forward." REF SEQ\n\n";
                        print "\n".$best_extension1." ".$count_group1." OPTION1\n";
                        print "\n".$best_extension2." ".$count_group2." OPTION2\n";
                        $best_extension = <>;
                        chomp($best_extension);
                        if ($best_extension ne "")
                        {
                            $best_extension1 = "";
                            $best_extension2 = "";
                            $best_extension3 = "";
                            $best_extension4 = "";
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "\n".$best_extension." MANUALLY SELECTED\n\n";
                            }
                            delete $SNP_active{$id};
                            delete $before_shorter_skip{$id};
                            delete $before{$id};
                            goto AFTER_EXT;
                        }
                    }
                    if($heteroplasmy eq "" && $hp_back eq "" && $deletion ne "yes" && $reference_guided ne "yes" &&
                       ($repetitive_detect eq "" || $long_repeat_forward eq "yes") && $hp_seed_assemble eq "" && $SNP_active eq "yes" && $count_best_ext > 1)
                    {
                        if (exists $old_id{$id} && ($noback eq "stop" || $position_back >= ($insert_size*3)))
                        {                                     
                            $merge_read_length = length($read);
                            $merge_read = "yes"; 
                            $read = $seed_old{$old_id{$id}} ."LLLLLLLLLLLLLLL".$read;
                            $seed{$id} = $read;
                            $hasL = "yes";
                            foreach my $tree_tmp (keys %tree)
                            {
                                my $old = $old_id{$id};
                                my $tree2 = $tree{$tree_tmp};
                                my $tree3 = $tree{$tree_tmp};
                                if ($old_id{$id} =~ m/.*_(\d+)$/)
                                {
                                    $old = $1;
                                }
                                my $id_tmp = $id;
                                if ($id =~ m/.*_(\d+)$/)
                                {
                                    $id_tmp = $1;
                                }
                                my @ids_split = split /\*/, $tree2;
                                foreach my $id_split (@ids_split)
                                {
                                    if ($id_split  =~ m/^$old(B*REP)*$/)
                                    {
                                        if ($tree2 =~ m/^(.*\*)*$old(B*REP)*(\*.*)*$/)
                                        {
                                            if (defined($1))
                                            {
                                                $tree3 = $1.$id_tmp;
                                            }
                                            else
                                            {
                                                $tree3 = $id_tmp;
                                            }
                                            if (defined($2))
                                            {
                                                if ($2 eq "BREP")
                                                {
                                                    $tree3 = $tree3."REPB";
                                                }
                                                else
                                                {
                                                    $tree3 = $tree3."REP";
                                                }
                                            }
                                            if (defined($3))
                                            {
                                                $tree3 = $tree3.$3;
                                            }
                                        }
                                    }
                                }
                                delete $tree{$tree_tmp};
                                $tree{$tree_tmp} = $tree3;
                                foreach my $contigs_end (keys %contigs_end)
                                {
                                    if ($contigs_end{$contigs_end} eq $old)
                                    {
                                        delete $contigs_end{$contigs_end};
                                        $contigs_end{$contigs_end} = $id_tmp;
                                    }
                                }
                            }
                            delete $old_id{$id};
                            $noback{$id} = "stop";
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "Merged contigs with LLLLLLLLLLL!\n";
                            }
                            $contig_gap_min{$id."_".$contig_count} = ($contig_gap_min{$id."_".$contig_count}-$position_back);
                            $contig_gap_max{$id."_".$contig_count} = ($contig_gap_max{$id."_".$contig_count}-$position_back);
                        }
                        $best_extension = "";
                        
                        delete $seed{$id};
                        $seed{$id} = $read;
                        $seeds_check{$id} = undef;
                        $read_new = $read;
                        $read_new1 = $read;                 

                        if ($y > $startprint2)
                        {
                            print OUTPUT5 ">".$id."\n";
                            print OUTPUT5 $read."\n\n\n";
                        }
                        my $best_ex1 = substr $best_extension1, 0, 7;
                        my $best_ex2 = substr $best_extension2, 0, 7;
                        my $best_ex3 = substr $best_extension3, 0, 7;
                        my $best_ex4 = substr $best_extension4, 0, 7;
                        $best_ex1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        $best_ex2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        $best_ex3 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        $best_ex4 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        my $contigs_end0 = substr $read_end, -10;
                        my $read_short_end2_tmp = $read_short_end2;
                        my $check_rep1 = $read_short_end2_tmp =~ s/$contigs_end0$best_ex1/$contigs_end0$best_ex1/g;
                        my $check_rep2 = $read_short_end2_tmp =~ s/$contigs_end0$best_ex2/$contigs_end0$best_ex2/g;
                        my $check_rep3 = $read_short_end2_tmp =~ s/$contigs_end0$best_ex3/$contigs_end0$best_ex3/g;
                        my $check_rep4 = $read_short_end2_tmp =~ s/$contigs_end0$best_ex4/$contigs_end0$best_ex4/g;
                        
CORRECT:                my $contig_id2_tmp = substr $contig_id2, 0,-1;
                                             
                        my $contigs_end1 = substr $best_extension1, 0, 7;
                        my $contigs_end2 = substr $best_extension2, 0, 7;
                        my $contigs_end3 = substr $best_extension3, 0, 7;
                        my $contigs_end4 = substr $best_extension4, 0, 7;
                        $contigs_end1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        $contigs_end2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        $contigs_end3 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        $contigs_end4 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        $contigs_end0 = substr $read_end, -15;
                        my $tree_empty = "";
                        
                        if (exists($contigs_id{$contig_id2}) || exists($contigs_end{$contigs_end0.$contigs_end2}))
                        {
                            $tree{$id} = $contigs_end{$contigs_end0.$contigs_end2};
                            $tree_empty = "yes";
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "TREE_EMPTY2\n";
                            }
                        }
                        else
                        {
                            $seed{$contig_id2} = $contig_read2;
                            $seeds_check{$contig_id2} = undef;
                            $insert_size2{$contig_id2} = $insert_size;
                            $position{$contig_id2} = length($contig_read2);
                            $old_id2{$contig_id2} = undef;
                            $noback{$contig_id2} = "stop";
                            
                            $contigs_id{$contig_id2} = undef;
                            $contigs_end{$contigs_end0.$contigs_end2} = $contig_id2;
                            $correct_after_split = "yes";
                            $tree{$id} = $contig_id2;
                            
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $contig_id2." CONTIG_ID2\n";
                                print OUTPUT5 $best_extension2." best_ext2\n";
                                my $contig_id2hhh = substr $contig_id2, 0 ,-1;
                                if (exists($hash{$contig_id2hhh}))
                                {
                                    print OUTPUT5 $hash{$contig_id2hhh}." HASH2\n";
                                }
                            }
                            if (length($read) < 251)
                            {
                                delete $seed{$contig_id2};
                                $seed{$contig_id2} = $read.$best_extension2;
                                $seeds_check{$contig_id2} = undef;
                                delete $tree{$id};
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "SHORT2\n";
                                }
                                foreach my $tree_tmp (keys %tree)
                                {
                                    my $tmp = $tree{$tree_tmp};
                                    my @ids_split = split /\*/, $tmp;
                                    foreach my $id_split (@ids_split)
                                    {
                                        if ($id_split eq $id)
                                        {
                                            delete $tree{$tree_tmp};
                                            if ($tmp =~ m/^(.*\*)*$id(\*.*)*$/)
                                            {
                                                if (defined($1))
                                                {
                                                    $tmp = $1.$contig_id2;
                                                }
                                                else
                                                {
                                                    $tmp = $contig_id2;
                                                }
                                                if (defined($2))
                                                {
                                                    $tmp = $tmp.$2;
                                                }
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 $tmp." TESTOOO5\n";
                                                }
                                                $tree{$tree_tmp} = $tmp;
                                                foreach my $end_tmp (keys %contigs_end)
                                                {
                                                    if ($contigs_end{$end_tmp} eq $id)
                                                    {
                                                        delete $contigs_end{$end_tmp};
                                                        $contigs_end{$end_tmp} = $contig_id2;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (exists($contigs_id{$contig_id1}) || exists($contigs_end{$contigs_end0.$contigs_end1}))
                        {
                            if ($tree_empty eq "yes")
                            {
                                $tree{$id} = $contigs_end{$contigs_end0.$contigs_end2}."*".$contigs_end{$contigs_end0.$contigs_end1};
                            }
                            else
                            {
                                $tree{$id} = $contig_id2."*".$contigs_end{$contigs_end0.$contigs_end1};
                            }
                        }
                        else
                        {
                            
                            $seed{$contig_id1} = $contig_read1;
                            $seeds_check{$contig_id1} = undef;
                            $insert_size2{$contig_id1} = $insert_size;
                            $position{$contig_id1} = length($contig_read1);
                            $old_id2{$contig_id1} = undef;
                            $noback{$contig_id1} = "stop";
                            
                            $contigs_id{$contig_id1} = undef;
                            $contigs_end{$contigs_end0.$contigs_end1} = $contig_id1;
                            $correct_after_split = "yes";
                            
                            if ($tree_empty eq "yes")
                            {
                                $tree{$id} =  $contigs_end{$contigs_end0.$contigs_end2}."*".$contig_id1;
                            }
                            else
                            {
                                $tree{$id} = $contig_id2."*".$contig_id1;
                            }
                                                                        
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $contig_id1." CONTIG_ID1\n";
                                print OUTPUT5 $best_extension1." best_ext1\n";
                                my $contig_id1hhh = substr $contig_id1, 0 ,-1;
                                if (exists($hash{$contig_id1hhh}))
                                {
                                    print OUTPUT5 $hash{$contig_id1hhh}." HASH1\n";
                                }
                            }
                            if (length($read) < 251)
                            {
                                delete $seed{$contig_id1};
                                $seed{$contig_id1} = $read.$best_extension1;
                                $seeds_check{$contig_id1} = undef;
                                delete $tree{$id};
                                foreach my $tree_tmp (keys %tree)
                                {
                                    my $tmp = $tree{$tree_tmp};
                                    my @ids_split = split /\*/, $tmp;
                                    foreach my $id_split (@ids_split)
                                    {
                                        if ($tree_empty eq "yes")
                                        {
                                            if ($id_split eq $id)
                                            {
                                                delete $tree{$tree_tmp};
                                                if ($tmp =~ m/^(.*\*)*$id(\*.*)*$/)
                                                {
                                                    if (defined($1))
                                                    {
                                                        $tmp = $1.$contig_id1;
                                                    }
                                                    else
                                                    {
                                                        $tmp = $contig_id1;
                                                    }
                                                    if (defined($2))
                                                    {
                                                        $tmp = $tmp.$2;
                                                    }
                                                    $tree{$tree_tmp} = $contigs_end{$contigs_end0.$contigs_end2}."*".$tmp;
                                                    if ($y > $startprint2)
                                                    {
                                                        print OUTPUT5 $tree{$tree_tmp}." TESTOOO4a-----------------\n";
                                                    }
                                                    foreach my $end_tmp (keys %contigs_end)
                                                    {
                                                        if ($contigs_end{$end_tmp} eq $id)
                                                        {
                                                            delete $contigs_end{$end_tmp};
                                                            $contigs_end{$end_tmp} = $contig_id1;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if ($id_split eq $contig_id2)
                                            {
                                                delete $tree{$tree_tmp};
                                                $tree{$tree_tmp} = $contig_id1."*".$tmp;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 $tree{$tree_tmp}." TESTOOO5------------\n";
                                                }
                                                foreach my $end_tmp (keys %contigs_end)
                                                {
                                                    if ($contigs_end{$end_tmp} eq $contig_id2)
                                                    {
                                                        delete $contigs_end{$end_tmp};
                                                        $contigs_end{$end_tmp} = $contig_id2."*".$contig_id1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if ($count_split > 2)
                        {
                            if (exists($contigs_id{$contig_id3}) || exists($contigs_end{$contigs_end0.$contigs_end3}))
                            {
                                $tree{$id} = $contigs_end{$contigs_end0.$contigs_end3};
                                $tree_empty = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "TREE_EMPTY3\n";
                                }
                            }
                            else
                            {
                                $seed{$contig_id3} = $contig_read3;
                                $seeds_check{$contig_id3} = undef;
                                $insert_size2{$contig_id3} = $insert_size;
                                $position{$contig_id3} = length($contig_read3);
                                $old_id2{$contig_id3} = undef;
                                $noback{$contig_id3} = "stop";
                                
                                $contigs_id{$contig_id3} = undef;
                                $contigs_end{$contigs_end0.$contigs_end3} = $contig_id3;
                                $correct_after_split = "yes";
                                $tree{$id} = $contig_id3;
                                
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $contig_id3." CONTIG_ID3\n";
                                    print OUTPUT5 $best_extension3." best_ext3\n";
                                    my $contig_id3hhh = substr $contig_id3, 0 ,-1;
                                    if (exists($hash{$contig_id3hhh}))
                                    {
                                        print OUTPUT5 $hash{$contig_id3hhh}." HASH3\n";
                                    }
                                }
                                if (length($read) < 251)
                                {
                                    delete $seed{$contig_id3};
                                    $seeds_check{$contig_id3} = undef;
                                    $seed{$contig_id3} = $read.$best_extension3;
                                    delete $tree{$id};
                                    if ($y > $startprint2)
                                    {
                                        print OUTPUT5 "SHORT2\n";
                                    }
                                    foreach my $tree_tmp (keys %tree)
                                    {
                                        my $tmp = $tree{$tree_tmp};
                                        my @ids_split = split /\*/, $tmp;
                                        foreach my $id_split (@ids_split)
                                        {
                                            if ($id_split eq $id)
                                            {
                                                delete $tree{$tree_tmp};
                                                if ($tmp =~ m/^(.*\*)*$id(\*.*)*$/)
                                                {
                                                    if (defined($1))
                                                    {
                                                        $tmp = $1.$contig_id3;
                                                    }
                                                    else
                                                    {
                                                        $tmp = $contig_id3;
                                                    }
                                                    if (defined($2))
                                                    {
                                                        $tmp = $tmp.$2;
                                                    }
                                                    if ($y > $startprint2)
                                                    {
                                                        print OUTPUT5 $tmp." TESTOOO5\n";
                                                    }
                                                    $tree{$tree_tmp} = $tmp;
                                                    foreach my $end_tmp (keys %contigs_end)
                                                    {
                                                        if ($contigs_end{$end_tmp} eq $id)
                                                        {
                                                            delete $contigs_end{$end_tmp};
                                                            $contigs_end{$end_tmp} = $contig_id3;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if ($count_split > 3)
                        {
                            if (exists($contigs_id{$contig_id4}) || exists($contigs_end{$contigs_end0.$contigs_end4}))
                            {
                                $tree{$id} = $contigs_end{$contigs_end0.$contigs_end4};
                                $tree_empty = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "TREE_EMPTY4\n";
                                }
                            }
                            else
                            {
                                $seed{$contig_id4} = $contig_read4;
                                $seeds_check{$contig_id4} = undef;
                                $insert_size2{$contig_id4} = $insert_size;
                                $position{$contig_id4} = length($contig_read4);
                                $old_id2{$contig_id4} = undef;
                                $noback{$contig_id4} = "stop";
                                
                                $contigs_id{$contig_id4} = undef;
                                $contigs_end{$contigs_end0.$contigs_end4} = $contig_id4;
                                $correct_after_split = "yes";
                                $tree{$id} = $contig_id4;
                                
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $contig_id4." CONTIG_ID4\n";
                                    print OUTPUT5 $best_extension4." best_ext4\n";
                                    my $contig_id4hhh = substr $contig_id4, 0 ,-1;
                                    if (exists($hash{$contig_id4hhh}))
                                    {
                                        print OUTPUT5 $hash{$contig_id4hhh}." HASH4\n";
                                    }
                                }
                                if (length($read) < 251)
                                {
                                    delete $seed{$contig_id4};
                                    $seed{$contig_id4} = $read.$best_extension4;
                                    $seeds_check{$contig_id4} = undef;
                                    delete $tree{$id};
                                    if ($y > $startprint2)
                                    {
                                        print OUTPUT5 "SHORT4\n";
                                    }
                                    foreach my $tree_tmp (keys %tree)
                                    {
                                        my $tmp = $tree{$tree_tmp};
                                        my @ids_split = split /\*/, $tmp;
                                        foreach my $id_split (@ids_split)
                                        {
                                            if ($id_split eq $id)
                                            {
                                                delete $tree{$tree_tmp};
                                                if ($tmp =~ m/^(.*\*)*$id(\*.*)*$/)
                                                {
                                                    if (defined($1))
                                                    {
                                                        $tmp = $1.$contig_id4;
                                                    }
                                                    else
                                                    {
                                                        $tmp = $contig_id4;
                                                    }
                                                    if (defined($2))
                                                    {
                                                        $tmp = $tmp.$2
                                                    }
                                                    if ($y > $startprint2)
                                                    {
                                                        print OUTPUT5 $tmp." TESTOOO5\n";
                                                    }
                                                    $tree{$tree_tmp} = $tmp;
                                                    foreach my $end_tmp (keys %contigs_end)
                                                    {
                                                        if ($contigs_end{$end_tmp} eq $id)
                                                        {
                                                            delete $contigs_end{$end_tmp};
                                                            $contigs_end{$end_tmp} = $contig_id4;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if ($noback eq "stop")
                        {                    
                            if (exists($old_id{$id}))
                            {
                                my $read_tmp = $seed_old{$old_id{$id}};
                                if (length($read_tmp) > 250)
                                {
                                    if ($contig_num eq '1')
                                    {
                                        $contigs{$contig_num."+".$id} = $read_tmp;
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $contig_num."+".$id." ADD_CONTIG10\n";
                                        }
                                        contig_start ($read_tmp); 
                                    }
                                    else
                                    {
                                        $contigs{$contig_num."+".$old_id{$id}} = $read_tmp;
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $contig_num."+".$id." ADD_CONTIG11\n";
                                        }
                                    }
                                    $contig_num++;    
                                }
                            }
                            if (length($read) > 250)
                            {   
                                if ($contig_num eq '1')
                                {
                                    $contigs{$contig_num."+".$id} = $read;
                                    if ($y > $startprint2)
                                    {
                                        print OUTPUT5 $contig_num."+".$id." ADD_CONTIG12\n";
                                    }
                                    contig_start ($read); 
                                }
                                else
                                {
                                    $contigs{$contig_num."+".$id} = $read;
                                    if ($y > $startprint2)
                                    {
                                        print OUTPUT5 $contig_num."+".$id." ADD_CONTIG13\n";
                                    }
                                }
                                $contig_num++;
                            }
                            delete $seed{$id};
                            if (!keys %seed)
                            {
                                $circle = "contigs";
                                goto FINISH;
                            }
                            else
                            {
                                goto ITERATION;
                            }
                        }
                        else
                        {
                            $noforward = "stop";
                            $noforward{$id} = "stop";
                            $seed_split{$id} = undef;
                            $best_extension = "";
                            goto BACK;
                        }
                    }
                    else
                    {
                        $noforward = "stop";
                        $noforward{$id} = "stop";
                        $best_extension = "";
                        print OUTPUT5 "STOP_FORWARD2\n";
                        goto BACK;
                    }
                }
            }
            else
            {                             
                if ($y > $startprint2)
                {
                    print OUTPUT5 $best_extension." BEST_EXTENSION\n\n";
                }
                $best_extension_prev{$id} = $best_extension;    
            }  
AFTER_EXT:

                                            chomp $best_extension;
                                            my $vk2 = '0';
                                            if ($SNR_read eq "" && length($best_extension) > 2 && $heteroplasmy eq "")
                                            {
                                                my $best_extension_tmp7 = $best_extension;
                                                $best_extension_tmp7 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                
                                                my @dot2 = split //, $best_extension_tmp7;
                                                my $ut2 = length($best_extension_tmp7);
                                                
                                                while ($dot2[$ut2-1] eq "." || $dot2[$ut2-1] eq "*")
                                                {              
                                                    if ($dot2[$ut2-1] eq "*")
                                                    {
                                                        chop $best_extension;
                                                        chop $best_extension;
                                                        $vk2++;
                                                        $vk2++;
                                                        $ut2--;
                                                        $ut2--;
                                                    }
                                                    else
                                                    {                                                     
                                                        chop $best_extension;
                                                        $vk2++;
                                                        $ut2--;
                                                    }
                                                }
                                            }
                                            my $best_extension_tmpp = substr $best_extension, -15;
                                            my $SNR_check = $best_extension_tmpp =~ qr/AAAAAAA|CCCCCCC|GGGGGGG|TTTTTTT/;
                                            if ($SNR_check > 0 && $variance_detection eq "" && $heteroplasmy eq "")
                                            {
                                                if ($best_extension =~ m/((.*?)(A{7,}|C{7,}|G{7,}|T{7,}))(.*)/)
                                                {
                                                    if (length($4) < 5)
                                                    {
                                                        my $best_extension_short = substr $best_extension, 0, length($2)+7;
                                                        $best_extension = $best_extension_short;
                                                        if ($y > $startprint2)
                                                        {
                                                            print OUTPUT5 $best_extension." BEST_EXTENSION_SHORT\n\n";
                                                        }
                                                    }
                                                }
                                            }
                                            if ($split eq "")
                                            {
                                                $read_new = $read;                                           
                                                $read_new1 = $read_new;
                                            }
                                            if ($best_extension ne "" && $best_extension ne " ")
                                            {                                                                               
                                                $read_new = $read.$best_extension;                                           
                                                $read_new1 = $read_new;
                                                
                                                $position += length($best_extension);
                                                $position -= $vk2;                                    

                                                delete $position{$id};
                                                $position{$id} = $position;
                                                if (exists($large_variance_forward{$id}))
                                                {
                                                    $NUMT{$id} = $NUMT{$id}+length($best_extension);
                                                }

                                                if ($split eq "" || $extensions_before ne "")
                                                {
                                                    delete $before{$id};
                                                    delete $before_shorter_skip{$id};
                                                    delete $no_next_seed{$id};
                                                }
                                                if (exists($last_ref_seq_forward{$id}) && $split eq "" && $ref_check_forward ne "" && $save_seq_ref_forward ne "no2")
                                                {
                                                    my $seq_tmp = $last_ref_seq_forward{$id};
                                                    my $extra_seq = substr $ref_check_forward, 0, length($best_extension);
                                                    $last_ref_seq_forward{$id} = $seq_tmp.$extra_seq;
                                                    $last_ref_pos_forward{$id} = $last_ref_pos_forward{$id}+length($extra_seq);
                                                }
                                                if (exists($large_variance_forward{$id}) && $split eq "")
                                                {
                                                    $large_variance_length_forward{$id} = $large_variance_length_forward{$id}+length($best_extension);
                                                }
                                                $best_extension_forward = $best_extension;
                                                $best_extension = "";
                                                delete $regex{$id};
                                                delete $SNR_critical{$id};
                                                delete $SNP_active{$id};
                                                if ($split eq "")
                                                {
                                                    delete $yuyu_option{$id."A"};
                                                    delete $yuyu_option{$id."C"};
                                                    delete $yuyu_option{$id."T"};
                                                    delete $yuyu_option{$id."G"};
                                                    delete $before_shorter_skip{$id};
                                                    $need_longer_ext = "";
                                                }

                                                if (($SNR_go_last_chance < $position-5 && $SNR_read2 eq "") || $SNR_go_last_chance eq "")
                                                {
                                                    delete $last_chance{$id};
                                                    $SNR_go_last_chance = "";
                                                }

                                                if ($split eq "" && $jump_rep_because_stuck ne "")
                                                {
                                                    delete $jump_rep_because_stuck{$id};
                                                    $count_stuck_in_rep++;
                                                }
                                                $id_test = $id;
                                                if ($hp_seed_assemble_last_chance_forward eq "yes" && length($read) < $insert_size*1.6 && $split eq "")
                                                {
                                                    $hp_seed_assemble_last_chance_forward = "";
                                                }
                                                if ($split eq "")
                                                {
                                                    foreach my $add_read2 (keys %extensionsb)
                                                    {
                                                        my $add_read = substr $add_read2, 0, -1;
                                                        $count_reads{$add_read} = undef;
                                                    }
                                                }
                                            }
                                            elsif ($SNR_critical eq "yes1")
                                            {
                                                $read_new = $read;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION_CRITICAL\n";
                                                }
                                            }
                                            elsif ($use_regex eq "" && $repetitive_detect eq "" && $last_chance ne "yes" )
                                            {                                              
                                                delete $regex{$id};
                                                if ($split_forward eq "")
                                                {
                                                    $regex{$id} = "yes";
                                                }
                                                elsif ($split_forward ne "")
                                                {
                                                    $SNP_active{$id} = "yes";
                                                }
                                                $read_new = $read;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION1\n";
                                                }
                                            }
                                            elsif ($SNP_active eq "")
                                            {
                                                $read_new = $read;
                                                $SNP_active{$id} = "yes";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION3\n";
                                                }
                                            }
                                            elsif ($last_chance eq "")
                                            {
                                                $read_new = $read;
                                                $last_chance{$id} = "yes";
                                                delete $SNP_active{$id};
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION3b\n";
                                                }
                                            }
                                            elsif (($use_regex ne "" || $repetitive_detect ne "") && $last_chance ne "yes" && ($AT_rich_before eq "" || $mmr < 15))
                                            {
                                                $read_new = $read;
                                                delete $last_chance{$id};
                                                $last_chance{$id} = "yes";
                                                delete $regex{$id};
                                                $use_regex = "";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION4\n";
                                                }
                                            }
                                            elsif ($last_chance eq "yes" && $use_regex ne "yes" && $repetitive_detect eq "" && $hp_seed_assemble eq "")
                                            {
                                                $read_new = $read;
                                                delete $last_chance{$id};
                                                $last_chance{$id} = "yes";
                                                delete $regex{$id};
                                                $regex{$id} = "yes";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION5\n";
                                                }
                                            }
                                            elsif (($last_chance eq "yes" || $AT_rich_before ne "") && $use_regex ne "")
                                            {
                                                $read_new = $read;
                                                delete $last_chance{$id};
                                                $noforward = "stop";
                                                $noforward{$id} = $noforward;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION6\n";
                                                }
                                            }
                                            else
                                            {
                                                $noforward = "stop";
                                                $noforward{$id} = $noforward;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION7\n";
                                                }
                                            }
                                                                
BACK:   if ($y > $startprint2 && $benchmark_time eq "yes")
        {
            $time_back = time;    
            if ($time_back - $time_collect_ext > 1 && $noforward eq "")
            {
                print OUTPUT5 $time_back - $time_collect_ext." TIME_BACK\n";
            }
        }
        if ($ref_skip_before eq "yes")
        {
            if (exists($last_ref_seq_forward{$id}) && $split eq "" && $save_seq_ref_forward ne "no2")
            {
                my $seq_tmp = $last_ref_seq_forward{$id};
                $last_ref_seq_forward{$id} = $seq_tmp.$best_extension;
                $last_ref_pos_forward{$id} = $last_ref_pos_forward{$id}+length($best_extension);
            }
            if (exists($large_variance_forward{$id}) && $split eq "")
            {
                $large_variance_length_forward{$id} = $large_variance_length_forward{$id}+length($best_extension);
            }
        }
        if (keys %merged_match_back eq 0 && $use_regex_back ne "yes" && $noback eq "" && $circle eq "" )
        {                                              
            delete $regex_back{$id};
            $regex_back{$id} = "yes";
            $best_extension_back_prev{$id} = "";
        }
        elsif (keys %merged_match_back eq 0 && $use_regex_back eq "yes")
        {
            $noback{$id} = "stop";
            $best_extension_back_prev{$id} = "";
        }
        if (keys %merged_match_back > 0 && $noback ne "stop" )
        {
            undef %extensions1b;
            undef %extensions2b;
            undef %extensionsb;
            undef %extensionsb_original;
            undef @matches;
            undef @matches1;
            undef @matches2;
            undef %SNR_length;
            undef %remove_extension_mismatch;
            undef %extensions_for_before;
            undef %extensions_for_before_match;
            undef %extensions_for_before_match_pair;
            $split_forward = "";
            $split = "";
            $extensions_before = "";
            $ext_before = "";
            $best_extension_old1 = "";
            $best_extension_old2 = "";
            $best_extension_old3 = "";
            $best_extension_old4 = "";
        
REGEX_BACK:
            $read_count = '0';
            $read_ex = '0';

            if ($y > $startprint2)
            {
                if ($use_regex_back eq "yes")
                {
                    print OUTPUT5 "USE_REGEX_BACK_REVERSE\n";
                }
            }

            my $extra_overlap = "";
            my $read_short_start_tempie = "";
            my $read_short_start_3b = "";
            my $test_dot = '0';
            my $test_star = '0';
            my %hash_read_short_start;
            my %hash_read_short_start_dot;
            undef %hash_read_short_start;
            undef %hash_read_short_start_dot;
            my @read_short_start_tmp2;
            undef @read_short_start_tmp2;
            my $F;
            if ($last_chance_back ne "yes")
            {
                $extra_overlap = sprintf("%.0f", (($read_length-$overlap)/3));
                if (length($read) < $insert_size*$insert_range && $hp_seed_assemble ne "")
                {
                    $extra_overlap = '0';
                }
                
                $F = ($insert_size-(($insert_size*$insert_range)-$insert_size))-$read_length+($read_length-$overlap-$extra_overlap-15)-($read_length-$left-$right-$overlap);
                if ($F < 0)
                {
                    $F = '0';
                }
                $read_short_start_tempie = substr $read, $F , ($insert_size*$insert_range)-$F;
                if ($hp_seed_assemble ne "")
                {
                    $read_short_start_tempie = substr $read, 0, $insert_size*2;              
                }
                $read_short_start_tempie =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                undef %read_short_start_tmp;
                $test_dot = $read_short_start_tempie =~ tr/\./\./;
                $test_star = $read_short_start_tempie =~ tr/\*/\*/;
               
                if (($test_dot < 3 || ($mmbr > 80 && $test_star < 1 && $test_dot < 7)) && $mmbr > 20)
                {
                     %read_short_start_tmp = build_partial3b ($read_short_start_tempie,"","no_delete");       
                     $read_short_start_3b = "yes";
                }
                else
                {
                    %read_short_start_tmp = build_partial3c ($read_short_start_tempie,"","no_delete");            
                }
        
                if ($test_star > 0)
                {
                    %read_short_start_tmp2 = build_partial3c ($read_short_start_tempie,"","no_delete"); 
                }
                else
                {
                   $read_short_start_tmp2{$read_short_start_tempie} = undef;
                   @read_short_start_tmp2 = split //, $read_short_start_tempie;
                }
                
                my $ff = '0';    
                undef %hash_read_short_start;
                undef %hash_read_short_start_dot;
                foreach my $read_short_start_tempie (keys %read_short_start_tmp)
                {
                    $ff = '0';
                    if (length($read) < $insert_size*$insert_range && $hp_seed_assemble ne "")
                    {
                        $extra_overlap = '0';
                    }
                    my @length_before0;
                    undef @length_before0;
                    if ($test_star > 0)
                    {
                        @length_before0 = split /\*/, $read_short_start_tmp{$read_short_start_tempie};
                    }
                    while ($ff < (length($read_short_start_tempie)-($overlap+$extra_overlap)-1))
                    {
                        my $read_short_start_part = substr $read_short_start_tempie, $ff, $overlap+$extra_overlap;
                        if (exists($hash_read_short_start_dot{$read_short_start_part}) || exists($hash_read_short_start{$read_short_start_part}))
                        {}
                        else
                        {
                            my $star_correction = '0';
                            foreach my $lengt_before0 (@length_before0)
                            {
                                my @lengt_before = split /\+/, $lengt_before0;
                                if ($lengt_before[1] < $ff)
                                {
                                    $star_correction += $lengt_before[0];
                                }
                            }
                            if ($star_correction > 0 && $ff eq '400dddd')
                            {
                                print OUTPUT5 $read_short_start_tempie." STAR_CORRECTION1\n";
                                print OUTPUT5 $star_correction." STAR_CORRECTION2\n\n";
                            }
                            if ($test_dot > 0 && $read_short_start_3b eq "" && $test_star > 0)
                            {
                                my $test_dot2 = $read_short_start_part =~ tr/\./\./;
                                if ($test_dot2 > 0)
                                {
                                    $hash_read_short_start_dot{$read_short_start_part} = $ff+$star_correction;
                                }
                                else
                                {
                                    $hash_read_short_start{$read_short_start_part} = $ff+$star_correction;
                                }
                            }
                            else
                            {
                                $hash_read_short_start{$read_short_start_part} = $ff+$star_correction;
                            }
                        }
                        $ff++;
                    }
                }
            }
my $test1 = '0';
my $test2 = '0';
my $test3 = '0';
my $test4 = '0';
my $test5 = '0';
my $test6 = '0';
                my $test_N1 = $read_start =~ tr/\./\./;
NO_MATCH_BACK:  foreach my $ln (keys %merged_match_back)
                {              
                    $match = $merged_match_back{$ln};
                    $id_match = $ln;
                    chomp $id_match;
                    chomp $match;
                    my $SNP_in_forward_read = "";
                    if ($hp_seed_assemble ne "" && $NUMT_back eq "")
                    {
                        foreach my $pos_tmp (keys %SNPs)
                        {
                            if ($pos_tmp >= -$position_back && $pos_tmp < (-$position_back+length($match)))
                            {
                                $SNP_in_forward_read = "yes";
                            }                                    
                        }
                        if ($SNP_in_forward_read ne "yes" && $last_chance_back eq "yes")
                        {
                            next NO_MATCH_BACK;
                        }
                    }
                    if ($last_chance_back eq "yes")
                    {                             
                        my $forward = "";
                        if (exists($merged_match_back1{$ln}))
                        {
                            my $test = substr $match, -$merged_match_back_pos{$ln}-$right-$overlap, $overlap;

                            if ($heteroplasmy ne "" && $hp_seed_assemble eq "" && length($match) > ($merged_match_back_pos{$ln}+$right+$overlap))
                            {
                                my $last_nuc = substr $match, -$merged_match_back_pos{$ln}-$right-$overlap, 1;
                                if (($last_nuc eq "1" || $last_nuc eq "2" || $last_nuc eq "3" || $last_nuc eq "4" || $last_nuc eq "N") && $SNR_read_back eq "")
                                {
                                    $exlude_id_prev_nuc_hp_back{$ln} = undef;
                                }
                            }
                            elsif ($heteroplasmy ne "" && length($match) <= ($merged_match_back_pos{$ln}+$right+$overlap))
                            {
                                next NO_MATCH_BACK;
                            }
                            if ($use_quality ne "")
                            {    
                                $test =~ tr/1234/ACTG/;
                            }
                            
                            foreach my $read_start_tmp (keys %read_start)
                            {
                                if ($test eq $read_start_tmp)
                                {
                                    my $extension_tmp = $match;
                                    substr $extension_tmp, -$merged_match_back_pos{$ln}-$right-$overlap, $merged_match_back_pos{$ln}+$right+$overlap, "";
                                    $extension = reverse($extension_tmp);
                                    $forward = "yes";
                   
                                    $read_count++;
                                    goto LAST1_BACK;
                                }
                            }  
                            my $test_N2 = $test =~ tr/N/\./;
            
                            if ($test_N1 > 0 && $test_N2 eq '0' && $test_N1 < $overlap/6)
                            {
                                foreach my $read_start_tmp (keys %read_start)
                                {
                                    if ($test =~ m/$read_start_tmp/)
                                    {
                                        my $extension_tmp = $match;
                                        substr $extension_tmp, -$merged_match_back_pos{$ln}-$right-$overlap, $merged_match_back_pos{$ln}+$right+$overlap, "";
                                        $extension = reverse($extension_tmp);
                                        $forward = "yes";

                                        $read_count++;
                                        goto LAST1_BACK;
                                    }
                                }
                            }
                            elsif ($test_N2 > 0 && $test_N1 eq '0' && $test_N2 < $overlap/6)
                            {
                                foreach my $read_start_tmp (keys %read_start)
                                {
                                    if ($read_start_tmp =~ m/$test/)
                                    {
                                        my $extension_tmp = $match;
                                        substr $extension_tmp, -$merged_match_back_pos{$ln}-$right-$overlap, $merged_match_back_pos{$ln}+$right+$overlap, "";
                                        $extension = reverse($extension_tmp);
                                        $forward = "yes";
   
                                        $read_count++;
                                        goto LAST1_BACK;
                                    }
                                }
                            }
                            foreach my $read_start_tmp (keys %read_start)
                            {
                                my @test_tmp = split //, $test;
                                my @read_start_tmp = split //, $read_start_tmp;
    
                                my $d = '0';
                                my $next = "";
                                my $N = '0';
                                                                        
                                while ($d < length($read_start_tmp))
                                {
                                    if ($test_tmp[$d] eq $read_start_tmp[$d])
                                    {
                                    }
                                    elsif ($read_start_tmp[$d] eq ".")
                                    {
                                    }
                                    elsif ($test_tmp[$d] eq "." && $N < '5')
                                    {
                                        $N++;
                                    }          
                                    elsif ($next eq "" && $heteroplasmy eq "" && length($read) > $insert_size+200 && $use_regex_back eq "yes")
                                    {
                                        $next = "yes";
                                    }
                                    elsif ($next eq "yes")
                                    {
                                        $next = "yes2";
                                    }
                                    elsif ($next eq "yes2")
                                    {
                                        $next = "yes3";
                                    }
                                    else
                                    {
                                        next NO_MATCH_BACK;
                                    }
                                    $d++    
                                }
 
                                my $extension_tmp = $match;
                                substr $extension_tmp, -$merged_match_back_pos{$ln}-$right-$overlap, $merged_match_back_pos{$ln}+$right+$overlap, "";
                                $extension = reverse($extension_tmp);
                                $forward = "yes";
    
                                $read_count++;
                                goto LAST1_BACK;
                            }
                        }
                        elsif (exists($merged_match_back2{$ln}))
                        {
                            my $match_reverse = reverse($match);
                            my $test = substr $match_reverse, -$merged_match_back_pos{$ln}-$left-$overlap, $overlap;

                            if ($heteroplasmy ne "" && $hp_seed_assemble eq "" && length($match_reverse) > ($merged_match_back_pos{$ln}+$left+$overlap))
                            {
                                my $last_nuc = substr $match_reverse, -$merged_match_back_pos{$ln}-$left-$overlap, 1;
                                if (($last_nuc eq "1" || $last_nuc eq "2" || $last_nuc eq "3" || $last_nuc eq "4" || $last_nuc eq "N") && $SNR_read_back eq "")
                                {
                                    $exlude_id_prev_nuc_hp_back{$ln} = undef;
                                }
                            }
                            elsif ($heteroplasmy ne "" && length($match_reverse) <= ($merged_match_back_pos{$ln}+$left+$overlap))
                            {
                                next NO_MATCH_BACK;
                            }
                            
                            if ($use_quality ne "")
                            {
                                $test =~ tr/1234ACTG/TGACTGAC/;
                            }
                            else
                            {
                                $test =~ tr/ACTG/TGAC/;
                            }
                            foreach my $read_start_tmp (keys %read_start)
                            {
                                if ($test eq $read_start_tmp)
                                {
                                    my $extension_tmp = $match_reverse;
                                    substr $extension_tmp, -$merged_match_back_pos{$ln}-$left-$overlap, $merged_match_back_pos{$ln}+$left+$overlap, "";
                                    $extension = reverse($extension_tmp);

                                    $read_count++;
                                    goto LAST1_BACK;
                                }
                            }
                            my $test_N2 = $test =~ tr/N/\./;
            
                            if ($test_N1 > 0 && $test_N2 eq '0' && $test_N1 < $overlap/6)
                            {
                                foreach my $read_start_tmp (keys %read_start)
                                {
                                    if ($test =~ m/$read_start_tmp/)
                                    {
                                        my $extension_tmp = $match_reverse;
                                        substr $extension_tmp, -$merged_match_back_pos{$ln}-$left-$overlap, $merged_match_back_pos{$ln}+$left+$overlap, "";
                                        $extension = reverse($extension_tmp);

                                        $read_count++;
                                        goto LAST1_BACK;
                                    }
                                }
                            }
                            elsif ($test_N2 > 0 && $test_N1 eq '0' && $test_N2 < $overlap/6)
                            {
                                foreach my $read_start_tmp (keys %read_start)
                                {
                                    if ($test =~ m/$read_start_tmp/)
                                    {
                                        my $extension_tmp = $match_reverse;
                                        substr $extension_tmp, -$merged_match_back_pos{$ln}-$left-$overlap, $merged_match_back_pos{$ln}+$left+$overlap, "";
                                        $extension = reverse($extension_tmp);
   
                                        $read_count++;
                                        goto LAST1_BACK;
                                }
                                }
                            }
                            foreach my $read_start_tmp (keys %read_start)
                            {
                                my @test_tmp = split //, $test;
                                my @read_start_tmp = split //, $read_start_tmp;
    
                                my $d = '0';
                                my $next = "";
                                my $N = '0';
                                                                        
                                while ($d < length($read_start_tmp))
                                {
                                    if ($test_tmp[$d] eq $read_start_tmp[$d])
                                    {
                                    }
                                    elsif ($read_start_tmp[$d] eq ".")
                                    {
                                    }
                                    elsif ($test_tmp[$d] eq "." && $N < '5')
                                    {
                                        $N++;
                                    }
                                    elsif ($next eq "" && $heteroplasmy eq "" && length($read) > $insert_size+200 && $use_regex_back eq "yes")
                                    {
                                        $next = "yes";
                                    }
                                    elsif ($next eq "yes")
                                    {
                                        $next = "yes2";
                                    }
                                    elsif ($next eq "yes2")
                                    {
                                        $next = "yes3";
                                    }
                                    elsif ($containX_short_start2 > 0)
                                    {
                                        goto STAR_BACK;
                                    }
                                    else
                                    {
                                        next NO_MATCH_BACK;
                                    }
                                    $d++    
                                }
   
                                my $extension_tmp = $match_reverse;
                                substr $extension_tmp, -$merged_match_back_pos{$ln}-$left-$overlap, $merged_match_back_pos{$ln}+$left+$overlap, "";
                                $extension = reverse($extension_tmp);

                                $read_count++;
                                goto LAST1_BACK;
                            }
                        }
                        
STAR_BACK:              if ($containX_short_start2 > 0)
                        {
                            if (exists($merged_match_back2{$ln}))
                            {
                                foreach my $line (keys %read_start_b)
                                {
                                    my @read_start_b_sub;
                                    undef @read_start_b_sub;
                                    if ($use_regex_back eq "yes" && $hp_seed_assemble eq "" && $read_count < 60)
                                    {
                                        @read_start_b_sub = build_partialb $line;
                                    }
                                    else
                                    {
                                        push @read_start_b_sub, $line;
                                    }
                                     
                                    my $found_seq = '0';
                                    my $match2 = $match;
                                    
                                    if ($use_quality ne "")
                                    {
                                       $match2 =~ tr/1234/ACTG/;
                                    }
                                                                        
                                    foreach my $read_start_b_sub (@read_start_b_sub)
                                    {
                                        $found_seq = $match2 =~ s/.$read_start_b_sub/+/;
                                        if ($found_seq > 0)
                                        {
                                            my @ext = split /\+/, $match2;
                                            my $extension5 = $ext[1];
                                            $extension = substr $match, -length($extension5), length($extension5);
                                            $read_count++;
                                            goto LAST1_BACK;
                                        }
                                    }
                                }
                            }
                            elsif (exists($merged_match_back1{$ln}))
                            {
                                foreach my $line (keys %read_start)
                                {
                                    my @read_start_sub;
                                    undef @read_start_sub;
                                    if ($use_regex_back eq "yes" && $hp_seed_assemble eq "" && $read_count < 60)
                                    {
                                        @read_start_sub = build_partialb $line;
                                    }
                                    else
                                    {
                                        push @read_start_sub, $line;
                                    }
                                    my $found_seq = '0';
                                    my $match4 = $match;
                                                                        
                                    if ($use_quality ne "")
                                    {
                                       $match4 =~ tr/1234/ACTG/;
                                    }
                                    
                                    foreach my $read_start_sub (@read_start_sub)
                                    {
                                        $found_seq = $match4 =~ s/(.)$read_start_sub/$1+/g;
                                        if ($found_seq > 1)
                                        {
                                            my $pos = $merged_match_back_pos{$ln};
                                            my $match4b = substr $match, 0, -$pos;
                                            $match4b =~ s/(.+)$line/$1+/;
                                            my @ext = split /\+/, $match4;
                                            $extension = reverse($ext[0]);                                                
                                            $read_count++;
                                            $forward = "yes";
                                            goto LAST1_BACK;
                                        }
                                        elsif ($found_seq > 0)
                                        {
                                            my @ext = split /\+/, $match4;
                                            my $extension5 = reverse($ext[0]);
                                            my $extension4 = substr $match, 0, length($extension5);
                                            $extension = reverse($extension4);
                                            $read_count++;
                                            $forward = "yes";
                                            goto LAST1_BACK;
                                        }
                                    }
                                }
                            }
                        }
                        next NO_MATCH_BACK;
                        
LAST1_BACK:            
                        if ($extension eq "NOOO" || $extension eq " " || $extension eq "")
                        {
                            next NO_MATCH_BACK;
                        }
                        if ($hp_seed_assemble ne "" && $NUMT_back eq "")
                        {
                            my %SNPs_or_not;
                            undef %SNPs_or_not;
                            %SNPs_or_not = %SNPs;
                            my $check = "";
                            my $check_no_SNPs = "";

HP_SNP1_BACK:               foreach my $pos_tmp (keys %SNPs_or_not)
                            {             
                                my $pos_tmp2 = $pos_tmp;
                                if ($pos_tmp > 0)
                                {
                                     $pos_tmp--;
                                }
                                if ($pos_tmp <= (-$position_back+(length($match)-length($extension)))+1 && $pos_tmp > -$position_back-1)
                                {
                                    if (exists($merged_match_back1{$ln}))
                                    {                    
                                        my $hp_SNP_read = substr $match, length($extension)+$position_back+$pos_tmp, 1;
                                        $hp_SNP_read =~ tr/1234/ACTG/;

                                        if ($hp_SNP_read ne $SNPs_or_not{$pos_tmp2})
                                        {
                                            $check = "no";
                                            last HP_SNP1_BACK;
                                        }
                                        elsif ($hp_SNP_read eq $SNPs_or_not{$pos_tmp2} && $check_no_SNPs eq "")
                                        {
                                            $check = "yes";
                                            $hp_SNP_links{$pos_tmp2} .= exists $hp_SNP_links{$pos_tmp2} ? ",$ln" : $ln;
                                        }
                                    }
                                    elsif (exists($merged_match_back2{$ln}))
                                    {
                                        my $match_tmp = reverse($match);             
                                        my $hp_SNP_read = substr $match_tmp, length($extension)+$position_back+$pos_tmp, 1;
                                        $hp_SNP_read =~ tr/ACTG1234/TGACTGAC/;

                                        if ($hp_SNP_read ne $SNPs_or_not{$pos_tmp2})
                                        {
                                            $check = "no";
                                            last HP_SNP1_BACK;
                                        }
                                        elsif ($hp_SNP_read eq $SNPs_or_not{$pos_tmp2} && $check_no_SNPs eq "")
                                        {
                                            $check = "yes";
                                            $hp_SNP_links{$pos_tmp2} .= exists $hp_SNP_links{$pos_tmp2} ? ",$ln" : $ln;
                                        }
                                    }
                                }
                            }
                            if ($check_no_SNPs eq "" && $check ne "no")
                            {
                                undef %SNPs_or_not;
                                %SNPs_or_not = %noSNPs;
                                $check_no_SNPs = "yes";
                                goto HP_SNP1_BACK;
                            }
                            if ($check ne "yes")
                            {
                                next NO_MATCH_BACK;
                            }
                        }
                        if ($use_quality ne "" && ($SNR_critical_back ne "" || $no_quality_back ne "" || $hp_seed_assemble ne "" || $no_hp_one_turn ne ""))
                        {
                            if (exists($merged_match_back2{$ln}))
                            {
                                $extension =~ tr/1234ACTG/TGACTGAC/;
                            }
                            elsif (exists($merged_match_back1{$ln}))
                            {
                                $extension =~ tr/1234/ACTG/;
                            }
                        }
                        elsif (exists($merged_match_back2{$ln}))
                        {
                            $extension =~ tr/ACTG/TGAC/;
                        }
                        my $nuc_exlude = "test";
                        if ($yuyu_option_A_back eq "A" || $yuyu_option_C_back eq "C" || $yuyu_option_T_back eq "T" || $yuyu_option_G_back eq "G")
                        {
                            $nuc_exlude = substr $extension, 0, 1;
                            $nuc_exlude =~ tr/1234/ACTG/;
                        }
                        if ($nuc_exlude ne $yuyu_option_A_back && $nuc_exlude ne $yuyu_option_C_back && $nuc_exlude ne $yuyu_option_T_back && $nuc_exlude ne $yuyu_option_G_back)
                        {
                            my $match_tmp = $match;

                            if (exists($merged_match_back2{$ln}))
                            {
                                my $match_reverse = reverse($match_tmp);
                                $match_tmp = $match_reverse;
                            }

                            $extensions_for_before{$id_match} = $extension;
                            $extensions_for_before_match{$id_match} = $match_tmp;
                                                           
                            push @matches2, $id_match.",".$extension.","."".",".$match.","."";
                            if ($forward eq "yes")
                            {
                                $extensions2b{$id_match} = $extension;
                            }
                            else
                            {
                                $extensions1b{$id_match} = $extension;
                            }
                            if ($save_reads ne "")
                            {                                  
                                my $add_read = substr $id_match, 0, -1;
                                $save_reads{$add_read} = undef;
                            }
                        }
                        next NO_MATCH_BACK;
                    }
                    else
                    {                        
                        my $test = substr $match, -$merged_match_back_pos{$ln}-$right-$overlap, $overlap;

                        if ($heteroplasmy ne "" && length($match) > ($merged_match_back_pos{$ln}+$right+$overlap))
                        {
                            my $last_nuc = substr $match, -$merged_match_back_pos{$ln}-$right-$overlap, 1;
                            if ($heteroplasmy ne "" && ($last_nuc eq "1" || $last_nuc eq "2" || $last_nuc eq "3" || $last_nuc eq "4" || $last_nuc eq "N") && $SNR_read_back eq "")
                            {
                                $exlude_id_prev_nuc_hp_back{$ln} = undef;
                            }
                        }
                        elsif ($heteroplasmy ne " "&& length($match) <= ($merged_match_back_pos{$ln}+$right+$overlap))
                        {
                            next NO_MATCH_BACK;
                        }
                        if ($containX_short_start2 > 0)
                        {
                            goto STAR_BACK2;
                        }
                        if ($use_quality ne "")
                        {
                            $test =~ tr/1234/ACTG/;
                        }
                        
                        foreach my $line (keys %read_start)
                        {
                            if ($test eq $line)
                            {
                                my $extension_tmp = $match;
                                substr $extension_tmp, -$merged_match_back_pos{$ln}-$right-$overlap, $merged_match_back_pos{$ln}+$right+$overlap, "";
                                $extension = reverse($extension_tmp);
                                                       
                                $read_count++;
                                goto FOUND_BACK;
                            }
                        }
                        my $test_N2 = $test =~ tr/N/\./;
        
                        if ($test_N1 > 0 && $test_N2 eq '0' && $test_N1 < $overlap/6)
                        {
                            foreach my $line (keys %read_start)
                            {
                                if ($test =~ m/$line/)
                                {
                                    my $extension_tmp = $match;
                                    substr $extension_tmp, -$merged_match_back_pos{$ln}-$right-$overlap, $merged_match_back_pos{$ln}+$right+$overlap, "";
                                    $extension = reverse($extension_tmp);
                                                           
                                    $read_count++;
                                    goto FOUND_BACK;
                                }
                            }
                        }
                        elsif ($test_N2 > 0 && $test_N1 eq '0' && $test_N2 < $overlap/6)
                        {
                            foreach my $line (keys %read_start)
                            { 
                                if ($line =~ m/$test/)
                                {
                                    my $extension_tmp = $match;
                                    substr $extension_tmp, -$merged_match_back_pos{$ln}-$right-$overlap, $merged_match_back_pos{$ln}+$right+$overlap, "";
                                    $extension = reverse($extension_tmp);
                                                           
                                    $read_count++;
                                    goto FOUND_BACK;
                                }
                            }
                        }
                        foreach my $line (keys %read_start)
                        { 
                            my @test_tmp = split //, $test;
                            my @read_start_tmp = split //, $line;
    
                            my $d = '0';
                            my $next = "";
                            my $N = '0';
                                                                    
                            while ($d < length($line))
                            {
                                if ($test_tmp[$d] eq $read_start_tmp[$d])
                                {
                                }
                                elsif ($read_start_tmp[$d] eq ".")
                                {
                                }
                                elsif ($test_tmp[$d] eq "." && $N < '5')
                                {
                                    $N++;
                                }
                                elsif ($next eq "" && $hp_seed_assemble eq "" && $use_regex_back eq "yes")
                                {
                                    $next = "yes";
                                }
                                elsif ($next eq "yes")
                                {
                                    $next = "yes2";
                                }
                                elsif ($next eq "yes2")
                                {
                                    $next = "yes3";
                                }
                                else
                                {
                                    next NO_MATCH_BACK;
                                }
                                $d++    
                            }
                            my $extension_tmp = $match;
                            substr $extension_tmp, -$merged_match_back_pos{$ln}-$right-$overlap, $merged_match_back_pos{$ln}+$right+$overlap, "";
                            $extension = reverse($extension_tmp);
                                                   
                            $read_count++;
                            goto FOUND_BACK;
                        }
                    }
                    
STAR_BACK2:         if ($containX_short_start2 > 0)
                    {
                        foreach my $line (keys %read_start)
                        {
                            my @read_start_sub;
                            undef @read_start_sub;
                            if ($hp_seed_assemble eq "" && $use_regex_back ne "")
                            { 
                                @read_start_sub = build_partialb $line;
                            }
                            else
                            {
                                push @read_start_sub, $line;
                            }
                            my $found_seq = '0';
                            my $match4 = $match;
                                                                
                            if ($use_quality ne "")
                            {
                               $match4 =~ tr/1234/ACTG/;
                            }
                            
                            foreach my $read_start_sub (@read_start_sub)
                            {
                                $found_seq = $match4 =~ s/(.)$read_start_sub/$1+/g;
                                if ($found_seq > 1)
                                {
                                    my $pos = $merged_match_back_pos{$ln};
                                    my $match4b = substr $match, 0, -$pos;
                                    $match4b =~ s/(.+)$line/$1+/;
                                    my @ext = split /\+/, $match4;
                                    $extension = reverse($ext[0]);
                                    $read_count++;
                                    goto FOUND_BACK; 
                                }
                                elsif ($found_seq > 0)
                                {
                                    my @ext = split /\+/, $match4;
                                    my $extension5 = substr $match, 0, length($ext[0]);
                                    $extension = reverse($extension5);
                                    $read_count++;
                                    goto FOUND_BACK;     
                                }
                            }
                        }
                    }
                    next NO_MATCH_BACK;
                
FOUND_BACK:     if ($last_chance_back eq "yes" || $extension eq "NOOO" || $extension eq " " || $extension eq "")
                {           
                    next NO_MATCH_BACK;
                }
                if ($hp_seed_assemble ne "" && $NUMT_back eq "" && $SNP_in_forward_read eq "yes")
                {
                    my %SNPs_or_not;
                    undef %SNPs_or_not;
                    %SNPs_or_not = %SNPs;
                    my $check = "";
                    my $check_no_SNPs = "";

HP_SNP2_BACK:       foreach my $pos_tmp (keys %SNPs_or_not)
                    {             
                        my $pos_tmp2 = $pos_tmp;
                        if ($pos_tmp > 0)
                        {
                             $pos_tmp--;
                        }
                        if ($pos_tmp <= (-$position_back+(length($match)-length($extension)))+1 && $pos_tmp > -$position_back-1)
                        {
                            if (exists($merged_match_back1{$ln}))
                            { 
                                my $hp_SNP_read = substr $match, length($extension)+$position_back+$pos_tmp, 1;
                                $hp_SNP_read =~ tr/1234/ACTG/;

                                if ($hp_SNP_read ne $SNPs_or_not{$pos_tmp2})
                                {
                                    $check = "no";
                                    last HP_SNP2_BACK;
                                }
                                elsif ($hp_SNP_read eq $SNPs_or_not{$pos_tmp2} && $check_no_SNPs eq "")
                                {
                                    $test1++;
                                    $check = "yes";
                                    $hp_SNP_links{$pos_tmp2} .= exists $hp_SNP_links{$pos_tmp2} ? ",$ln" : $ln;
                                }
                            }
                        }
                    }
                    if ($check_no_SNPs eq "" && $check ne "no")
                    {
                        undef %SNPs_or_not;
                        %SNPs_or_not = %noSNPs;
                        $check_no_SNPs = "yes";
                        goto HP_SNP2_BACK;
                    }
                    if ($check eq "no")
                    {
                        delete $accepted_SNPs_back{$ln};
                        next NO_MATCH_BACK;
                    }
                    elsif ($check eq "yes")
                    {
                        $accepted_SNPs_back{$ln} = undef;
                    }
                }
                $read_ex++;
                
                if (exists($merged_match_pair_back{$ln}))
                {
                    $match_pair = $merged_match_pair_back{$ln};     
                    chomp($match_pair);
                    $match_pair2 = reverse($match_pair);                    

                    my $match_pair_middle2 = substr $match_pair2, $right+5, $overlap+$extra_overlap;

                    my $countN = $match_pair_middle2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
                    my $extra_regex_tmp = "";
                    if ($countN > 0 && $countN < length($match_pair_middle2)/5)
                    {
                        $extra_regex_tmp = "yes";
                    }
                    elsif ($countN >= length($match_pair_middle2)/5)
                    {
                        next NO_MATCH_BACK;
                    }
                    if ($use_quality ne "")
                    {
                        $match_pair_middle2 =~ tr/1234ACTG/TGACTGAC/;
                    }
                    else
                    {
                        $match_pair_middle2 =~ tr/ACTG/TGAC/;
                    }
            
                    if (exists($hash_read_short_start{$match_pair_middle2}))
                    {
                        if ($hp_seed_assemble ne "" && $NUMT_back eq "")
                        {
                            my $ch = check_HP_pos_back($hash_read_short_start{$match_pair_middle2}, $position, $position_back, $match_pair2, $ln);
                            if ($ch eq "no")
                            {
                                next NO_MATCH_BACK;
                            }
                            $test2++;
                        }
                        $extension_match = "";
                        goto SKIP_BACK;
                    }
                    if ($read_short_start_3b eq "" || $extra_regex_tmp eq "yes" || $use_regex_back eq "yes")
                    {                                                                                                                                                                                            
                        my @match_pair_middle_sub = split //, $match_pair_middle2;
                        $extension_match = "";
                        my $gh = '0';
                        foreach my $line (keys %read_short_start_tmp2)
                        {
                            my @line;
                            undef @line;
                            $gh = '0';
                            if ($test_star > 0)
                            {
                                @line = split //, $line;
                            }
                            else
                            {
                                @line = @read_short_start_tmp2;
                            }
         
CHECK_PAIR_BACK:            while ($gh < length($line)-length($match_pair_middle2))
                            {
                                my $d = '0';
                                my $next = "";
                                my $th = '0';
                                my $N = '0';
                                if ($use_regex_back ne "yes")
                                {
                                    $next = "yes3";
                                }
                                
                                while ($d < length($match_pair_middle2))
                                {
                                    $th = $d + $gh;
                                    if ($match_pair_middle_sub[$d] eq $line[$th])
                                    {
                                    }
                                    elsif ($line[$th] eq "." || $line[$th] eq "N")
                                    {
                                    }
                                    elsif ($match_pair_middle_sub[$d] eq ".")
                                    {
                                        $N++;
                                    }
                                    elsif ($next eq "" && $hp_seed_assemble eq "")
                                    {
                                        $next = "yes";
                                    }
                                    elsif ($next eq "yes")
                                    {
                                        $next = "yes2";
                                    }
                                    elsif ($next eq "yes2")
                                    {
                                        $next = "yes3";
                                    }
                                    else
                                    {
                                        $gh++;
                                        goto CHECK_PAIR_BACK;
                                    }
                                    $d++    
                                }
                                goto CHECK_PAIR0_BACK;
                            }
                        }   
                        $extension_match = "NOOO";
                                
CHECK_PAIR0_BACK:                               
                        if ($hp_seed_assemble ne "" && $NUMT_back eq "")
                        {
                            my $ch = check_HP_pos_back($gh, $position, $position_back, $match_pair2, $ln);
                            if ($ch eq "no")
                            {
                                next NO_MATCH_BACK;
                            }
                            $test3++;
                        }
                        goto SKIP_BACK;    
                    }
                    if ($test_star > 0)
                    {
                        my $found_seq = '0';
                        my $match_pair_middle_tmp = $match_pair_middle2;
CHECK_PAIR2_BACK:       foreach my $line (keys %hash_read_short_start_dot)
                        {
                            my $found_seq = '0';
                            my $star_first = substr $line, 0, 1;
                            if ($star_first eq "*")
                            {
                                $line = substr $line, 1;
                                $match_pair_middle_tmp = substr $match_pair_middle_tmp, 1;
                            }                       
                            $found_seq = $match_pair_middle_tmp =~ s/$line/+/;
                            if ($found_seq > 0)
                            {
                                last CHECK_PAIR2_BACK;
                            }
                        }
                        if ($found_seq > 0)
                        {
                            $extension_match = "";
                            if ($hp_seed_assemble ne "" && $NUMT_back eq "")
                            {
                                my $ch = check_HP_pos_back($hash_read_short_start_dot{$match_pair_middle2}, $position, $position_back, $match_pair2, $ln);
                                if ($ch eq "no")
                                {
                                    next NO_MATCH_BACK;
                                }
                                $test4++;
                            }
                            goto SKIP_BACK;
                        }
                        else
                        {
                            $extension_match = "NOOO";
                        }
                    }
                    $extension_match = "NOOO";
SKIP_BACK:
                    if ($extension_match eq "NOOO")
                    {
                        next NO_MATCH_BACK;
                    }
                    if ($hp_seed_assemble ne "" && $NUMT_back eq "" && $no_hp_one_turn2_back eq "")
                    {
                        my $check = "";
                        if (exists($accepted_SNPs_back{$ln}))
                        {
                            $check = "yes";
                            $test5++;
                        }
                        if (exists($accepted_SNPs_pair_back{$ln}))
                        {
                            $check = "yes";
                            $test6++;
                        }
                        if ($check ne "yes")
                        {
                            next NO_MATCH_BACK;
                        }
                    }
                    if ($use_quality ne "" && ($SNR_critical_back ne "" || $no_quality_back ne "" || $hp_seed_assemble ne "" || $no_hp_one_turn ne ""))
                    {
                        $extension =~ tr/1234/ACTG/;
                    }
                    my $nuc_exlude = "test";
                    if ($yuyu_option_A_back eq "A" || $yuyu_option_C_back eq "C" || $yuyu_option_T_back eq "T" || $yuyu_option_G_back eq "G")
                    {
                        $nuc_exlude = substr $extension, 0, 1;
                        $nuc_exlude =~ tr/1234/ACTG/;
                    }
                    if ($nuc_exlude ne $yuyu_option_A_back && $nuc_exlude ne $yuyu_option_C_back && $nuc_exlude ne $yuyu_option_T_back && $nuc_exlude ne $yuyu_option_G_back)
                    {         
                        my $match_tmp = $match;
                        my $match_pair_tmp = $match_pair2;

                        $extensions_for_before{$id_match} = $extension;
                        $extensions_for_before_match{$id_match} = $match_tmp;
                        $extensions_for_before_match_pair{$id_match} = $match_pair_tmp;
                                                  
                        $extensions2b{$id_match} = $extension;
                        push @matches1, $id_match.",".$extension.","."".",".$match.",".$match_pair;
                        if ($save_reads ne "")
                        {                                  
                            my $add_read = substr $id_match, 0, -1;
                            $save_reads{$add_read} = undef;
                        }
                    }                                                                                         
                                            
                }
            }
            %extensionsb = (%extensions1b, %extensions2b);
            %extensionsb_original = %extensionsb;
            @matches = (@matches1, @matches2);
           
            my $ext = keys %extensionsb;
            my $ext_total_back = '0';
            $ext_total_back = $ext;

            if ($y > $startprint2)
            {
                print OUTPUT5 "\n".$read_count ." READ_COUNT_BACK\n";
                print OUTPUT5 $read_ex ." READ_EX_BACK\n";
                print OUTPUT5 $ext ." EXTENSIONS_BACK\n";
            }
            if ($y > $startprint2 && $benchmark_time eq "yes")
            {
                $time_collect_ext_back = time;
            }
        
            undef %SNR_length;
            if (($y > $startprint && $print_log eq '2') || $hp_seed_assemble eq "fsf" || $y eq "vqsvg" || $SNR_read_back eq "dd" || $last_chance_back eq "ydges")
            {
                foreach my $matches (@matches)
                {
                    my @matchesb;
                    undef @matchesb;
                    @matchesb = split /,/, $matches;
                    print OUTPUT5 $matchesb[1]."\n";
                    if (exists($merged_match1{$matchesb[0]}))
                    {
                    }
                    elsif (exists($merged_match2{$matchesb[0]}))
                    {
                    }
                }               
            }
            
            if ($SNR_read_back ne "" && $SNR_read_back2 ne "" && $last_chance_back ne "yes" && $ext < 5)
            {
                goto AFTER_EXT_BACK;
            }
            undef %extensionsb_group1;
            undef %extensionsb_group2;   
            undef %extensionsb_group3;
            undef %extensionsb_group4;
            
            $no_SNR = "";
            undef %extensionsb_backup;
            %extensionsb_backup = %extensionsb;
            
            my $removed_N_reads;
            my $percentage_N = '0.1';
REMOVE_N_BACK:if ($use_quality eq "yes" && $SNR_read_back ne "" && $ext_total_back > 4 && $SNR_critical_back eq "")
            {
                undef %extensionsb;
                foreach my $extensions_id (keys %extensionsb_original)
                {                                 
                    my $extensions = $extensionsb_original{$extensions_id};
                    my $N = $extensions =~ tr/N1234/N1234/;
                    if ($N/length($extensions) < $percentage_N)
                    {
                        $extensionsb{$extensions_id} = $extensions;
                    }
                }
                my $f = keys %extensionsb;
                print OUTPUT5 $f." EXT-N\n";
                if ($f < 4 && $percentage_N < 0.5)
                {
                    %extensionsb = %extensionsb_original;
                    $percentage_N += 0.1;
                    goto REMOVE_N_BACK;
                }
                elsif ($f < 4)
                {
                    %extensionsb = %extensionsb_original;
                }
                elsif ($removed_N_reads ne "yes1")
                {
                    $removed_N_reads = "yes";
                }
            }
             
SPLIT_BACK:
            if ($split eq "yes_back")
            {
                %extensionsb = %extensionsb_group2;
                $split = "yes2_back";
                $ext = keys %extensionsb;
            }
            elsif ($split eq "yes2_back")
            {
                %extensionsb = %extensionsb_group3;
                $split = "yes3_back";
                $ext = keys %extensionsb;
            }
            elsif ($split eq "yes3_back")
            {
                %extensionsb = %extensionsb_group4;
                $split = "yes4_back";
                $ext = keys %extensionsb;
            }
            elsif ($split eq "yes4_back")
            {
                %extensionsb = %extensionsb_group1;
                $split = "yes5_back";
                $ext = keys %extensionsb;
                if ($count_split eq '1')
                {
                    $split = "";
                }
            }
            $position_back = $position_back{$id};                   
            $l  = '0';
            $best_extension = "";          
            $SNP   = '0';
            $A_SNP = '0';
            $C_SNP = '0';
            $T_SNP = '0';
            $G_SNP = '0';
            $pos_SNP = '0';
            $pos_SNP2 = '0';
            $pos_SNP3 = '0';
            $pos_SNP4 = '0';
            
            if ($SNR_read_back eq "")
            {
                $SNR_read_back = SNR_ahead (\%extensionsb, '0', "yes");
            }

NUCLEO0_BACK:            
            if ($SNR_read_back ne "")
            {
                $ext = keys %extensionsb;
            }
            my $extra_l = '0';
            $highest_all_freq = '0';

NUCLEO_BACK: while ($l < $read_length - ($overlap+$left-1) + $extra_l && $l < 149)
             {
                my $A = '0';
                my $C = '0';
                my $T = '0';
                my $G = '0';
                my $skipped = '0';
                my $low_quality_nucs = '0';

                if ($SNR_read_back2 ne "" && $l > 0 && $split eq "")
                {
                    my $best_extension_tmp8 = $best_extension;
                    $best_extension_tmp8 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

                    my $last_nuc = substr $best_extension_tmp8, -1;
                    my $arrSize1 = keys %extensionsb;
                    if ($last_nuc ne '.' && $arrSize1 > 4)
                    {
                        my %extensionsb_tmp;
                        undef %extensionsb_tmp;
                        foreach my $extensions_id (keys %extensionsb)
                        {
                            my $extensions = $extensionsb{$extensions_id};
                            my @chars = split//, $extensions;
                            if ($chars[$l-1] eq $last_nuc || length($extensions) < $l)
                            {
                                $extensionsb_tmp{$extensions_id} = $extensions;
                            }
                        }
                        my $arrSize2 = keys %extensionsb_tmp;

                        if ($arrSize1 ne $arrSize2)
                        {
                            undef %extensionsb;
                            %extensionsb = %extensionsb_tmp;
                                                       
                            my $best_extension_dot = $best_extension_tmp8 =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
                            if ($best_extension_dot > 0)
                            {
                                $l = 0;
                                $SNP = '0';
                                $best_extension = "";
                                goto NUCLEO0_BACK;
                            }
                        }
                    }               
                }
                
                foreach my $extensions_id (keys %extensionsb)
                {                                
                    my $extensions = $extensionsb{$extensions_id};                              
                    my @chars = split//, $extensions;
                    
                    if ($l eq '0' && $heteroplasmy ne "" && exists($exlude_id_prev_nuc_hp_back{$extensions_id}))
                    {
                        $low_quality_nucs++;
                    } 
                    if ($chars[$l] eq "A")
                    {
                        $A++;
                    }
                    elsif ($chars[$l] eq "C")
                    {
                        $C++;
                    }
                    elsif ($chars[$l] eq "T")
                    {
                        $T++;
                    }
                    elsif ($chars[$l] eq "G")
                    {
                        $G++;
                    }
                    elsif ($chars[$l] eq "1" || $chars[$l] eq "2" || $chars[$l] eq "3" || $chars[$l] eq "4")
                    {
                        $low_quality_nucs++;
                    }
                    elsif ($chars[$l] eq "N")
                    {
                        $skipped++;
                    }
                }
                if (($A+$T+$G+$C) < 1)
                {
                    last NUCLEO_BACK;
                }
                my $c = '2.8';               
                if ($ext > 22 && $SNR_read_back eq "")
                {
                    $c = '3.4';
                }
                if ($SNR_read_back2 ne "" && $l < 5)
                {
                    $c = '1.4';
                }
                if ($ext > 6 && ($type ne "chloro" || $extensions_before ne "") && $SNR_read_back eq "")
                {
                    $c = '5';
                }
                if ($ext > 22 && $SNR_read_back eq "" && $type ne "chloro")
                {
                    $c = '6.5';
                }
                if ($ext > 38 && $SNR_read_back eq "" && $type ne "chloro")
                {
                    $c = '8.4';
                }
                if ($ext > 100 && $SNR_read_back eq "" && $type eq "mito_plant")
                {
                    $c = '13';
                }
                if ($ext > $average_coverage_ext*6 && $SNR_read_back eq "" && $type eq "mito_plant")
                {
                    $c = '25';
                }
                if ($repetitive_detect_back ne "" && $ext < 23 && $SNR_read_back eq "")
                {
                   $c = '7';
                }
                if ($repetitive_detect_back ne "" && $ext >= 23 && $SNR_read_back eq "")
                {
                   $c = '9';
                }
                if ($repetitive_detect_back2 eq "yes" || ($repetitive_detect_back ne "" && $ext > 120))
                {
                   $c = '15';
                }
                if ($extensions_before eq "yes" && $type eq "mito_plant")
                {
                   $c = '13';
                }
                if ($extensions_before eq "yes" && $ext > $average_coverage_ext*0.5 && $type eq "mito_plant")
                {
                   $c = '23';
                }
                if ($type eq "mito_plant")
                {
                    $c += 2;
                }
                my $q = '2';
                my $z = '1';
                my $v = '6';
                my $s = '3';
                my $w = '5';
                if ($need_longer_ext_back eq "yes" || $split ne "")
                {
                    $w = '10';
                }
                if ($split ne "")
                {
                    $v = '10';
                    $s = '2';
                    $z = '0';
                }
                my $hp = 10000000000;
                if ($heteroplasmy ne "" && $repetitive_detect_back eq "" && ($hp_seed_assemble eq "" || $no_hp_one_turn2_back ne "") && $split eq "" && $no_hp_one_turn eq "" && ($SNR_read_back2 eq "" || $need_longer_ext_back eq ""))
                {
                    $hp = ($A + $T + $G + $C)*$heteroplasmy*0.8;
                    if ($heteroplasmy*0.8 < 0.0048)
                    {
                        $hp = ($A + $T + $G + $C)*0.0048;
                    }
                    $q = 1.5;
                    $v = 4;
                    $z = 2;
                    my $tmp = reverse($best_extension).$read_start;
                    my $dot = $tmp =~ tr/\./\./;
                    if ($skipped/($A + $T + $G + $C+$skipped) > $heteroplasmy && $skipped/($A + $T + $G + $C+$skipped) > 0.02 && $dot < 4)
                    {
                        $hp = ($A + $T + $G + $C)*($heteroplasmy*0.8);
                        if ($heteroplasmy*0.8 < 0.0050)
                        {
                            $hp = ($A + $T + $G + $C)*0.0050;
                        }
                    }
                }
                if ($hp_seed_assemble ne "" && $no_hp_one_turn2_back eq "")
                {
                    $v = '40';
                    $q = '1.4';
                    $c += 1;
                    if ($c < 5 && $SNR_read eq "")
                    {
                        $c = '5';
                    }
                }
                if (($pos_SNP eq '0' && $l eq '1') || ($pos_SNP eq '1' && $l eq '2') || ($pos_SNP eq '2' && $l eq '3') || ($pos_SNP eq '3' && $l eq '4'))
                {
                    $q = '3';
                }
                if ($heteroplasmy ne "" && ($SNR_read_back_ahead eq "" || $l > 25) && ($SNR_read_back eq "" || $l > 10) && ($l > 15 || ($l > $w && $SNP < 3)) && ($highest_all_freq > $heteroplasmy/2 || $pos_SNP eq $l-1 || $pos_SNP2 eq $l-1 || $pos_SNP3 eq $l-1))
                {
                    chop($best_extension);
                    last NUCLEO_BACK;
                }
                if ($position_back > 160000000000 || $y eq '1132')
                {
                    print OUTPUT5 $A."+".$C."+".$T."+".$G."+".$l."+".$ext."+".$skipped."+".$low_quality_nucs."+".$SNP."+".$ll."+".$highest_all_freq."+".$pos_SNP."+".$q."+".$extensions_before."+".$ext_before."+".$w."+".$SNR_read_back."+".$SNP_active_back."\n";
                }
                if ($A > ($C + $T + $G)*$c && (($C <= $hp && $T <= $hp && $G <= $hp) || ($C < 2 && $T < 2 && $G < 2)) && (($A > $s && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q) || ($A > $z && $l < $v && ($C + $T + $G) eq 0 && ($ext)/($A+$T+$G+$C+$skipped) < $q)))
                {
                    $best_extension = $best_extension."A";
                    $allele_percentage_back{$l} = $A."+".$C."+".$T."+".$G;
                    $highest_all_freq = ($C+$T+$G)/($A+$C+$T+$G);
                }
                elsif ($C > ($A + $T + $G)*$c && (($A <= $hp && $T <= $hp && $G <= $hp) || ($A < 2 && $T < 2 && $G < 2)) && (($C > $s && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q) || ($C > $z && $l < $v && ($A + $T + $G) eq 0 && ($ext)/($A+$T+$G+$C+$skipped) < $q)))
                {
                    $best_extension = $best_extension."C";
                    $allele_percentage_back{$l} = $A."+".$C."+".$T."+".$G;
                    $highest_all_freq = ($A+$T+$G)/($A+$C+$T+$G);
                }
                elsif ($T > ($A + $C + $G)*$c && (($C <= $hp && $A <= $hp && $G <= $hp) || ($C < 2 && $A < 2 && $G < 2)) && (($T > $s && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q) || ($T > $z && $l < $v && ($A + $C + $G) eq 0 && ($ext)/($A+$T+$G+$C+$skipped) < $q)))
                {
                    $best_extension = $best_extension."T";
                    $allele_percentage_back{$l} = $A."+".$C."+".$T."+".$G;
                    $highest_all_freq = ($A+$C+$G)/($A+$C+$T+$G);
                }
                elsif ($G > ($C + $T + $A)*$c && (($C <= $hp && $T <= $hp && $A <= $hp) || ($C < 2 && $T < 2 && $A < 2)) && (($G > $s && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q) || ($G > $z && $l < $v && ($C + $T + $A) eq 0 && ($ext)/($A+$T+$G+$C+$skipped) < $q)))
                {
                    $best_extension = $best_extension."G";
                    $allele_percentage_back{$l} = $A."+".$C."+".$T."+".$G;
                    $highest_all_freq = ($A+$T+$C)/($A+$C+$T+$G);
                }           
                elsif ((($heteroplasmy ne "" && (($l < 10 && $SNP eq '0') || ($l < $pos_SNP+10 && $SNP eq '1') || ($l < $pos_SNP2+10 && $SNP eq '2') || ($l < $pos_SNP3+10 && $SNP eq '3'))) || $SNP_active_back eq "yes" ||
                       ($extensions_before eq "yes" && $ext_before ne "yes")) && $SNP < 4 && ($A+$T+$G+$C) > 3 && (($l < 15 && $split eq "") || ($l < 11 && $split ne "")) && (($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q || ($SNR_read_back ne "" && $l < 12))) 
                {
                    if ($hp_seed_assemble ne "" && $no_hp_one_turn2_back && $split eq "" && $SNR_read_back eq "")
                    {
                        my %A_hp;
                        my %C_hp;
                        my %T_hp;
                        my %G_hp;
                        undef %A_hp;
                        undef %C_hp;
                        undef %T_hp;
                        undef %G_hp;
                        foreach my $pos_hp (sort {$a <=> $b} keys %hp_SNP_links)
                        {
                            my $A_hp;
                            my $C_hp;
                            my $T_hp;
                            my $G_hp;
                            my %all_ids_tmp;
                            undef %all_ids_tmp;
                            my $list = substr $hp_SNP_links{$pos_hp},1;
                            my @list_id = split /,/, $list;
                            foreach my $id_hp (@list_id)
                            {
                                if (exists($extensionsb{$id_hp}))
                                {
                                    my $first_nuc = substr $extensionsb{$id_hp}, $l, 1;
                                    if ($first_nuc eq "A")
                                    {
                                        $A_hp++;     
                                    }
                                    if ($first_nuc eq "C")
                                    {
                                        $C_hp++;     
                                    }
                                    if ($first_nuc eq "T")
                                    {
                                        $T_hp++;     
                                    }
                                    if ($first_nuc eq "G")
                                    {
                                        $G_hp++;     
                                    }
                                    $all_ids_tmp{$id_hp} = undef;
                                }     
                            }
                            if (($A_hp+$C_hp+$T_hp) eq '0' && $G_hp > 2)
                            {
                                foreach my $id_tmp (keys %all_ids_tmp)
                                {
                                    $G_hp{$id_tmp} = undef;
                                }
                            }
                            if (($A_hp+$C_hp+$G_hp) eq '0' && $T_hp > 2)
                            {
                                foreach my $id_tmp (keys %all_ids_tmp)
                                {
                                    $T_hp{$id_tmp} = undef;
                                }
                            }
                            if (($A_hp+$G_hp+$T_hp) eq '0' && $C_hp > 2)
                            {
                                foreach my $id_tmp (keys %all_ids_tmp)
                                {
                                    $C_hp{$id_tmp} = undef;
                                }
                            }
                            if (($G_hp+$C_hp+$T_hp) eq '0' && $A_hp > 2)
                            {
                                foreach my $id_tmp (keys %all_ids_tmp)
                                {
                                    $A_hp{$id_tmp} = undef;
                                }
                            }
                            if ($A_hp > 0 || $C_hp > 0 || $T_hp > 0 || $G_hp > 0)
                            {
                            }
                        }
                        my @A_hp = keys %A_hp;
                        my @C_hp = keys %C_hp;
                        my @T_hp = keys %T_hp;
                        my @G_hp = keys %G_hp;
                        my $hp_correct = "";
                        if ((@C_hp+@T_hp+@G_hp) eq '0' && (@A_hp > 0.2*($A+$C+$T+$G) || (@A_hp > 0.15*$A && ($C+$T+$G) > 2*$A) || (@A_hp > 5 && @A_hp > 0.2*$A && $A/($C+$T+$G) > 0.5 && $A/($C+$T+$G) < 1.9)))
                        {
                            $best_extension = $best_extension."A";
                            $hp_correct = @A_hp;
                        }
                        elsif ((@A_hp+@T_hp+@G_hp) eq '0' && (@C_hp > 0.2*($A+$C+$T+$G) || (@C_hp > 0.15*$C && ($A+$T+$G) > 2*$C) || (@C_hp > 5 && @C_hp > 0.2*$C && $C/($A+$T+$G) > 0.5 && $C/($A+$T+$G) < 1.9)))
                        {
                            $best_extension = $best_extension."C";
                            $hp_correct = @C_hp;
                        }
                        elsif ((@C_hp+@A_hp+@G_hp) eq '0' && (@T_hp > 0.2*($A+$C+$T+$G) || (@T_hp > 0.15*$T && ($C+$A+$G) > 2*$T) || (@T_hp > 5 && @T_hp > 0.2*$T && $T/($C+$A+$G) > 0.5 && $T/($C+$A+$G) < 1.9)))
                        {
                            $best_extension = $best_extension."T";
                            $hp_correct = @T_hp;
                        }
                        elsif ((@C_hp+@T_hp+@A_hp) eq '0' && (@G_hp > 0.2*($A+$C+$T+$G) || (@G_hp > 0.15*$G && ($C+$T+$A) > 2*$G) || (@G_hp > 5 && @G_hp > 0.2*$G && $G/($C+$T+$A) > 0.5 && $G/($C+$T+$A) < 1.9)))
                        {
                            $best_extension = $best_extension."G";
                            $hp_correct = @G_hp;
                        }
                        if ($hp_correct ne "")
                        {
                            $allele_percentage_back{$l} = $A."+".$C."+".$T."+".$G;
                            print OUTPUT5 $hp_correct." HP_CORRECT\n";
                            $l++;
                            next NUCLEO_BACK;
                        }
                    }
                    if ($heteroplasmy ne "" && $SNP > 0)
                    {
                    }                    
                    delete $SNP_active_back{$id};
                    if ($SNP eq '0')
                    {
                        $A_SNP = $A;
                        $C_SNP = $C;
                        $T_SNP = $T;
                        $G_SNP = $G;
                        $pos_SNP = $l;
                    }
                    if ($SNP eq '1')
                    {
                        $pos_SNP2 = $l;
                    }
                    if ($SNP eq '2')
                    {
                        $pos_SNP3 = $l;
                    }
                    if ($SNP eq '3')
                    {
                        $pos_SNP4 = $l;
                    }
                    
                    print OUTPUT5 $A."+".$C."+".$T."+".$G." COUNTS\n";
                    my @IUPAC = IUPAC($A,$C,$T,$G);
                    if ($IUPAC[0] eq "A" || $IUPAC[0] eq "C" || $IUPAC[0] eq "T" || $IUPAC[0] eq "G")
                    {
                    }
                    else
                    {
                        $SNP++;
                    }
                    $allele_percentage_back{$l} = $A."+".$C."+".$T."+".$G;
                    $best_extension = $best_extension.$IUPAC[0]; 
                }
                elsif ((($heteroplasmy ne "" && $l < $pos_SNP4+10) || $heteroplasmy eq "") && $SNP eq "4" && ($pos_SNP ne 0 || ($pos_SNP4 > $pos_SNP+12) || ($extensions_before eq "yes" && $l > 12))) 
                {
                    print OUTPUT5 $best_extension." BEST_EXT_CHOP\n";
                    $SNP = "yes5_back";
                    my $g = $l;
                    my $pos_SNP_tmp = $pos_SNP;
                    if ($pos_SNP4 > $pos_SNP+12)
                    {
                        $pos_SNP_tmp = $pos_SNP4;
                    }
                    if ($pos_SNP2 > $pos_SNP+5)
                    {
                        $pos_SNP_tmp = $pos_SNP2;
                    }
                    if ($extensions_before ne "yes" && $pos_SNP ne 0 && $SNR_read_back2 eq "")
                    {
                        while ($g > $pos_SNP_tmp)
                        {                                         
                            chop($best_extension);
                            $g--;
                        }
                    }
                    last  NUCLEO_BACK;
                }
                
                elsif (($SNP eq "4" && $pos_SNP eq 0 && $l < 15) || ($l eq 0 && $ext > 4) && ($A + $T + $G + $C) > 4 && ($ext)/($A+$T+$G+$C+$low_quality_nucs+$skipped) < $q)
                {                
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $SNP." SNP\n";
                    }
                    if ($SNR_read ne "" && $no_SNR ne "yes")
                    {
                        $l = '0';
                        $best_extension = "";
                        $no_SNR = "yes";
                        %extensionsb = %extensionsb_backup;
                        
                        goto SPLIT_BACK;
                    }
                    if ($SNP eq '0')
                    {
                        $A_SNP = $A;
                        $C_SNP = $C;
                        $T_SNP = $T;
                        $G_SNP = $G;
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 $best_extension." BEST_EXTENSIONll\n";
                            print OUTPUT5 $A_SNP." A\n";
                            print OUTPUT5 $C_SNP." C\n";
                            print OUTPUT5 $T_SNP." T\n";
                            print OUTPUT5 $G_SNP." G\n";
                        }
                    }
                    $best_extension = "";
                    $split = "yes_back";

                    undef @firstSNP_max;
                    my $w = 0.035;
                    if ($type eq "mito_plant")
                    {
                        $w = 0.015;
                    }

                    if ($A_SNP >= ($C_SNP+$A_SNP+$T_SNP+$G_SNP)*$w && $A_SNP > 0)
                    {
                        if (exists($yuyu_option_back{$id."A"}))
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "YUYU_A_EXISTS\n";
                            }
                        }
                        else
                        {
                            push @firstSNP_max, "A";
                        }  
                    }
                    if ($C_SNP >= ($C_SNP+$A_SNP+$T_SNP+$G_SNP)*$w && $C_SNP > 0)
                    {
                        if (exists($yuyu_option_back{$id."C"}))
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "YUYU_C_EXISTS\n";
                            }
                        }
                        else
                        {
                            push @firstSNP_max, "C";
                        }  
                    }
                    if ($T_SNP >= ($C_SNP+$A_SNP+$T_SNP+$G_SNP)*$w && $T_SNP > 0)
                    {
                        if (exists($yuyu_option_back{$id."T"}))
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "YUYU_T_EXISTS\n";
                            }
                        }
                        else
                        {
                            push @firstSNP_max, "T";
                        }  
                    }
                    if ($G_SNP >= ($C_SNP+$A_SNP+$T_SNP+$G_SNP)*$w && $G_SNP > 0)
                    {
                        if (exists($yuyu_option_back{$id."G"}))
                        {
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 "YUYU_G_EXISTS\n";
                            }
                        }
                        else
                        {
                            push @firstSNP_max, "G";
                        }  
                    }
                    
                    $count_split = @firstSNP_max;
                    my $count_split_tmp = '0';
                    
                    if ($count_split eq '2')
                    {
                        $delete_third = "yes_back";
                        $delete_second = "yes_back";
                    }
                    if ($count_split eq '3')
                    {
                        $delete_third = "yes_back";
                    }
                    if ($count_split eq '1')
                    {
                        $delete_third = "yes_back";
                        $delete_first = "yes_back";
                        $delete_second = "yes_back";
                        $split = "yes4_back";
                    }
                    
                    foreach my $firstSNP_max (@firstSNP_max)
                    {                                            
                        foreach my $extensions_id (keys %extensionsb)
                        {                       
                            my $extensions_tmp = $extensionsb{$extensions_id};
                            my $first_nuc = substr $extensions_tmp, 0, 1;
                            if ($first_nuc eq $firstSNP_max && $count_split_tmp eq '0')
                            {
                                $extensionsb_group1{$extensions_id} = $extensions_tmp;
                            }
                            elsif ($first_nuc eq $firstSNP_max && $count_split_tmp eq '1')
                            {
                                $extensionsb_group2{$extensions_id} = $extensions_tmp;
                            }
                            elsif ($first_nuc eq $firstSNP_max && $count_split_tmp eq '2')
                            {
                                $extensionsb_group3{$extensions_id} = $extensions_tmp;
                            }
                            elsif ($first_nuc eq $firstSNP_max && $count_split_tmp eq '3')
                            {
                                $extensionsb_group4{$extensions_id} = $extensions_tmp;
                            }
                        }
                        $count_split_tmp++;
                    }
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $count_split." COUNT_SPLIT\n";
                    }
                    goto SPLIT_BACK;
                }  
                else
                {  
                    last  NUCLEO_BACK;
                }
                $l++;
            }
            if ($get_more_matches_back ne "no" && $split eq "" && $ext_total_back*$heteroplasmy < 1.1 && $ext_total_back < $mmbr && $repetitive_detect_back eq "" && $heteroplasmy ne ""  && $hp_seed_assemble eq "" &&  $last_chance_back eq "")
            {
                if ($last_chance_back eq "")
                {
                    $last_chance_back = "yes";
                }
                if ($use_quality ne "" && $ext < 20)
                {
                    $no_quality_back = "yes";
                }
                $get_more_matches_back = "yes";
                goto NO_AT;
            }
            if ($ext_total_back*$heteroplasmy > 1000 && $get_more_matches_back eq "yes")
            {
                $last_chance_back = "";
                $get_more_matches_back = "no";
                goto NO_AT;
            }
            my $last_nucleo = substr $best_extension, -1;
            $last_nucleo =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            while ($last_nucleo eq '.')
            {
                chop($best_extension);
                $last_nucleo = substr $best_extension, -1;
                $last_nucleo =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            }

            if ($best_extension eq "" && $removed_N_reads ne "" && $removed_N_reads ne "yes1")
            {
                $removed_N_reads = "yes1";
                $SNP_active_back = "yes";
                %extensionsb = %extensionsb_original;
                print OUTPUT5 $percentage_N." SNP_ACTIVE\n";
                goto REMOVE_N_BACK;
            }
            if ($best_extension eq "" && $use_quality eq "yes" && $SNR_critical_back ne "yes" && $ext_total_back > 4)
            {
                my $N_total = '0';
                my $Total = '1';
                foreach my $extensions_id (keys %extensionsb_original)
                {                                 
                    my $extensions = $extensionsb_original{$extensions_id};                                
                    my $N = $extensions =~ tr/N1234/N1234/;
                    $N_total += $N;
                    $Total += length($extensions);
                }
                print OUTPUT5 $N_total/$Total." BEST_EXTENSION_N2\n";
                if ($N_total/$Total > 0.35 && $split ne "" && $removed_N_reads ne "yes1")
                {
                    $removed_N_reads = "yes1";
                    $split = "";
                    $SNR_read_back = "yes";
                    %extensionsb = %extensionsb_original;
                    $SNR_critical_pos_back{$id} = $position_back;
                    goto REMOVE_N_BACK;
                }
                elsif ($N_total/$Total > 0.35 && $split ne "" && $SNP_active_back eq "")
                {
                    $SNP_active_back = "yes";
                    $split = "";
                    $removed_N_reads = "yes1";
                    %extensionsb = %extensionsb_original;
                    $SNR_critical_pos_back{$id} = $position_back;
                    goto REMOVE_N_BACK;
                }
                if ($N_total/$Total > 0.35)
                {
                    $SNR_critical_back = "yes1";
                    $SNR_critical_back{$id} = "yes";
                    $SNP_active_back{$id} = "yes";
                    $SNR_critical_pos_back{$id} = $position_back;
                    $best_extension = "";
                    $split = "";
                }
            }
            if ($split ne "" && $use_quality eq "yes" && $SNR_critical_back ne "yes" && $ext_total_back > 4)
            {
                my $N_total = '0';
                my $Total = '1';
                foreach my $extensions_id (keys %extensionsb_original)
                {                                 
                    my $extensions = $extensionsb_original{$extensions_id};                              
                    my $N = $extensions =~ tr/N1234/N1234/;
                    $N_total += $N;
                    $Total += length($extensions);
                }
                print OUTPUT5 $N_total/$Total." N_SPLT_SNR\n";
                my $SNR_end0bt = $read_start;
                my $SNR_check = $SNR_end0bt =~ s/AAAA|CCCC|GGGG|TTTT|TATATA//;
                if ($N_total/$Total > 0.25 && $split ne "" && $SNR_check > 0)
                {
                    $SNR_read_back{$id} = "yes";
                }
            }
            if ($SNR_critical_back ne "" && $split eq "")
            {
                $best_extension = substr $best_extension, 0, 5;
            }
            if ($split eq "yes2_back" || ($split eq "yes3_back" && $count_split > 2) || ($split eq "yes4_back" && $count_split > 3))
            {  
                if ($split eq "yes2_back")
                {
                    $best_extension2 = $best_extension;
                }
                elsif ($split eq "yes3_back")
                {
                    $best_extension3 = $best_extension;
                }
                elsif ($split eq "yes4_back")
                {
                    $best_extension4 = $best_extension;
                }
                my $best_extension_tmp = $best_extension;
                $best_extension_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

                if ($y > $startprint2)
                {
                    if ($split eq "yes2_back")
                    {
                        print OUTPUT5 "GROUP2\n";
                        if ($extensions_before ne "yes")
                        {
                            %extensionsb_group2_old = %extensionsb_group2;
                        }
                        if (keys %extensionsb_group2 < 150)
                        {
                            foreach my $extensions_tmp (keys %extensionsb_group2)
                            {  
                                print OUTPUT5 $extensionsb_group2{$extensions_tmp}."\n";                        
                            }
                        }
                        print OUTPUT5 $best_extension_tmp." BEST_EXTENSION_BACK2\n\n";
                    }
                    elsif ($split eq "yes3_back")
                    {
                        print OUTPUT5 "GROUP3\n";
                        if ($extensions_before ne "yes")
                        {
                            %extensionsb_group3_old = %extensionsb_group3;
                        }
                        if (keys %extensionsb_group3 < 150)
                        {
                            foreach my $extensions_tmp (keys %extensionsb_group3)
                            {  
                                print OUTPUT5 $extensionsb_group3{$extensions_tmp}."\n";                        
                            }
                        }
                        print OUTPUT5 $best_extension_tmp." BEST_EXTENSION_BACK3\n\n";
                    }
                    elsif ($split eq "yes4_back")
                    {
                        print OUTPUT5 "GROUP4\n";
                        if ($extensions_before ne "yes")
                        {
                            %extensionsb_group4_old = %extensionsb_group4;
                        }
                        if (keys %extensionsb_group4 < 150)
                        {
                            foreach my $extensions_tmp (keys %extensionsb_group4)
                            {  
                                print OUTPUT5 $extensionsb_group4{$extensions_tmp}."\n";                        
                            }
                        }
                        print OUTPUT5 $best_extension_tmp." BEST_EXTENSION_BACK4\n\n";
                    }    
                }
                if ($split eq "yes2_back")
                {                      
                    if ($count_split eq '2')
                    {
                        $split = "yes4_back";
                    }
                    goto SPLIT_BACK;
                }
                elsif ($split eq "yes3_back")
                {                      
                    if ($count_split eq '3')
                    {
                        $split = "yes4_back";
                    }                                               
                    goto SPLIT_BACK;
                }
                if ($split eq "yes4_back")
                {                      
                    goto SPLIT_BACK;
                }
            }
            elsif ($split eq "yes5_back" || (($variance_detection eq "yes" || $heteroplasmy ne "") && $best_extension ne "" && $repetitive_detect_back eq ""))
            {
                if ($split eq "" && $repetitive_detect_back eq "" && ($variance_detection eq "yes"  || $heteroplasmy ne ""))
                {
                    goto DEL_BACK;
                }
                $best_extension1 = $best_extension;
                
                if ($y > $startprint2)
                {
                    print OUTPUT5 "GROUP1\n";
                    if ($extensions_before ne "yes")
                    {
                        %extensionsb_group1_old = %extensionsb_group1;
                    }
                    if (keys %extensionsb_group1 < 150)
                    {
                        foreach my $extensions_tmp (keys %extensionsb_group1)
                        {  
                            print OUTPUT5 $extensionsb_group1{$extensions_tmp}."\n";                        
                        }
                    }
                    print OUTPUT5 $best_extension1." BEST_EXTENSION_BACK1\n\n";
                }
DEL_BACK:
                my $read_part_back_tmp = substr $read_short_start2, 0, $read_length;
                my $star_check = $read_part_back_tmp =~ tr/\*/\*/;
                my $best_p_from_del = "";

                if ($SNP_active_back eq "yes" && $count_split eq '2' && ($star_check eq 0 || $star_check eq "" || $platform eq "ion") && ($noforward ne "" || $hp_seed_assemble ne ""))
                {
                    my @check_deletion = check_deletion($best_extension1, $best_extension2, $best_extension_old1, $best_extension_old2, "", "back");
                    $best_extension = $check_deletion[0];
                    
                    if ($best_extension ne "")
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 reverse($best_extension)." BEST_EXTENSION_BACK_DEL\n";
                        }            
                        $deletion_back = "yes";
                        $split = "";
                        $best_p_from_del = $check_deletion[3];

                        if ($heteroplasmy eq "" && $variance_detection eq "")
                        {
                            goto INDEL_BACK;
                        }
                        else
                        {
                            my $star_check = $best_extension =~ tr/\*/\*/;
                            $SNPs_indel{-$position_back} = $star_check;
                        }
                    } 
                }
REFERENCE_BACK:
                if ($NUMT_back ne "yes2" && (((length($best_extension1) > 4 && length($best_extension2) > 4) || (length($best_extension_old1) > 4 && length($best_extension_old2) > 4)) && $reference ne ""
                     && $SNP_active_back eq "yes" && $repetitive_detect_back eq "" && $deletion_back eq "" && ($split eq "" || $before ne "")) ||
                    (($variance_detection eq "yes" || $heteroplasmy ne "") && $best_extension ne "" && $repetitive_detect_back eq ""))
                {
                    my $p = 0;
                    my $p_prev = '-100';
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "CHECK_REFERENCE_BACK\n\n";
                    }
                    my $ref_part_prev = "";
                    my $found_further_back = "";
                    my %ref_id3;
                    my @ref_id3;
                    undef %ref_id3;
                    undef @ref_id3;
                    my $further = "";
                    my $first_last_seq_ref;
                    my $last_seq_ref;
                    my $check_back_length = '800';
                    if ($last_ref_seq_back{$id} eq "" && length($read) < 1000)
                    {
                        $check_back_length = '150';
                    }
                    if (exists($large_variance_back{$id}))
                    {
                        $large_variance_tmp_back = "yes";
                    }
                    
                    
CHECK_REF_BACK:     while ($p < $check_back_length && $p < length($read))
                    {
                        if ($found_further_back ne "yes")
                        {
                            undef @ref_id3;
                            undef %ref_id3;
                        }
                        my $read_short_start2_tmp = substr $read, 0, $check_back_length+200;
                        if (exists($last_ref_seq_back{$id}) && $first_last_seq_ref ne "yes" && $first_without_LV_back eq "")
                        {
                            $read_short_start2_tmp = $last_ref_seq_back{$id};
                            if (length($read_short_start2_tmp)+$p < 0)
                            {
                                $first_last_seq_ref = "yes";
                                $read_short_start2_tmp = $read_short_start2;
                            }
                        }
                        my $ref_part2 = substr $read_short_start2_tmp, $p, 30;
                        my $star2;
                        if ($containX_short_start2 > 0)
                        {
                            my $star = $ref_part2 =~ tr/\*/\*/;

                            $ref_part2 = substr $read_short_start2_tmp, $p, 30+($star*2);
                            $star2 = $ref_part2 =~ tr/\*/\*/;                                                
                            while ($star2 > $star)
                            {
                                $ref_part2 = substr $read_short_start2_tmp, $p, 30+($star*2)+(($star2-$star)*2);
                                $star = $star2;
                                $star2 = $ref_part2 =~ tr/\*/\*/;
                            }   
                        }
                        
                        my %ref_part;
                        if ($last_ref_seq_back{$id} eq "")
                        {
                            my $ref_part2_tmp = $ref_part2;
                            my $count_dots = $ref_part2_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
                            if ($count_dots < 6)
                            {
                               %ref_part = build_partial3b $ref_part2_tmp, "back";
                            }
                        }
                        $ref_part{$ref_part2} = undef;
                        
                        if ($found_further_back eq "yes")
                        {
                            $p--;
                        }
                        my $ref_loc = $p;
                        if ($found_further_back eq "")
                        {
REF_PART_BACK:              foreach my $ref_part_tmp (keys %ref_part)
                            {
                                if (exists($hashref{$ref_part_tmp}))
                                {                             
                                    my $ref_id3 = $hashref{$ref_part_tmp};      
                                    my $ref_id2 = substr $ref_id3, 1;
                                    my @ref_id3_tmp2;
                                    undef @ref_id3_tmp2;
                                    
                                    my @ref_id3_tmp = split /,/, $ref_id2;

                                    foreach (@ref_id3_tmp)
                                    {
                                        if (($_ < $last_ref_pos_back{$id}+5000 && $_ > $last_ref_pos_back{$id}-5000 && ($_ <= $last_ref_pos_back{$id}+$ref_loc+1 || $heteroplasmy eq "")) || $last_ref_pos_back{$id} eq "" || $first_150 ne "")
                                        {  
                                            if ($_ < $large_variance_back{$id} || $first_without_LV_back eq "")
                                            {
                                                $ref_id3{$_} = $ref_part_tmp;
                                                push @ref_id3_tmp2, $_;
                                            }
                                        }
                                    }
                                    push @ref_id3, @ref_id3_tmp2;
                                }
                            }
                        }
                        if (@ref_id3 > 1 && exists($last_ref_pos_back{$id}))
                        {
                            my @ref_id3_tmpie;
                            undef @ref_id3_tmpie;
                            foreach my $ref_id (@ref_id3)
                            {
                                if ($ref_id-$ref_loc-1 eq $last_ref_pos_back{$id})
                                {
                                    push @ref_id3_tmpie, $ref_id;
                                }
                            }
                            if (@ref_id3_tmpie eq 1)
                            {
                                undef @ref_id3;
                                foreach my $tmp (@ref_id3_tmpie)
                                {
                                    push @ref_id3, $tmp;
                                }
                            }
                        }
                        if (@ref_id3 eq 1)
                        {
                            foreach my $ref_id (@ref_id3)
                            {
                                my $prev_loc1 = $ref_id - $ref_loc - 1;
                                
                                if ($prev_loc1 eq "-1")
                                {
                                    $prev_loc1 = '0';
                                }
                                $last_ref_pos_back{$id} = $prev_loc1;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $ref_loc." REF_LOC ".$ref_id." REF_ID ".$prev_loc1." PREV_LOC\n";
                                }                               
                                my @delete;
                                undef @delete;
                                if (exists($last_ref_seq_back{$id}) && $first_last_seq_ref ne "yes")
                                {
                                }
                                else
                                {
                                    foreach my $var_pos_tmp (keys %variance_back)
                                    {
                                        my @split = split /\*/, $var_pos_tmp;
                                         
                                        my $var_pos = $split[1];
                                        if ($split[0] eq $id)
                                        {
                                            if ($var_pos < $ref_id && $var_pos > $ref_id-2000)
                                            {
                                                $prev_loc1 += $variance_back{$var_pos_tmp};
                                            }
                                            if ($ref_id - $ref_loc -1 + $check_back_length < $var_pos)
                                            {
                                                push @delete, $var_pos_tmp;
                                            }
                                        }
                                    }
                                }
                                foreach my $delete (@delete)
                                {
                                    delete $variance_back{$delete};
                                }            
                                
                                $last_seq_ref = $hashref2{$prev_loc1+1};
                                print OUTPUT5 $last_seq_ref." LAST_SEQ_REF_BACK\n";
                                if ($y < 80 && $prev_loc1 < 350 && $heteroplasmy ne "" && $hp_seed_assemble eq "")
                                {
                                   print OUTPUT5 $best_extension." BEST_EXTENSION_BACK_NO_VAR_YET\n";
                                   delete $last_ref_seq_back{$id};
                                   delete $last_ref_pos_back{$id};
                                   goto AFTER_EXT_BACK;
                                }
                                elsif ($prev_loc1 < 0 && $y > 80) 
                                {
                                    if ($heteroplasmy ne "" && $first_150 eq "")
                                    {
                                        $noback{$id} = "stop";
                                        $noback = "stop";
                                    }
                                    else
                                    {
                                        if ($split eq "")
                                        {
                                            print OUTPUT5 $best_extension." BEST_EXTENSION_BACK_HP\n";
                                            delete $last_ref_seq_back{$id};
                                            delete $last_ref_pos_back{$id};
                                            goto AFTER_EXT_BACK;
                                        }
                                        goto INDEL_BACK;
                                    }
                                }
                                elsif ($prev_loc1 < -50 && exists($last_ref_seq_back{$id}))
                                {
                                    delete $last_ref_seq_back{$id};
                                    delete $last_ref_pos_back{$id};
                                    goto REFERENCE_BACK;
                                }
                                if (exists($hashref2{$prev_loc1}))
                                {
                                    my $prev_loc1_tmp = $prev_loc1;
                                    my $ref_check_star;
                                    my $ref_check;
                                    my $j = '149';   
                                    
                                    while ($j > -1)
                                    {
                                        my $added_to_ref = "yes";
                                        if (exists($hashref2{$prev_loc1_tmp-$j}) && $j > 29)
                                        {
                                            $ref_check .= $hashref2{$prev_loc1_tmp-$j};
                                            $ref_check_star .= $hashref2{$prev_loc1_tmp-$j};
                                        }
                                        elsif (exists($hashref2{$prev_loc1_tmp-$j}) && $j < 30)
                                        {
                                            my $ref_check_plus = substr $hashref2{$prev_loc1_tmp-$j}, 0, $j+1;
                                            $ref_check .= $ref_check_plus;
                                            $ref_check_star .= $ref_check_plus;
                                            last;
                                        }
                                        elsif (($y > 40 || $hp_seed_assemble ne "" || $heteroplasmy eq "") &&
                                            ($prev_loc1_tmp <= length($best_extension) || ($split ne "" && ($prev_loc1_tmp < length($best_extension1) || $prev_loc1_tmp < length($best_extension2)))))
                                        {
                                            my $best_extension_tmp = substr $best_extension, 0, length($ref_check);
                                            if ($split ne "")
                                            {
                                                $best_extension1 = substr $best_extension1, 0, length($ref_check);
                                                $best_extension2 = substr $best_extension2, 0, length($ref_check);
                                            }
                                            $best_extension = $best_extension_tmp;
                                            $noback{$id} = "stop";
                                            $noback = "stop";
                                        }
                                        else
                                        {
                                            $added_to_ref = "";
                                        }
                                        if ($added_to_ref eq "")
                                        {
                                            $j--;
                                        }
                                        else
                                        {
                                            $j -= 30;
                                        }  
                                    }         
                                    
                                    if ($y > $startprint2)
                                    {
                                        print OUTPUT5 reverse($ref_check)." EXISTSREF1 ".$prev_loc1." PREV_LOC1\n";
                                    }
                                    $ref_check_back = reverse($ref_check);
                                    if ($y eq '1' && $heteroplasmy ne "" && $hp_seed_assemble eq "" && $prev_loc1 <= length($read))
                                    {
                                    }
                                    
                                    my $best_extension_del = $best_extension;
                                    
                                    if (exists($large_variance_back{$id}) && $first_without_LV_back eq "yes2")
                                    {
                                        $variance_back{$id."*".$large_variance_back{$id}} = $large_variance_back{$id}-$prev_loc1_tmp-$large_variance_length_back{$id};
                                        print OUTPUT5 $variance_back{$id."*".$large_variance_back{$id}}." LARGE_DELETION_BACK\n";
                                        delete $last_ref_seq_back{$id};
                                        delete $last_ref_pos_back{$id};
                                        delete $large_variance_back{$id};
                                        delete $large_variance_length_back{$id};
                                        $large_variance_tmp_back = "";
                                    }
                                    if (($variance_detection eq "yes" || $heteroplasmy ne "") && $split eq "" && $repetitive_detect_back eq "")
                                    {
                                        my $prev_loc1_tmp_correction = '0';
                                        my $prev_loc1_tmp_2 = $prev_loc1_tmp;
                                        my $del_detect = '1';
                                        my %hold_SNPs;
                                        my %hold_linked;
                                        undef %hold_SNPs;
                                        undef %hold_linked;
DEL_DETECT_BACK:                        if ($deletion_back eq "yes" && $del_detect eq '1')
                                        {
                                            my $best_extension1_tmp = $best_extension;
                                            $best_extension1_tmp =~ tr/\*//d;
                                            $best_extension = $best_extension1_tmp;
                                        }
                                        elsif ($deletion_back eq "yes" && $del_detect eq '2')
                                        {
                                            my $best_extension2_tmp = $best_extension_del;
                                            $best_extension2_tmp =~ s/\*.//g;
                                            $best_extension = $best_extension2_tmp;
                                        }
                                        
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $best_extension." BEST_EXTENSION_BACK_VAR\n\n";
                                        }
                                        my $best_extension_tmp = $best_extension;
                                        my %not_linked_tmp;
                                        undef %not_linked_tmp;
WITHOUT_LV_BACK:                                        
                                        my $ref_check_tmp = reverse($ref_check);
                                        
                                        if (exists($large_variance_back{$id}) && $first_without_LV_back eq "yes")
                                        {
                                            $ref_check_tmp = reverse($hashref2{$large_variance_back{$id}-150}.$hashref2{$large_variance_back{$id}-120}.$hashref2{$large_variance_back{$id}-90}.$hashref2{$large_variance_back{$id}-60}.$hashref2{$large_variance_back{$id}-30}); 
                                            print OUTPUT5 $ref_check_tmp." EXISTSREF1_VAR_DETECT_BACK\n\n";
                                        }
                                               
                                        my $write_last_SNP = "";
                                        my $deletion_found = "";
                                        my $max_SNP = 1;

                                        if ($no_large_variance_back ne "")
                                        {
                                            if ($no_large_variance_back >= $prev_loc1+75)
                                            {
                                                delete $no_large_variance_back{$id};
                                            }
                                            else
                                            {
                                                $max_SNP = length($best_extension_tmp);
                                            }
                                        }
VAR_START_BACK:                              
                                        my @best_extension = split //, $best_extension_tmp;
                                        my @ref_check = split //, $ref_check_tmp;
                                        my $gh = '0';
                                        my $th = '0';
                                        $prev_loc1_tmp = $prev_loc1_tmp_2;
                                        
VAR_CHECK_BACK:                         while ($gh <= length($ref_check_tmp)-length($best_extension_tmp))
                                        {
                                            my $d = '0';
                                            my $next = '0';
                                            my @pos;
                                            undef @pos;
                                            my $pos = "";
                                            my $pos_first = "";
                                            my $pos_last = "";
                                            my $v = '4';
                                            my $AF = "";
                                            my $DP = "";
                                            my $DP_no_filter = '0';
                                            my $FR = "";
                                            my $LCR = "";
                                            my $check_for_DEL = "";
                                            if ($SNR_read_back ne "")
                                            {
                                                if ($SNR_nucleo_back ne "")
                                                {
                                                    $LCR = "SNR(".$SNR_nucleo_back.")";
                                                }
                                                else
                                                {
                                                    $LCR = "SNR";
                                                }
                                                $v = '8';
                                            }
                                            if ($heteroplasmy ne "")
                                            {
                                                $FR = ";FR=F";
                                            }
                                            my %var_from_forward;
                                            undef %var_from_forward;
                                            my $var_recorderd = '0';
                                            if (length($best_extension_tmp) > 15)
                                            {
                                                $v = '6';
                                            }
                                            if (exists($large_variance_back{$id}))
                                            {
                                                $v = '7';
                                            }
                                            $prev_loc1_tmp += $prev_loc1_tmp_correction;
                                            $prev_loc1_tmp_correction = '0';
                                            
VAR_CHECK_BACK1:                            while ($d < length($best_extension_tmp))
                                            {
                                                $th = $d + $gh;
                                                if ($best_extension[$d] eq $ref_check[$th] || $write_last_SNP eq "yes")
                                                {
                                                    my $variance_indel;
                                                    if (exists($variance_indels{$prev_loc1-$th}))
                                                    {
                                                        $variance_indel = "yes";
                                                    }
                                                    if ($hp_seed_assemble eq "" && exists($variance_all{$prev_loc1-$th}) && $hp_back ne "" && $variance_indel eq "" && $large_variance_tmp_back eq "")
                                                    {
                                                        $next++;
                                                        $pos = $prev_loc1-$th;
                                                        $var_from_forward{$pos} = undef;
                                                        if ($pos_first eq "")
                                                        {
                                                            $pos_first = $d;
                                                        }
                                                        if (exists($hp_forward_data2{$prev_loc1-$th}))
                                                        {
                                                            my @old_hp = split /\+/, $hp_forward_data2{$prev_loc1-$th};
                                                            my @IUPAC = IUPAC($old_hp[0],$old_hp[1],$old_hp[2],$old_hp[3]);
                                                            print OUTPUT5 $old_hp[0]." ".$old_hp[1]." ".$old_hp[2]." ".$old_hp[3]." VAR_FROM_FORW\n";
                                                            substr $best_extension_tmp, $d, 1, $IUPAC[0];
                                                            @best_extension = split //, $best_extension_tmp;
                                                        }
                                                        if ($y > $startprint2)
                                                        {
                                                            print OUTPUT5 $prev_loc1-$th." POS ".$best_extension_tmp." VAR_FROM_FORWARD\n";
                                                        }
                                                        
                                                        if ($best_extension[$d] ne "A" && $best_extension[$d] ne "C" && $best_extension[$d] ne "T" && $best_extension[$d] ne "G")
                                                        {
                                                            $max_SNP++;
                                                        }
                                                        elsif (exists($large_variance_back{$id}) && $first_without_LV_back eq "" && $d ne '0' && $next/($d+1) < 0.13)
                                                        {
                                                            $max_SNP++;
                                                        }
                                                        my $count_pos_tmp = @pos;
                                                        if (($d > length($best_extension_tmp)-6 || ($d > 10 && exists($hp_forward_data2{$prev_loc1-$th}))) &&
                                                             length($best_extension_tmp) > 6 && $count_pos_tmp eq '0' && $no_large_variance_back eq "" && $deletion_back eq "" && $d ne '0')
                                                        {
                                                            $best_extension = substr $best_extension, 0, $d;
                                                            last VAR_CHECK_BACK;
                                                        }
                                                        elsif ($d eq length($best_extension_tmp)-1 && (length($best_extension_tmp) < 10 || $no_large_variance_back ne "") && $write_last_SNP eq "")
                                                        {
                                                            $write_last_SNP = "yes";
                                                            $d--;
                                                            goto VAR_CHECK_BACK1;
                                                        }
                                                        if (($d eq '0' || $deletion_back ne "") && $no_large_variance_back eq "")
                                                        {
                                                            $max_SNP = length($best_extension)/4;
                                                            if ($max_SNP < 3)
                                                            {
                                                                $max_SNP = 3;
                                                            }
                                                            if (length($best_extension) > 15 && $max_SNP < 6)
                                                            {
                                                                $max_SNP = 6;
                                                            }
                                                            if (length($best_extension) > 25 && $max_SNP < 7)
                                                            {
                                                                $max_SNP = 7;
                                                            }
                                                        }
                                                        if (($d > 5 && exists($hp_forward_data2{$prev_loc1-$th})))
                                                        {
                                                            $d--;
                                                            goto VAR_CHECK_BACK1;
                                                        }
                                                        push @pos, $prev_loc1-$th;
                                                    }
                                                    if ($next ne '0' && $large_variance_tmp_back eq "" && (-($pos-$prev_loc1-$gh) < $d-$v || ($d eq length($best_extension_tmp)-1)))
                                                    {
                                                        foreach my $pos_tmp (@pos)
                                                        {
                                                            if (exists $HP_exclude{$pos_tmp})
                                                            {}
                                                            else
                                                            {
                                                                $var_recorderd++;
                                                                my $position_tmp;
                                                                my $nuc_other_than_ref = "";
                                                                my $nuc_other_than_ref_AF = "";
                                                                my $nuc_count_ref = "";
                                                                $pos_last = $prev_loc1-$pos_tmp+1;
                                                                if ($AF eq "")
                                                                {
                                                                    $position_tmp = $pos_first;
                                                                }
                                                                else
                                                                {
                                                                    $position_tmp = $prev_loc1-$pos_tmp;
                                                                }
                                                                
                                                    print OUTPUT5 "\n".$position_tmp." TESh1\n";         
                                                                my @nucs_count = split /\+/, $allele_percentage_back{$position_tmp};
                                                                my ($nucs_alt2, $nucs_alt_array) = IUPAC_reverse($best_extension[$position_tmp]);
                                                               
                                                                my @nucs_alt = @$nucs_alt_array;
                                                                my $nucs_alt;
                                                                my $nucs_alt_save;
                                                                my $AF_save;
                                                                my $AF_no_filter;
                                                                my $no_variance = "";
                                                                my $deduct_duplications_first = '0';
                                                                my $deduct_low_quality_next_nuc_first = '0';
                                                                my $deduct_mismatch_nuc_first = '0';
    
                                                    print OUTPUT5 $allele_percentage_back{$position_tmp}." TESh2\n";
                                                                my $s = '0';
                                                                my @nucs_order = ('A','C','T','G');
                                                                my $AF_high = '0';
                                                                my %allele_ordered;
                                                                undef %allele_ordered;
                                                                my $AF_tmp2 = "";
                                                                my $nuc_other_than_ref_tmp = "";
                                                                if ($hp_seed_assemble ne "")
                                                                {
                                                                    my @variances_tmp = split /\t/, $variance_all{$pos_tmp};
                                                                    my $AF_tmp = $variances_tmp[7]; 
                                                                    if ($AF_tmp =~ m/AF=(\d+\.\d+).*/)
                                                                    {
                                                                        $AF_tmp2 = $1;
                                                                        print OUTPUT5 $AF_tmp2." AF_TMP2\n";
                                                                    }
                                                                    if ($AF_tmp2 > 0.5)
                                                                    {
                                                                        $nuc_other_than_ref_tmp = $variances_tmp[3];
                                                                    }
                                                                    elsif ($AF_tmp2 < 0.5 && $AF_tmp2 ne "")
                                                                    {
                                                                        $nuc_other_than_ref_tmp = $variances_tmp[4];
                                                                    }
                                                                }
                                                                
                                                                $DP_no_filter = $nucs_count[0]+$nucs_count[1]+$nucs_count[2]+$nucs_count[3];
                                                                
                                                                if (($nucs_count[0]+$nucs_count[1]+$nucs_count[2]+$nucs_count[3]) > 0)
                                                                {
                                                                    my $h = '0.001';
                                                                    foreach (@nucs_alt)
                                                                    {  
                                                                        my $nuc_tmp = $_-1;
                                                                        my $AF_tmp = sprintf("%.3g",$nucs_count[$nuc_tmp]/($nucs_count[0]+$nucs_count[1]+$nucs_count[2]+$nucs_count[3]));
                                                                        if ($hp_seed_assemble ne "" && $nuc_other_than_ref_tmp ne "")
                                                                        {
                                                                            if ($nucs_order[$nuc_tmp] eq $nuc_other_than_ref_tmp && @nucs_alt < 3)
                                                                            {
                                                                                $nuc_other_than_ref = $nuc_other_than_ref_tmp;
                                                                                $nuc_other_than_ref_AF = $AF_tmp;  
                                                                            }
                                                                        }
                                                                        elsif ($nucs_order[$nuc_tmp] ne $ref_check[$pos_tmp-$prev_loc1] && @nucs_alt < 3)
                                                                        {
                                                                            $nuc_other_than_ref = $nucs_order[$nuc_tmp];
                                                                            $nuc_other_than_ref_AF = $AF_tmp;
                                                                        }
                                                                        if ($nucs_order[$nuc_tmp] eq $ref_check[$pos_tmp-$prev_loc1] && @nucs_alt < 3 && $nuc_count_ref eq "")
                                                                        {
                                                                            $nuc_count_ref = $nucs_count[$nuc_tmp];
                                                                        }

                                                         print OUTPUT5 $nucs_order[$nuc_tmp]." TESh3\n";
                                                                        
                                                                        if (exists($allele_ordered{$AF_tmp}) && $AF_tmp ne '0')
                                                                        {
                                                                            $allele_ordered{$AF_tmp+0.001} = $nuc_tmp;
                                                                            $h = '0.002';
                                                                        }
                                                                        elsif ($AF_tmp ne '0')
                                                                        {
                                                                           $allele_ordered{$AF_tmp} = $nuc_tmp; 
                                                                        }                                                                    
                                                print OUTPUT5 $AF_tmp." TESh4\n";
                                                                    }
                                                                    my %deduct_duplications;
                                                                    undef %deduct_duplications;
                                                                    my %deduct_duplications_no_filter;
                                                                    undef %deduct_duplications_no_filter;
                                                                    my $count_allele = '1';
                                                                    my $deduct_duplications_total;
                                                                    
                                                                    mismatch (\%extensionsb, \%remove_extension_mismatch, $ref_check_back);
                                                                    my $count_tmp = keys %remove_extension_mismatch_tmp;
                                                                    my $count_tmp2 = keys %extensionsb;
                                                                    if ($count_tmp < $count_tmp2/5 && $split eq "")
                                                                    {
                                                                       %remove_extension_mismatch = (%remove_extension_mismatch, %remove_extension_mismatch_tmp);
                                                                    }
                                                                    my $count_tmp3 = keys %remove_extension_mismatch;
                                                                    foreach my $allele_ordered (sort {$b <=> $a} keys %allele_ordered)
                                                                    {
                                                                        if ($s eq '0')
                                                                        {
                                                                            $nucs_alt = $nucs_order[$allele_ordered{$allele_ordered}];
                                                                            
                                                                            my %count_ext_first;
                                                                            undef %count_ext_first;

HP_NEXT_BACK:                                                               foreach my $ext_tmp (keys %extensionsb)
                                                                            {
                                                                                my $first_nuc = substr $extensionsb{$ext_tmp}, $position_tmp, 1;
                                                                                if ($first_nuc eq $nucs_order[$allele_ordered{$allele_ordered}])
                                                                                {
                                                                                    if (exists($remove_extension_mismatch{$extensionsb{$ext_tmp}}))
                                                                                    {
                                                                                            $deduct_mismatch_nuc_first++;
                                                                                            next HP_NEXT_BACK;
                                                                                    }      
                                                                                    if ($position_tmp > 0)
                                                                                    {
                                                                                        my $next_nuc = substr $extensionsb{$ext_tmp}, $position_tmp-1, 1;
                                                                                        if ($next_nuc eq "N" || $next_nuc eq "1" || $next_nuc eq "2" || $next_nuc eq "3" || $next_nuc eq "4" || $next_nuc eq "")
                                                                                        {
                                                                                            $deduct_low_quality_next_nuc_first++;
                                                                                            next HP_NEXT_BACK;
                                                                                        }
                                                                                    }
                                                                                    if (exists($exlude_id_prev_nuc_hp_back{$ext_tmp}))
                                                                                    {
                                                                                        $deduct_low_quality_next_nuc_first++;
                                                                                        next HP_NEXT_BACK;
                                                                                    }
                                                                                    elsif (length($extensionsb{$ext_tmp}) > $position_tmp+1)
                                                                                    {
                                                                                        if (exists($hp_forward_data2{$pos_tmp}))
                                                                                        {
                                                                                        }
                                                                                        my $next_nuc = substr $extensionsb{$ext_tmp}, $position_tmp+1, 1;
                                                                                        if ($next_nuc eq "N" || $next_nuc eq "1" || $next_nuc eq "2" || $next_nuc eq "3" || $next_nuc eq "4" || $next_nuc eq "")
                                                                                        {
                                                                                            $deduct_low_quality_next_nuc_first++;
                                                                                            next HP_NEXT_BACK;
                                                                                        }
                                                                                    }
                                                            
                                                                                    if (exists($count_ext_first{length($extensionsb{$ext_tmp})}))
                                                                                    {
                                                                                        my $count = $count_ext_first{length($extensionsb{$ext_tmp})}+1;
                                                                                        $count_ext_first{length($extensionsb{$ext_tmp})} = $count;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        $count_ext_first{length($extensionsb{$ext_tmp})} = '1';
                                                                                    }
                                                                                }
                                                                            }
                                                                             
                                                                            foreach my $count_ext_first (keys %count_ext_first)
                                                                            {
                                                                                if ($count_ext_first{$count_ext_first} > ($nucs_count[$allele_ordered{$allele_ordered}]/($read_length-$right-$overlap))*3 && $count_ext_first{$count_ext_first} > 2)
                                                                                {
                                                                                    $deduct_duplications_first += $count_ext_first{$count_ext_first}-(($nucs_count[$allele_ordered{$allele_ordered}]/($read_length-$right-$overlap)))*1.7;
                                                                                }
                                                                            }
                                                                            $deduct_duplications{0} = $nucs_count[$allele_ordered{$allele_ordered}]-$deduct_duplications_first-$deduct_low_quality_next_nuc_first-$deduct_mismatch_nuc_first;
                                                                            $deduct_duplications_no_filter{0} = $nucs_count[$allele_ordered{$allele_ordered}];
                                                                            $deduct_duplications_total = $deduct_duplications_first+$deduct_low_quality_next_nuc_first+$deduct_mismatch_nuc_first;                                                                           
                                                                         print OUTPUT5 $deduct_mismatch_nuc_first." DEDU1\n";
                                                                              print OUTPUT5 $deduct_low_quality_next_nuc_first." DEDU2\n";
                                                                               print OUTPUT5 $deduct_duplications_first." DEDU3\n";
                                                                        }
                                                                        else
                                                                        {
                                                                            $nucs_alt .= ",".$nucs_order[$allele_ordered{$allele_ordered}];
                                                                            print OUTPUT5 $allele_ordered." ALLELE\n";
                                                                            my %count_ext;
                                                                            undef %count_ext;
                                                                            my $deduct_low_quality_next_nuc = '0';
                                                                            my $deduct_mismatch_nuc = '0';
                                                                            
HP_NEXT_BACK2:                                                              foreach my $ext_tmp (keys %extensionsb)
                                                                            {
                                                                                my $first_nuc = substr $extensionsb{$ext_tmp}, $position_tmp, 1;
                                                                                if ($first_nuc eq $nucs_order[$allele_ordered{$allele_ordered}])
                                                                                {   
                                                                                    if (exists($remove_extension_mismatch{$extensionsb{$ext_tmp}}))
                                                                                    {
                                                                                            $deduct_mismatch_nuc++;
                                                                                            next HP_NEXT_BACK2;
                                                                                    }
                                                                                    if ($position_tmp > 0)
                                                                                    {                                                                                        
                                                                                        my $next_nuc = substr $extensionsb{$ext_tmp}, $position_tmp-1, 1;
                                                                                        if ($next_nuc eq "N" || $next_nuc eq "1" || $next_nuc eq "2" || $next_nuc eq "3" || $next_nuc eq "4" || $next_nuc eq "")
                                                                                        {
                                                                                            $deduct_low_quality_next_nuc++;
                                                                                            next HP_NEXT_BACK2;
                                                                                        }
                                                                                    }
                                                                                    if (exists($exlude_id_prev_nuc_hp_back{$ext_tmp}))
                                                                                    {
                                                                                        $deduct_low_quality_next_nuc++;
                                                                                        next HP_NEXT_BACK2;
                                                                                    }
                                                                                    elsif (length($extensionsb{$ext_tmp}) > $position_tmp+1)
                                                                                    {
                                                                                        if (exists($hp_forward_data2{$pos_tmp}))
                                                                                        {
                                                                                        }
                                                                                        my $next_nuc = substr $extensionsb{$ext_tmp}, $position_tmp+1, 1;
                                                                                        if ($next_nuc eq "N" || $next_nuc eq "1" || $next_nuc eq "2" || $next_nuc eq "3" || $next_nuc eq "4" || $next_nuc eq "")
                                                                                        {
                                                                                            $deduct_low_quality_next_nuc++;
                                                                                            next HP_NEXT_BACK2;
                                                                                        }
                                                                                    }
                                                                                    if (exists($count_ext{length($extensionsb{$ext_tmp})}))
                                                                                    {
                                                                                        my $count = $count_ext{length($extensionsb{$ext_tmp})}+1;
                                                                                        $count_ext{length($extensionsb{$ext_tmp})} = $count;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        $count_ext{length($extensionsb{$ext_tmp})} = '1';
                                                                                    }
                                                                                }
                                                                            }
                                                                            my $deduct_duplications = '0';
                                                                            foreach my $count_ext (keys %count_ext)
                                                                            {
                                                                                if ($count_ext{$count_ext} > ($nucs_count[$allele_ordered{$allele_ordered}]/($read_length-$right-$overlap))*3 && $count_ext{$count_ext} > 2)
                                                                                {
                                                                                    $deduct_duplications += $count_ext{$count_ext}-($nucs_count[$allele_ordered{$allele_ordered}]/($read_length-$right-$overlap))*1.7;
                                                                                }
                                                                            }
                                                                            $deduct_duplications{$count_allele} = $nucs_count[$allele_ordered{$allele_ordered}]-$deduct_duplications-$deduct_low_quality_next_nuc-$deduct_mismatch_nuc;
                                                                            $deduct_duplications_no_filter{$count_allele} = $nucs_count[$allele_ordered{$allele_ordered}];
                                                                            $deduct_duplications_total += ($deduct_duplications+$deduct_low_quality_next_nuc+$deduct_mismatch_nuc);
                                                                            print OUTPUT5 $deduct_duplications{$count_allele}." GIGI\n";
                                                                            if ($deduct_duplications{$count_allele} < 1)
                                                                            {
                                                                                 delete $deduct_duplications{$count_allele};
                                                                            }
                                                                            $count_allele++;   
                                                                        }
                                                                        $s++;
                                                                    }
                                                                    my @new_nuc_alt = split /,/, $nucs_alt;
                                                                    my $count_AFs = keys %deduct_duplications;
                                                                    if ($count_AFs eq 1 && $variance_detection eq "" && $split eq "" && $deletion_back eq "")
                                                                    {
                                                                        foreach my $DD (keys %deduct_duplications)
                                                                        {
                                                                            if (exists($variance_all{$pos_tmp}) && $hp_seed_assemble eq "")
                                                                            {}
                                                                            elsif (exists($variance_all_homo{$pos_tmp}) && $hp_seed_assemble eq "")
                                                                            {}
                                                                            else
                                                                            {    
                                                                                substr $best_extension_tmp, $position_tmp, 1, $new_nuc_alt[$DD];
                                                                                substr $best_extension, $position_tmp, 1, $new_nuc_alt[$DD];
                                                                                print OUTPUT5 $best_extension_tmp." TEST_EXT_BACK\n";
                                                                            }
                                                                        }
                                                                    }
                                                                    my $new_total_nuc = $nucs_count[0]+$nucs_count[1]+$nucs_count[2]+$nucs_count[3]-$deduct_duplications_total;
                                                                    if ($new_total_nuc <= '0')
                                                                    {
                                                                        $new_total_nuc = '1';
                                                                    }
                                                                    if (exists ($variance_all{$pos_tmp}))
                                                                    {}
                                                                    elsif ($new_total_nuc < 10 && $hp_seed_assemble eq "")
                                                                    {
                                                                        $d++;
                                                                        next VAR_CHECK_BACK1;
                                                                    }
                                                                    $DP = int($new_total_nuc);
                                                                    
                                                                    if ($heteroplasmy ne "")
                                                                    {
                                                                        $no_variance = "yes";
                                                                    }
                                                                    
                                                                    my $new_nucs_alt = "";
                                                                    foreach my $deduct_duplications_tmp (sort {$a <=> $b} keys %deduct_duplications)
                                                                    {   
                                                                        my $AF_tmp = sprintf("%.3g",($deduct_duplications{$deduct_duplications_tmp})/$new_total_nuc);
                                                                        my $AF_tmp_no_filter = sprintf("%.3g",($deduct_duplications_no_filter{$deduct_duplications_tmp})/$DP_no_filter);
                                                                        
                                                                        print OUTPUT5 $AF_tmp." NO_VARIANCE\n";
                                                                        if ($AF_tmp < 0)
                                                                        {
                                                                            $AF_tmp = '0';
                                                                        }
                                                                        if ($deduct_duplications_tmp eq '0')
                                                                        {
                                                                            $AF = $AF_tmp;
                                                                            $AF_save = $AF_tmp;
                                                                            $AF_no_filter = $AF_tmp_no_filter;
                                                                            $nucs_alt_save = $new_nuc_alt[$deduct_duplications_tmp];
                                                                            if ($hp_seed_assemble ne "" && $nuc_other_than_ref eq $new_nuc_alt[$deduct_duplications_tmp])
                                                                            {
                                                                                $nuc_other_than_ref_AF = $AF_tmp;
                                                                            }
                                                                            if ($hp_seed_assemble eq "")
                                                                            {
                                                                                $variance_pos_to_nuc_to_freq{$pos_tmp}{$new_nuc_alt[$deduct_duplications_tmp]} = $AF_tmp;
                                                                            }
                                                                        }
                                                                        elsif ($AF_tmp >= $heteroplasmy)
                                                                        {
                                                                            $AF .= ",".$AF_tmp;
                                                                            $AF_save .= ",".$AF_tmp;
                                                                            $AF_no_filter .= ",".$AF_tmp_no_filter;
                                                                            $new_nucs_alt .= ",".$new_nuc_alt[$deduct_duplications_tmp];
                                                                            $nucs_alt_save .= ",".$new_nuc_alt[$deduct_duplications_tmp];
                                                                            $no_variance = "";
                                                                            if ($hp_seed_assemble ne "" && $nuc_other_than_ref eq $new_nuc_alt[$deduct_duplications_tmp])
                                                                            {
                                                                                $nuc_other_than_ref_AF = $AF_tmp;
                                                                            }
                                                                            if ($hp_seed_assemble eq "")
                                                                            {
                                                                                $variance_pos_to_nuc_to_freq{$pos_tmp}{$new_nuc_alt[$deduct_duplications_tmp]} = $AF_tmp;
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            $AF_save .= ",".$AF_tmp;
                                                                            $AF_no_filter .= ",".$AF_tmp_no_filter;
                                                                            $nucs_alt_save .= ",".$new_nuc_alt[$deduct_duplications_tmp];
                                                                            if ($hp_seed_assemble eq "")
                                                                            {
                                                                                $variance_pos_to_nuc_to_freq{$pos_tmp}{$new_nuc_alt[$deduct_duplications_tmp]} = $AF_tmp;
                                                                            }
                                                                        }
                                                                    }
                                                                    $nucs_alt = substr $new_nucs_alt, 1;
                                                                }
                                                                else
                                                                {
                                                                    last VAR_CHECK_BACK1;
                                                                }
                                                                
                                                                my $nuc_in_ext_hp = substr $best_extension, $position_tmp, 1;
                                                                
                                                                if ($variance_detection eq "yes")
                                                                {
                                                                    $variance_no_hp{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$ref_check[$position_tmp]."\t".$nucs_alt."\t.\t.\tAF=".$AF.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                }
                                                                elsif ($hp_seed_assemble eq "" && ($no_variance ne "yes" || exists($variance_all{$pos_tmp})))
                                                                {
                                                                    if ((exists($variance_all{$pos_tmp}) || exists($hp_forward_data{$pos_tmp}) ||  exists($hp_forward_data2{$pos_tmp})) && $hp_back ne "")
                                                                    {
                                                                        my $old_DP_no_filter;
                                                                        my @old;
                                                                        undef @old;
                                                                        if (exists($variance_all{$pos_tmp}))
                                                                        {
                                                                            @old = split /\t/, $variance_all{$pos_tmp};
                                                                            print OUTPUT5 $variance_all{$pos_tmp}." OLD1\n";
                                                                            if (exists($var_from_forward{$pos_tmp}))
                                                                            {
                                                                                $FR = ";FR=R";
                                                                            }
                                                                            else
                                                                            {
                                                                                $FR = ";FR=FR";
                                                                            }
                                                                        }
                                                                        elsif (exists($hp_forward_data{$pos_tmp}))
                                                                        {
                                                                            @old = split /\t/, $hp_forward_data{$pos_tmp};
                                                                            print OUTPUT5 $hp_forward_data{$pos_tmp}." OLD2\n";
                                                                        }
                                                                        print OUTPUT5 $old[7]." OLD_AF\n";
                                                                        if ($old[7] =~ m/^AF=(\d+.*\d+);DP=(\d+).*/ || exists($hp_forward_data2{$pos_tmp}))
                                                                        {
                                                                            my $old_DP = $2;
                                                                            my $comb_DP = $DP+$old_DP;
                                                                            my $old_AF = $1;
                                                        print OUTPUT5 $old_AF." NUC_OLD\n";
                                                         print OUTPUT5 $AF." NUC_NEW\n";
                                                         print OUTPUT5 $old[4]." ALT_NUC_OLD\n"; 
                                                                            my @old_AF = split /,/, $old_AF;
                                                                            my @old_AF_no_filter;
                                                                            my @old_nuc_alt_no_filter;
                                                                            my @new_AF = split /,/, $AF_save;
                                                                            my @new_AF_no_filter = split /,/, $AF_no_filter;
                                                                            my @old_nuc_alt = split /,/, $old_nucs_alt{$pos_tmp};
                                                                            my @new_nuc_alt = split /,/, $nucs_alt_save;
                                                                            my $AF_comb;
                                                                            my $d = '0';
                                                                            my %old_nucs_checked;
                                                                            my $new_nucs_alt = "";
                                                                            my $hp_threshold_total = '0';
                                                                            if (exists($hp_forward_data2{$pos_tmp}))
                                                                            {
                                                                                my @old_hp_no_filter = split /\+/, $hp_forward_data2{$pos_tmp};
                                                                                $old_DP_no_filter = '0';
                                                                                foreach my $old_hp (@old_hp_no_filter)
                                                                                {
                                                                                    $old_DP_no_filter += $old_hp;
                                                                                }
                                                                                foreach my $old_hp (@old_hp_no_filter)
                                                                                {
                                                                                    my $old_AF = $old_hp/$old_DP_no_filter;
                                                                                    push @old_AF_no_filter, $old_AF;
                                                                                }
                                                                                @old_nuc_alt_no_filter = ("A","C","T","G");
                                                                                print OUTPUT5 $hp_forward_data2{$pos_tmp}." OLD_DATA\n";
                                                                                if ($old_DP eq "")
                                                                                {
                                                                                    $old_DP = $old_DP_no_filter;
                                                                                    $comb_DP = $DP+$old_DP_no_filter;
                                                                                    @old_AF = @old_AF_no_filter;
                                                                                    @old_nuc_alt = @old_nuc_alt_no_filter;
                                                                                }
                                                                            }
NEW_AF_BACK:                                                                foreach my $new_AF (@new_AF)
                                                                            {
                                                                                my $b = '0';
                                                                                my $found_nuc = "";
                                                                                print OUTPUT5 $new_AF." NEW_AF\n";    
                                                                                while ($b < @old_nuc_alt)
                                                                                {
                                                                                    if ($old_nuc_alt[$b] eq $new_nuc_alt[$d])
                                                                                    {
                                                                                        $old_nucs_checked{$b} = undef;
                                                                                        my $cov = ($new_AF*$DP)+($old_AF[$b]*$old_DP);
                                                                                        my $comb_AF = sprintf("%.3g",$cov/($DP+$old_DP));
                                                                                        my $comb_AF_no_filter = '0';
                                                                                        print OUTPUT5 $cov." COV\n";
                                                                                        print OUTPUT5 $old_AF[$b]." OLD_AF\n";
                                                                                         print OUTPUT5 $DP." DP\n";
                                                                                          print OUTPUT5 $old_DP." OLD_DP\n"; 
                                                                                        print OUTPUT5 $comb_AF." COMB_AF\n";     
                                                                                        my $s = '0';
                                                                                        my $s2 = "";
                                                                                        if ($old_AF[$b] eq 0 && $old_DP > $DP/2)
                                                                                        {
                                                                                            $d++;
                                                                                            next NEW_AF_BACK;
                                                                                        }
                                                                                        
                                                                                        while ($s < @old_nuc_alt_no_filter)
                                                                                        {
                                                                                            if ($old_nuc_alt_no_filter[$s] eq $new_nuc_alt[$d])
                                                                                            {
                                                                                                my $cov_no_filter = ($new_AF_no_filter[$d]*$DP_no_filter)+($old_AF_no_filter[$s]*$old_DP_no_filter);
                                                                                                $comb_AF_no_filter = sprintf("%.3g",$cov_no_filter/($DP_no_filter+$old_DP_no_filter));
                                                                                                $s2 = $s;
                                                                                            }
                                                                                            $s++;
                                                                                        }
                                                                                         print OUTPUT5 $comb_AF_no_filter." COMP_AF_nofilter\n";   
                                                                                        if ($comb_AF > $heteroplasmy-0.0005 && $comb_AF_no_filter > $heteroplasmy*0.88 && $comb_AF > 0.0059 && $comb_AF_no_filter > 0.0059 &&
                                                                                           ($old_AF[$b] > 0.2*$new_AF || $old_DP*$heteroplasmy < 1.3 || $old_AF[$b] > $heteroplasmy) && ($new_AF > 0.2*$old_AF[$b] || $DP*$heteroplasmy < 1.3 || $new_AF > $heteroplasmy) &&
                                                                                           ($old_AF_no_filter[$s2] > 0.2*$new_AF_no_filter[$d] || $old_DP_no_filter*$heteroplasmy < 1.3 || $old_AF_no_filter[$s2] > $heteroplasmy) &&
                                                                                           ($new_AF_no_filter[$d] > 0.2*$old_AF_no_filter[$s2] || $DP_no_filter*$heteroplasmy < 1.3 || $new_AF_no_filter[$d] > $heteroplasmy))
                                                                                        {
                                                                                            $hp_threshold_total++;
                                                                                            if ($new_nuc_alt[$d] ne $ref_check[$position_tmp])
                                                                                            {
                                                                                                $AF_comb .= ",".$comb_AF;
                                                                                                $new_nucs_alt .= ",".$new_nuc_alt[$d];
                                                                                            }
                                                                                        }
                                                                                        $found_nuc = "yes";
                                                                                    }
                                                                                    $b++;
                                                                                }
                                                                                
                                                                                if ($found_nuc eq "")
                                                                                {
                                                                                    my $cov = ($new_AF[$d]*$DP);
                                                                                    my $comb_AF = sprintf("%.3g",$cov/($DP+$old_DP));
                                                                                    if ($comb_AF > $heteroplasmy-0.0005)
                                                                                    {
                                                                                        $hp_threshold_total++;
                                                                                        if ($new_nuc_alt[$d] ne $ref_check[$position_tmp])
                                                                                        {
                                                                                            $AF_comb .= ",".$comb_AF;
                                                                                            $new_nucs_alt .= ",".$new_nuc_alt[$d];
                                                                                        }
                                                                                    }
                                                                                }
                                                                                $d++;
                                                                            }
                                                                            if (@old_nuc_alt > @new_nuc_alt && exists($variance_all{$pos_tmp}))
                                                                            {
                                                                                my $b = '0';
OLD_NUC_ALT_BACK:                                                               while ($b < @old_nuc_alt)
                                                                                {
                                                                                    if (exists($old_nucs_checked{$b}))
                                                                                    {}
                                                                                    else
                                                                                    { 
                                                                                        my $cov = ($old_AF[$b]*$old_DP);
                                                                                        my $comb_AF = sprintf("%.3g",$cov/($DP+$old_DP));
                                                                                        if ($DP > $old_DP/2)
                                                                                        {
                                                                                            $b++;
                                                                                            next OLD_NUC_ALT_BACK;
                                                                                        }
                                                                                        my $cov_no_filter = $old_AF_no_filter[$b]*$old_DP_no_filter;
                                                                                        my $comb_AF_no_filter = sprintf("%.3g",$cov_no_filter/($DP_no_filter+$old_DP_no_filter));
                                                                                    print OUTPUT5 $comb_AF." COMB_AF0\n"; 
                                                                                        if  ($comb_AF > $heteroplasmy-0.0005 && ($old_AF[$b] > 0.2*0 || $old_DP*$heteroplasmy < 1.3 || $old_AF[$b] > $heteroplasmy) &&
                                                                                            (0 > 0.2*$old_AF[$b] || $DP*$heteroplasmy < 1.3 || 0 > $heteroplasmy) &&
                                                                                            ($old_AF_no_filter[$b] > 0.2*0 || $old_DP_no_filter*$heteroplasmy < 1.3 || $old_AF_no_filter[$b] > $heteroplasmy) &&
                                                                                            (0 > 0.2*$old_AF_no_filter[$b] || $DP_no_filter*$heteroplasmy < 1.3 || 0 > $heteroplasmy))
                                                                                        {
                                                                                            $hp_threshold_total++;
                                                                                            $AF_comb .= ",".$comb_AF;
                                                                                            $new_nucs_alt .= ",".$old_nuc_alt[$b];
                                                                                        }
                                                                                    }
                                                                                    $b++;
                                                                                }
                                                                            }
                                                                            print OUTPUT5 $new_nucs_alt." FFFFFFFFFFFFFFFF\n";
                                                                            $nucs_alt = substr $new_nucs_alt, 1;
                                                                            substr $AF_comb, 0, 1, "";
                                                                            print OUTPUT5 $hp_threshold_total." HP_TOTAL\n";
                                                                            if ($hp_threshold_total > 1)
                                                                            {
                                                                                print OUTPUT5 $AF_comb." AF_COMB_FINAL\n";
                                                                                $variance_all{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$ref_check[$position_tmp]."\t".$nucs_alt."\t.\t.\tAF=".$AF_comb.";DP=".$comb_DP.$FR.";LCR=".$LCR;
                                                                                $variance_all_SNP{$pos_tmp} = $nucs_alt;
                                                                            }
                                                                            else
                                                                            {
                                                                                delete $variance_all{$pos_tmp};
                                                                            }
                                                                        }
                                                                    }
                                                                    elsif ($no_variance ne "yes")
                                                                    {
                                                                        my @new_AF = split /,/, $AF_save;
                                                                        my @new_nuc_alt = split /,/, $nucs_alt_save;
                                                                        my $d = '0';
                                                                        my $AF_final = "";
                                                                        my $final_nucs_alt = "";
                                                                        foreach my $new_AF (@new_AF)
                                                                        {
                                                                            if ($new_nuc_alt[$d] ne $ref_check[$position_tmp])
                                                                            {
                                                                                $AF_final .= ",".$new_AF;
                                                                                $final_nucs_alt .= ",".$new_nuc_alt[$d];
                                                                            }
                                                                            $d++;
                                                                        }
                                                                        my $final_nucs_altb = substr $final_nucs_alt, 1;
                                                                        my $AF_finalb = substr $AF_final, 1;
                                                                        $variance_all_SNP{$pos_tmp} = $final_nucs_altb;
                                                                        $variance_all{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$ref_check[$position_tmp]."\t".$final_nucs_altb."\t.\t.\tAF=".$AF_finalb.";DP=".$DP.$FR.";LCR=".$LCR;
                                                                    }
                                                                }
                                                                elsif ($ref_check[$position_tmp] ne $nuc_in_ext_hp && ($nuc_in_ext_hp eq "A" || $nuc_in_ext_hp eq "C" || $nuc_in_ext_hp eq "T" || $nuc_in_ext_hp eq "G") && $hp_seed_assemble ne "")
                                                                {                                                              
                                                                    my $pos_SNPs = -($position_back+$position_tmp+1);                                                                
                                                                    if (exists($variance_all_homo{$pos_tmp}))
                                                                    {
                                                                        print OUTPUT5 $pos_tmp." H\n";
                                                                    }
                                                                    elsif ($del_detect eq "1" && $deletion_back ne "")
                                                                    {
                                                                        $hold_SNPs{$pos_SNPs} = $nuc_in_ext_hp;
                                                                        $hold_linked{$pos_tmp} = undef;
                                                                    }
                                                                    elsif ($del_detect eq "2" && $deletion_back ne "")
                                                                    {
                                                                        if (exists($hold_SNPs{$pos_SNPs}))
                                                                        {
                                                                            $SNPs{$pos_SNPs} = $nuc_in_ext_hp;
                                                                        }
                                                                        if (exists($hold_linked{$pos_tmp}))
                                                                        {
                                                                            $linked_SNPs{$pos_tmp} = undef;
                                                                        }
                                                                    }
                                                                    else
                                                                    {        
                                                                        $SNPs{$pos_SNPs} = $nuc_in_ext_hp;
                                                                        $linked_SNPs{$pos_tmp} = undef;
                                                                    }
                                                                    if (exists($NUMT_assembled{$pos_tmp}))
                                                                    {
                                                                        print OUTPUT5 $pos_tmp." NUMT_ALERT_BACK\n";
                                                                        $NUMT_back = "yes";
                                                                        delete $seed{$id};
                                                                        goto HP0;
                                                                    }
                                                                }
                                                                elsif ($ref_check[$position_tmp] ne $nuc_in_ext_hp && $no_variance ne "yes" && $hp_seed_assemble ne "")
                                                                {
                                                                    if (exists($variance_all_homo{$pos_tmp}))
                                                                    {
                                                                        print OUTPUT5 $pos_tmp." H\n";
                                                                    }
                                                                    else
                                                                    {
                                                                        my $test_c = '0';
                                                                        foreach my $l_h_SNPs (keys %linked_half_SNPs)
                                                                        {
                                                                            $test_c++;
                                                                        }
                                                                        if ($test_c > 10000 && $PCR_free ne "yes")
                                                                        {
                                                                            $noback{$id} = "stop_HP";
                                                                            print OUTPUT5 "STOP_HALF_LINKED_BACK\n";
                                                                        }
                                                                        my $pos_SNPs = -($position_back+$position_tmp+1);
                                                                        $linked_half_SNPs{$pos_tmp} = $pos_SNPs;
    
                                                                        my $pos_tmp_start = $pos_tmp-20;
                                                                        my $found_homo = "";
                                                                        while ($pos_tmp_start < $pos_tmp+20)
                                                                        {
                                                                            if (exists($variance_all_homo{$pos_tmp_start}) && $SNR_read_back ne "")
                                                                            {
                                                                                $found_homo = "yes";
                                                                                last VAR_CHECK_BACK;
                                                                            }
                                                                            $pos_tmp_start++;
                                                                        }
                                                                        if (($PCR_free ne "yes" && $test_c < 10 && $nuc_other_than_ref_AF > 0.65) || (($nuc_other_than_ref_AF > 0.7 && ($nuc_count_ref < 5)) || $nuc_other_than_ref_AF > 0.9))
                                                                        {
                                                                            if ($nuc_other_than_ref ne "")
                                                                            {
                                                                                $SNPs{$pos_SNPs} = $nuc_other_than_ref;
                                                                                $linked_SNPs{$pos_tmp} = undef;
                                                                            }
                                                                            substr $best_extension, $position_tmp, 1, $nuc_other_than_ref;
                                                                            substr $best_extension, $pos_tmp-$prev_loc1+1, length($best_extension)-($pos_tmp-$prev_loc1), "";
                                                                            last VAR_CHECK_BACK;
                                                                        }
                                                                    }
                                                                }
                                                                print OUTPUT5 $pos_tmp." POSI\n";
                                                            }
                                                        }   
                                                        $next = '0';
                                                        undef @pos;
                                                    }
                                                    elsif ($hp_seed_assemble ne "" && ($deletion_back eq "" || (@pos < 2 && $d > 2)) && $large_variance_tmp_back eq "")
                                                    {
                                                        my $check = "";
                                                        foreach my $pos_tmp (keys %variance_all_SNP)
                                                        {
                                                            if (exists($variance_all_SNP_seed{$pos_tmp}))
                                                            {}
                                                            elsif ($pos_tmp eq $prev_loc1-$d)
                                                            {
                                                                $not_linked_SNPs{$pos_tmp} = undef;
                                                                print OUTPUT5 $pos_tmp." NOT_LINKED\n";
                                                                $not_linked_tmp{$pos_tmp} = $d;
                                                            }                                    
                                                        }
                                                    }
                                                }
                                                elsif (($next < $max_SNP || $deletion_found eq "yes") && exists($HP_exclude{$prev_loc1-$th}))
                                                {
                                                    $variance_all_SNP{$prev_loc1-$th} = $best_extension[$d];
                                                }
                                                elsif (($next < $max_SNP || $deletion_found eq "yes") && $check_for_DEL ne "yes")
                                                {
                                                    if ($deletion_back ne "" && $check_for_DEL eq "")
                                                    {
                                                        $check_for_DEL = "yes";
                                                    }
                                                    elsif ($deletion_back ne "" && $check_for_DEL eq "yes")
                                                    {
                                                        $check_for_DEL = "yes2";
                                                    }
                                                    if ($y > $startprint2)
                                                    {
                                                        print OUTPUT5 $ref_check[$th]." VAR_DETECT\n";
                                                    }
                                                    if (($pos_first eq '0' || $SNR_read_back ne "") && $need_longer_ext_back eq "" && length($best_extension) < 9)
                                                    {
                                                        $need_longer_ext_back = "yes";
                                                        goto BACK;
                                                    }

                                                    $pos = $prev_loc1-$th;
                                                    $next++;
                                                    if ($best_extension[$d] ne "A" && $best_extension[$d] ne "C" && $best_extension[$d] ne "T" && $best_extension[$d] ne "G")
                                                    {
                                                        $max_SNP++;
                                                    }
                                                    elsif (exists($large_variance_back{$id}) && $first_without_LV_back eq "" && $d ne '0' && $next/($d+1) < 0.13)
                                                    {
                                                        $max_SNP++;
                                                    }
                                                    my $count_pos_tmp = @pos;
                                                    push @pos, $prev_loc1-$th;
                                                    if ($pos_first eq "")
                                                    {
                                                        $pos_first = $d;
                                                    }
                                                    if ($d > length($best_extension_tmp)-6 && length($best_extension_tmp) > 6 && $count_pos_tmp eq '0' && $no_large_variance_back eq "" && $deletion_back eq "" && $d ne '0')
                                                    {
                                                        $best_extension = substr $best_extension, 0, $d;
                                                        last VAR_CHECK_BACK;
                                                    }
                                                    elsif ($d eq length($best_extension_tmp)-1 && (length($best_extension_tmp) < 10 || $no_large_variance_back ne ""))
                                                    {
                                                        $write_last_SNP = "yes";
                                                        $d--;
                                                    }
                                                    if (($d eq '0' || $deletion_back ne "") && $no_large_variance_back eq "")
                                                    {
                                                        $max_SNP = length($best_extension)/4;
                                                        if ($max_SNP < 3)
                                                        {
                                                            $max_SNP = 3;
                                                        }
                                                        if (length($best_extension) > 15 && $max_SNP < 6)
                                                        {
                                                            $max_SNP = 6;
                                                        }
                                                        if (length($best_extension) > 25 && $max_SNP < 7)
                                                        {
                                                            $max_SNP = 7;
                                                        }
                                                    }
                                                }                                                
                                                elsif ($next > 0 && ($pos_first ne '0' || $var_recorderd > 0) && $deletion_back eq "" && $large_variance_tmp_back eq "")
                                                {
                                                    my $best_extension_tmp = $best_extension;
                                                    if ($pos_last eq "")
                                                    {
                                                        $pos_last = $pos_first;
                                                    }
                                                    $best_extension = substr $best_extension_tmp, 0, $pos_last;
                                                    foreach my $not_linked (keys %not_linked_tmp)
                                                    {
                                                        if ($not_linked_tmp{$not_linked} >= $prev_loc1-$pos_last)
                                                        {
                                                            delete $not_linked_SNPs{$not_linked};
                                                            delete $not_linked_tmp{$not_linked};
                                                        }
                                                    }
                                                    if ($y > $startprint2)
                                                    {
                                                        print OUTPUT5 $best_extension." BEST_EXT_CUT\n";
                                                    }
                                                    last VAR_CHECK_BACK;
                                                }
                                                elsif ((($next >= $max_SNP && ($pos_first eq '0' || ($pos_first < '3' && $deletion_back ne "")) && $deletion_found ne "yes") || $check_for_DEL eq "yes")
                                                       && ($large_variance_tmp_back eq "" || length($best_extension) > 15))
                                                {
                                                    if ($check_for_DEL eq "yes")
                                                    {
                                                        $check_for_DEL = "yes2";
                                                    }
                                                    foreach my $not_linked (keys %not_linked_tmp)
                                                    {
                                                        delete $not_linked_SNPs{$not_linked};
                                                        delete $not_linked_tmp{$not_linked};
                                                    }
                                                    my @check_deletion;
                                                    undef @check_deletion;
                                                    @check_deletion = check_deletion($best_extension_tmp, $ref_check_tmp,"","","yes","");
                                                    
                                                    my $var_deletion = $check_deletion[0];
                                                    my $one_or_two = $check_deletion[1];
                                                    my $shorter = $check_deletion[2];
                                                    my $deletion_length0 = $check_deletion[3];
                                                    print OUTPUT5 $var_deletion." VAR_DEL_DETECT_BACK\n";
                                                    print OUTPUT5 $one_or_two." ONE_OR_TWO\n";                                            
                                                    
                                                    if ($var_deletion =~ m/(.*)\*(.*)?/)
                                                    { 
                                                        if ($heteroplasmy ne "" && $best_p_from_del ne $deletion_length0 && $best_p_from_del ne '0' && $hp_seed_assemble eq "" && $deletion_back ne "")
                                                        {
                                                            print OUTPUT5 "GOTO_REF\n";
                                                            $best_extension = "";
                                                            $before_back = "yes";
                                                            delete $last_ref_pos_back{$id};
                                                            delete $last_ref_seq_back{$id};
                                                            goto REF_GUIDED_BACK;
                                                        }
                                                        my $deletion_tmp = $1;
                                                        my $after_deletion = $2;
                                                        $deletion_tmp =~ tr/\*//d;
                                                        my $last_nuc = substr $after_deletion, 0, 1;
                                                        my $loc_in_ref = $prev_loc1-$gh;
                                                        if (exists($large_variance_back{$id}) && $first_without_LV_back ne "")
                                                        {          
                                                            my $deletion_length = $large_variance_back{$id}-$prev_loc1;
                                                            my $deletion_length_tmp = length($deletion_tmp);
                                                            my $deleted_part = substr $read_short_start2, 0, $deletion_length;
                                                            $loc_in_ref = $large_variance_back{$id};
                                                            
                                                            if (length($best_extension) < 13)
                                                            {
                                                                $deletion_length_tmp = $overlap - length($deletion_tmp);
                                                            }
                                                            if ($one_or_two eq "one")
                                                            {
                                                                $deletion_length += $deletion_length_tmp;
                                                                $deleted_part = reverse($deletion_tmp).$deleted_part;
                                                                $loc_in_ref -= 1;
                                                            }
                                                            else
                                                            {
                                                                $deletion_length -= $deletion_length_tmp;
                                                                substr $deleted_part, 0, $deletion_length_tmp, "";
                                                            }
                                                            
                                                            if (length($best_extension) < 13)
                                                            {
                                                                if ($overlap > length($deletion_tmp))
                                                                {
                                                                    $deleted_part = substr $read_short_start2, $deletion_length, $deletion_length_tmp;
                                                                }
                                                            }
                                                            print OUTPUT5 $deletion_length." DELETION_LENGTH\n";
                                                            print OUTPUT5 $deletion_length_tmp." DELETION_LENGTH2\n";
                                                            print OUTPUT5 $large_variance_length_back{$id}." DELETION_LENGTH2b\n";
                                                            
                                                            $deletion_tmp = reverse($deleted_part);
                                                            $last_nuc = substr $hashref2{$large_variance_back{$id}-1}, 0, 1;
                                                            $deletion_length0 = $deletion_length;
                                                            
                                                            if ($large_variance_length_back{$id} > $deletion_length_tmp)
                                                            {
                                                                if ($one_or_two eq "two")
                                                                {
                                                                    $loc_in_ref -= 1;
                                                                }
                                                                $one_or_two = "one";
                                                            }
                                                            elsif ($large_variance_length_back{$id} < $deletion_length_tmp)
                                                            {
                                                                $one_or_two = "two";
                                                            }
                                                            print OUTPUT5 $deleted_part." LARGE_INSERTION_BACK\n";
                                                        }
                                                        elsif (exists($large_variance_back{$id}) && $first_without_LV_back eq "")
                                                        {
                                                            goto NO_LARGE_VARIANCE_BACK;
                                                        }
                                                        my $tmp = '0';
                                                        my $check_rep = substr $hashref2{$loc_in_ref}.$hashref2{$loc_in_ref+30}, -$tmp, length($deletion_tmp);
                                                
                                                        while ($check_rep eq $deletion_tmp && $deletion_tmp ne "" && $check_rep ne "")
                                                        { 
                                                            $tmp++;
                                                            $check_rep = substr $hashref2{$loc_in_ref}.$hashref2{$loc_in_ref+30}, -$tmp, length($deletion_tmp);
                                                        }
                                                        if ($tmp ne '0')
                                                        {
                                                            $tmp += length($deletion_tmp);
                                                        }

                                                        my $pos_tmp = $loc_in_ref-1;
                                                        my $last_nucb = $last_nuc;
                                                        my $tmpie = $loc_in_ref-$tmp-1;
                                                        if ($hp_seed_assemble eq "")
                                                        {
                                                            if (exists($variance_all{$pos_tmp}) && $hp_back eq "")
                                                            {
                                                                if ($variance_all{$pos_tmp} =~ m/^\S*\s\S*\s\S*\s(\S*)\s(\S*)\s.*/)
                                                                {
                                                                    $last_nuc = $1;
                                                                    $last_nucb = $2;
                                                                }
                                                                $variance_all{$pos_tmp."b"} = $variance_all{$pos_tmp};
                                                                delete $variance_all{$pos_tmp};
                                                            }
                                                            elsif (exists($variance_all{$pos_tmp}) && $hp_back ne "")
                                                            {
                                                            }
                                                            elsif ($deletion_back eq "")
                                                            {
                                                                if ($split eq "" && $heteroplasmy ne "")
                                                                {
                                                                }
                                                                elsif ($one_or_two eq "one")
                                                                {
                                                                    $variance_all{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc."\t".$last_nucb.reverse($deletion_tmp)."\t.\t.\t.";
                                                                    $variance_no_hp{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc."\t".$last_nucb.reverse($deletion_tmp)."\t.\t.\t.";                                                                 
                                                                    $variance_indels{$pos_tmp} = undef;
                                                                    if ($deletion_back eq "")
                                                                    {
                                                                        $variance_back{$id."*".$tmpie} = length($deletion_tmp);
                                                                    }
                                                                }
                                                                elsif($one_or_two eq "two")
                                                                {
                                                                    $variance_all{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc.reverse($deletion_tmp)."\t".$last_nucb."\t.\t.\t.";
                                                                    $variance_no_hp{$pos_tmp} = $chromosome."\t".$pos_tmp."\t".".\t".$last_nuc.reverse($deletion_tmp)."\t".$last_nucb."\t.\t.\t.";                                                                                                                              
                                                                    $variance_indels{$pos_tmp} = undef;
                                                                    if ($deletion_back eq "")
                                                                    {
                                                                        $variance_back{$id."*".$tmpie} = -length($deletion_tmp);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        elsif ($deletion_back eq "")
                                                        {
                                                            my $pos_SNPs = $position_back-1;
                                                            my $first_nuc = substr $best_extension, 0, 1;
                                                            my $second_nuc = substr $best_extension, 1, 1;
                                                            print OUTPUT5 $prev_loc1." VAR_DEL_HP_BACK\n";
                                                            if ($one_or_two eq "one")
                                                            {
                                                                $variance_back{$id."*".$tmpie} = length($deletion_tmp);
                                                            }
                                                            elsif($one_or_two eq "two")
                                                            {
                                                                $variance_back{$id."*".$tmpie} = -length($deletion_tmp);
                                                            }
                                                        }
                                                        my $check_dot = $after_deletion =~ tr/\./\./;
                                                        if ($shorter > 0)
                                                        {
                                                            substr $best_extension, -$shorter, $shorter, "";
                                                            print OUTPUT5 $best_extension." BEST_EXTENSION_SHORTER_BACK\n";
                                                        }
                                                        
                                                        my $deletion_length0_tmp = $deletion_length0;
                                                        if($one_or_two eq "one")
                                                        {
                                                            $deletion_length0_tmp = -$deletion_length0;
                                                        }
                                                        print OUTPUT5 $deletion_length0." DEL_LENGTH0_BACK\n";
                                                        my $length = length($best_extension)+$deletion_length0_tmp;
                                                        my $extra_seq = substr $ref_check_back, 0, $length;
                                                        print OUTPUT5 $extra_seq." EXTRA_SEQ\n";
                                                        $last_ref_seq_back{$id} = reverse($extra_seq).$last_seq_ref;
                                                        if (exists($last_ref_pos_back{$id}))
                                                        {
                                                            $last_ref_pos_back{$id} = $last_ref_pos_back{$id}-length($extra_seq);
                                                        }
                                                        
                                                        $save_seq_ref_back = "no2";
                                                        
                                                        if ($deletion_length0 < $large_variance_length_back{$id} && exists($large_variance_back{$id}))
                                                        {
                                                            if ($one_or_two eq "one")
                                                            {
                                                                $best_extension_tmp = substr $read_short_start2, 0, $large_variance_length_back{$id}-$deletion_length0;
                                                                $best_extension_tmp = reverse($best_extension_tmp).$best_extension;
                                                                $prev_loc1 = $prev_loc1-($prev_loc1-$large_variance_back{$id});
                                                            }
                                                            elsif($one_or_two eq "two")
                                                            {
                                                                $ref_check_tmp = substr $ref_check, length($deletion_tmp);
                                                                $prev_loc1_tmp_correction = -length($deletion_tmp);
                                                            }
                                                            $deletion_found = "yes";
                                                            delete $large_variance_back{$id};
                                                            delete $large_variance_length_back{$id}; 
                                                            goto VAR_START_BACK;
                                                        }
                                                        
                                                        delete $large_variance_back{$id};
                                                        delete $large_variance_length_back{$id};
                                                        
                                                        if ($check_dot > 0)
                                                        {
                                                            if ($one_or_two eq "one")
                                                            {
                                                                $best_extension_tmp = substr $best_extension, length($deletion_tmp);
                                                            }
                                                            elsif($one_or_two eq "two")
                                                            {
                                                                $ref_check_tmp = substr reverse($ref_check), length($deletion_tmp);
                                                            }
                                                            $deletion_found = "yes";
                                                            goto VAR_START_BACK;
                                                        }
                                                    }
                                                    if ($var_deletion ne "")
                                                    {
                                                        last VAR_CHECK_BACK;
                                                    }
                                                    elsif ($max_SNP eq '1')
                                                    {
                                                        $max_SNP = length($best_extension)/5;
                                                        if ($max_SNP < 3)
                                                        {
                                                            $max_SNP = 3;
                                                        }
                                                        if (length($best_extension) > 15 && $max_SNP < 6)
                                                        {
                                                            $max_SNP = 6;
                                                        }
                                                        if (length($best_extension) > 25 && $max_SNP < 7)
                                                        {
                                                            $max_SNP = 7;
                                                        }
                                                        undef @pos;
                                                        goto VAR_START_BACK;
                                                    }
                                                    elsif ($split eq "" && $deletion_back eq "")
                                                    {             
                                                        if (exists($large_variance_back{$id}))
                                                        {
                                                            if ($first_without_LV_back eq "" && $var_recorderd eq '0')
                                                            {
                                                                $first_without_LV_back = "yes";
                                                                goto WITHOUT_LV_BACK;
                                                            }
                                                            elsif ($first_without_LV_back eq "yes" && $var_recorderd eq '0')
                                                            {
                                                                $first_without_LV_back = "yes2";
                                                                goto REFERENCE_BACK;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            print OUTPUT5 $prev_loc1-$gh." LARGE_VARIANCE_BACK\n";
                                                            $first_without_LV_back = "no";
                                                            $large_variance_tmp_back = "yes";
                                                            $save_seq_ref_back = "";
                                                            $large_variance_back{$id} = $prev_loc1;
                                                            delete $no_large_variance_back{$id};                                            
                                                        }
                                                        last VAR_CHECK_BACK;
                                                    }
                                                }
                                                elsif (exists($large_variance_back{$id}) && $first_without_LV_back eq "" && $var_recorderd eq '0')
                                                {
                                                    $first_without_LV_back = "yes";
                                                    goto WITHOUT_LV_BACK;    
                                                }
                                                elsif (exists($large_variance_back{$id}) && $first_without_LV_back eq "yes" && $var_recorderd eq '0')
                                                {
                                                    $first_without_LV_back = "yes2";
                                                    goto REFERENCE_BACK;
                                                } 
                                                else
                                                {
                                                    $gh++;
                                                    last VAR_CHECK_BACK;
                                                }
                                                $d++    
                                            }
                                            last VAR_CHECK_BACK;
                                        }
                                        
                                        if (exists($large_variance_back{$id}) && $first_without_LV_back eq "" && length($best_extension) > 5)
                                        {
                                            substr $read, 0,  ($large_variance_back{$id}-$prev_loc1_tmp), "";
                                            $position_back -= ($large_variance_back{$id}-$prev_loc1_tmp);
                                            $best_extension = "";
                                            delete $large_variance_back{$id};
                                            $no_large_variance_back{$id} = $prev_loc1_tmp;
                                            $position_back{$id} = $position_back;
                                        }
NO_LARGE_VARIANCE_BACK:
                                        if (exists($large_variance_back{$id}) && $first_without_LV_back eq "" && length($best_extension) > 9)
                                        {
                                            substr $read, 0, ($large_variance_back{$id}-$prev_loc1_tmp),"";
                                            $position_back -= ($large_variance_back{$id}-$prev_loc1_tmp);
                                            $no_large_variance_back{$id} = $prev_loc1_tmp;
                                            $position_back{$id} = $position_back;
                                            $best_extension = substr $read, 0,($large_variance_back{$id}-$prev_loc1_tmp);
                                            
                                            my $new_last_seq_ref;
                                            my $cc = $prev_loc1_tmp;
                                            while ($cc <= $large_variance_back{$id}-30)
                                            {
                                                $new_last_seq_ref .= $hashref2{$cc};
                                                $cc += 30;
                                            }
                                            my $last_bit = substr $hashref2{$cc}, 0, $large_variance_back{$id}-$cc;
                                            $new_last_seq_ref .= $last_bit;
                                            $last_ref_seq_back{$id} = $new_last_seq_ref;
                                            if (exists($last_ref_pos_back{$id}))
                                            {
                                                $last_ref_pos_back{$id} = $last_ref_pos_back{$id}-length($last_bit);
                                            }
                                            
                                            $no_large_variance_back = "yes";
                                            print OUTPUT5 $new_last_seq_ref." NEW_LAST_SEQ_REF\n";
                                            print OUTPUT5 $best_extension." NEW_BEST_EXT\n";
                                            delete $large_variance_back{$id};
                                            delete $large_variance_length_back{$id};
                                            $best_extension_tmp = $best_extension;
                                            $ref_check_tmp = $new_last_seq_ref;
                                            $max_SNP = length($best_extension_tmp);
                                            $no_large_variance_back = $prev_loc1_tmp;
                                            $large_variance_tmp_back = "";
                                            $save_seq_ref_back = "no2";
                                            goto VAR_START_BACK;
                                        }
                                        if ($save_seq_ref_back eq "" && $split eq "")
                                        {
                                            $last_ref_seq_back{$id} = $last_seq_ref;
                                        }
                                        if ($deletion_back eq "yes" && $del_detect eq '1')
                                        {
                                            $del_detect = '2';
                                            goto DEL_DETECT_BACK;
                                        }
                                        if ($deletion_back eq "yes")
                                        {
                                            $best_extension = $best_extension_del;
                                            
                                            foreach my $not_linked (keys %not_linked_SNPs)
                                            {
                                                if (exists($linked_SNPs{$not_linked}))
                                                {
                                                    delete $not_linked_SNPs{$not_linked};
                                                    delete $linked_SNPs{$not_linked};
                                                    my $pos_SNPs = -($position_back+$prev_loc1-$not_linked+1);
                                                    $linked_half_SNPs{$not_linked} = $pos_SNPs;
                                                }
                                            }
                                        }
                                        $best_extension_back_prev{$id} = $best_extension;
                                        goto AFTER_EXT_BACK;
                                    }
REF_GUIDED_BACK:
                                    my $star_check_start = $read_start =~ tr/\*/\*/;
                                    if ($hp_seed_assemble eq "" && ($before_back ne "" || $star_check_start > 0))
                                    {
                                        print OUTPUT5 "FOLLOW_REF_BACK\n";
                                        
                                        my $best_extension1_tmp;
                                        my $best_extension2_tmp;
                                        my $best_extension3_tmp;
                                        my $best_extension4_tmp;
                                        if (length($best_extension_old1) > length($best_extension1))
                                        {
                                            $best_extension1_tmp = $best_extension_old1;
                                        }
                                        else
                                        {
                                            $best_extension1_tmp = $best_extension1;
                                        }
                                        if (length($best_extension_old2) > length($best_extension2))
                                        {
                                            $best_extension2_tmp = $best_extension_old2;
                                        }
                                        else
                                        {
                                            $best_extension2_tmp = $best_extension2;
                                        }
                                        if (length($best_extension_old3) > length($best_extension3))
                                        {
                                            $best_extension3_tmp = $best_extension_old3;
                                        }
                                        else
                                        {
                                            $best_extension3_tmp = $best_extension3;
                                        }
                                        if (length($best_extension_old4) > length($best_extension4))
                                        {
                                            $best_extension4_tmp = $best_extension_old4;
                                        }
                                        else
                                        {
                                            $best_extension4_tmp = $best_extension4;
                                        }
                                        
                                        my $best_extension1_part = substr $best_extension1_tmp, 0, 25;
                                        my $best_extension2_part = substr $best_extension2_tmp, 0, 25;
                                        my $best_extension3_part = substr $best_extension3_tmp, 0, 25;
                                        my $best_extension4_part = substr $best_extension4_tmp, 0, 25;
                                        my $best_extension1_partb = substr $best_extension1_tmp, 5, 25;
                                        my $best_extension2_partb = substr $best_extension2_tmp, 5, 25;
                                        my $best_extension3_partb = substr $best_extension3_tmp, 5, 25;
                                        my $best_extension4_partb = substr $best_extension4_tmp, 5, 25;
                                        
                                        my $reference_guided1 = '0';
                                        my $reference_guided2 = '0';
                                        my $reference_guided3 = '0';
                                        my $reference_guided4 = '0';
                                    
                                        if (length($best_extension1_part) > 8)
                                        {
                                            my $ref_check_tmp = reverse($ref_check);
                                            my $best_extension1_part_tmp = $best_extension1_part;
                                            my $steps = '0';
                                            my $cut_ext = '0';
EXT1_PART0_BACK:                            $best_extension1_part_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                            my @best_extension = split //,$best_extension1_part_tmp;
                                            my @ref_check = split //, $ref_check_tmp;
                                            my $gh = '0';
                                            my $th = '0';
    
EXT1_PART_BACK:                             while ($gh < length($ref_check_tmp)-length($best_extension1_part_tmp))
                                            {
                                                my $d = '0';
                                                my $next = '0';
                                                
                                                while ($d < length($best_extension1_part_tmp))
                                                {
                                                    $th = $d + $gh;
                                                    if ($best_extension[$d] eq $ref_check[$th])
                                                    {
                                                    }
                                                    elsif ($ref_check[$th] eq ".")
                                                    {
                                                    }
                                                    elsif ($best_extension[$d] eq ".")
                                                    {
                                                    }
                                                    elsif ($next < length($best_extension1_part_tmp)*0.25)
                                                    {
                                                        $next++;
                                                    }
                                                    else
                                                    {
                                                        $gh++;
                                                        goto EXT1_PART_BACK;
                                                    }
                                                    $d++    
                                                }
                                                
                                                $reference_guided1 += $next+($gh/2)+1+$cut_ext;
                                                
                                                if ($reference_guided1 < 25)
                                                {
                                                    $reference_guided_back = "yes1";
                                                    print OUTPUT5 $reference_guided1." REFERENCE_GUIDED1\n";
                                                    print OUTPUT5 $best_extension1_part_tmp." BEST_EXTENSION1\n\n";
                                                    $best_extension = $best_extension1_tmp;
                                                    last EXT1_PART_BACK;
                                                }
                                                else
                                                {
                                                    $reference_guided1 = '0';
                                                    $gh++;
                                                    goto EXT1_PART_BACK;
                                                }
                                            }
                                            if ($reference_guided_back eq "" && $star2 > 0 && ($steps < 1 || ($steps < 2 && $best_extension1_part_tmp eq $best_extension1_partb)))
                                            {
                                                $ref_check_tmp = reverse($ref_check_star);
                                                $steps++;
                                                goto EXT1_PART0_BACK;
                                            }
                                            if ($reference_guided_back eq "" && $cut_ext < 5 && length($best_extension1_tmp)-$cut_ext > 10)
                                            {
                                                $ref_check_tmp = reverse($ref_check);
                                                $cut_ext++;
                                                $best_extension1_part_tmp = substr $best_extension1_tmp, $cut_ext, 25;
                                                if ($cut_ext eq 5)
                                                {
                                                    $steps += 2;
                                                    if ($star2 > 0)
                                                    {
                                                        $steps--;
                                                    }
                                                }
                                                goto EXT1_PART0_BACK;
                                            }
                                        }
                                        my $ref_check_tmp0 = reverse($ref_check);
                                        my $ref_check_tmp20 = reverse($ref_check_star);
                                        my $ref_check_tmp = substr $ref_check_tmp0, 0, 40;
                                        my $ref_check_tmp2 = substr $ref_check_tmp0, 0, 40;
                                        
                                        if ($reference_guided_back ne "yes1")
                                        {
EXT1_PART_single_BACK:                      foreach my $extensions_group1_id (%extensionsb_group1_old)
                                            {
                                                my $extensions_group1 = $extensionsb_group1_old{$extensions_group1_id};
                                                if (length($extensions_group1) > 15)
                                                {
                                                    my $best_extension1_tmp_6 = substr $best_extension1_tmp, 0, 6;
                                                    if ($extensions_group1 =~ s/$best_extension1_tmp_6/$best_extension1_tmp_6/)
                                                    {
                                                        my $extensions_group1_part = substr $extensions_group1, 0, 25;
                                                        my @ref1_single = build_partialb_4dots $extensions_group1_part;
                                                        foreach my $best_extension1_part2_single (@ref1_single)
                                                        {                                                                                  
                                                            if ($ref_check_tmp =~ s/$best_extension1_part2_single/$best_extension1_part2_single/ || $ref_check_tmp2 =~ s/$best_extension1_part2_single/$best_extension1_part2_single/)
                                                            {    
                                                                print OUTPUT5 "REFERENCE_GUIDED1b\n";
                                                                print OUTPUT5 $extensions_group1." BEST_EXTENSION1_single\n\n";
                                                                $best_extension = $best_extension1_tmp;
                                                                $reference_guided_back = "yes1";
                                                                last EXT1_PART_single_BACK;
                                                            }
                                                        }
                                                        undef @ref1_single;
                                                    }
                                                }
                                            }
                                        }
                                        if (length($best_extension2_part) > 8)
                                        {
                                            my $ref_check_tmp = reverse($ref_check);
                                            my $best_extension2_part_tmp = $best_extension2_part;
                                            my $steps = '0';
                                            my $cut_ext = '0';
EXT2_PART0_BACK:                            $best_extension2_part_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                            my @best_extension = split //,$best_extension2_part_tmp;
                                            my @ref_check = split //, $ref_check_tmp;
                                            my $gh = '0';
                                            my $th = '0';
    
EXT2_PART_BACK:                             while ($gh < length($ref_check_tmp)-length($best_extension2_part_tmp))
                                            {
                                                my $d = '0';
                                                my $next = '0';
                                                
                                                while ($d < length($best_extension2_part_tmp))
                                                {
                                                    $th = $d + $gh;
                                                    if ($best_extension[$d] eq $ref_check[$th])
                                                    {
                                                    }
                                                    elsif ($ref_check[$th] eq ".")
                                                    {
                                                    }
                                                    elsif ($best_extension[$d] eq ".")
                                                    {
                                                    }
                                                    elsif ($next < length($best_extension2_part_tmp)*0.25)
                                                    {
                                                        $next++;
                                                    }
                                                    else
                                                    {
                                                        $gh++;
                                                        goto EXT2_PART_BACK;
                                                    }
                                                    $d++    
                                                }
                                                $reference_guided2 += $next+($gh/2)+1+$cut_ext;
                                                
                                                if ($reference_guided2 > 24)
                                                {
                                                    $reference_guided2 = '0';
                                                    $gh++;
                                                    goto EXT2_PART_BACK; 
                                                }
                                                
                                                if ($reference_guided_back ne "" && $reference_guided2 > 7*$reference_guided1)
                                                {
                                                    last EXT2_PART_BACK;
                                                }
                                                elsif ($reference_guided_back ne "" && $reference_guided1 > 7*$reference_guided2)
                                                {
                                                    $reference_guided_back = "";
                                                }
                                                if ($reference_guided_back eq "")
                                                {
                                                    $reference_guided_back = "yes2";
                                                }
                                                else
                                                {
                                                    $reference_guided_back = "yes_both";
                                                }
                                                
                                                print OUTPUT5 $reference_guided2." REFERENCE_GUIDED2\n";
                                                print OUTPUT5 $best_extension2_part_tmp." BEST_EXTENSION2\n\n";
                                                $best_extension = $best_extension2_tmp;
                                                last EXT2_PART_BACK;
                                            }
                                            if ($reference_guided2 eq 0 && $star2 > 0 && ($steps < 1 || ($steps < 2 && $best_extension2_part_tmp eq $best_extension2_partb)))
                                            {
                                                $ref_check_tmp = reverse($ref_check_star);
                                                $steps++;
                                                goto EXT2_PART0_BACK;
                                            }
                                            if ($reference_guided2 eq 0 && $cut_ext < 5 && length($best_extension2_tmp)-$cut_ext > 10)
                                            {
                                                $ref_check_tmp = reverse($ref_check);
                                                $cut_ext++;
                                                $best_extension2_part_tmp = substr $best_extension2_tmp, $cut_ext, 25;
                                                if ($cut_ext eq 5)
                                                {
                                                    $steps += 2;
                                                    if ($star2 > 0)
                                                    {
                                                        $steps--;
                                                    }
                                                }
                                                goto EXT2_PART0_BACK;
                                            }
                                        }
                                        if ($reference_guided_back ne "yes2" && $reference_guided_back ne "yes_both")
                                        {
EXT2_PART_single_BACK:                      foreach my $extensions_group2_id (%extensionsb_group2_old)
                                            {
                                                my $extensions_group2 = $extensionsb_group2_old{$extensions_group2_id};
                                                if (length($extensions_group2) > 15)
                                                {
                                                    my $best_extension2_tmp_6 = substr $best_extension2_tmp, 0, 6;
                                                    if ($extensions_group2 =~ s/$best_extension2_tmp_6/$best_extension2_tmp_6/)
                                                    {
                                                        my $extensions_group2_part = substr $extensions_group2, 0, 25;
                                                        my @ref2_single = build_partialb_4dots $extensions_group2_part;
                                                        foreach my $best_extension2_part2_single (@ref2_single)
                                                        {                                    
                                                            if ($ref_check_tmp =~ s/$best_extension2_part2_single/$best_extension2_part2_single/ || $ref_check_tmp2 =~ s/$best_extension2_part2_single/$best_extension2_part2_single/)
                                                            {   
                                                                if ($reference_guided_back eq "")
                                                                {
                                                                    $reference_guided_back = "yes2";
                                                                }
                                                                else
                                                                {
                                                                    $reference_guided_back = "yes_both";
                                                                }
                                                                print OUTPUT5 "REFERENCE_GUIDED2c\n";
                                                                print OUTPUT5 $extensions_group2." BEST_EXTENSION2_single\n\n";
                                                                $best_extension = $best_extension2_tmp;
                                                                last EXT2_PART_single_BACK;
                                                            }
                                                        }
                                                        undef @ref2_single;
                                                    }
                                                }
                                            }
                                        }
 
                                        if ($count_split > 2 && $reference_guided_back ne "yes_both")
                                        {
                                            if (length($best_extension3_part) > 12)
                                            {
                                                my @ref3 = build_partialb_4dots $best_extension3_part;
EXT3_PART_BACK:                                 foreach my $best_extension3_part2 (@ref3)
                                                {                                    
                                                    if ($ref_check_tmp =~ s/$best_extension3_part2/$best_extension3_part2/ || $ref_check_tmp2 =~ s/$best_extension3_part2/$best_extension3_part2/)
                                                    {  
                                                        if ($reference_guided_back eq "")
                                                        {
                                                            $reference_guided_back = "yes3";
                                                        }
                                                        else
                                                        {
                                                            $reference_guided_back = "yes_both";
                                                        }
                                                        print OUTPUT5 "REFERENCE_GUIDED3\n";
                                                        print OUTPUT5 $best_extension3_part2." BEST_EXTENSION3\n\n";
                                                        $best_extension = $best_extension3_tmp;
                                                        last EXT3_PART_BACK;
                                                    }
                                                }
                                                undef @ref3;
                                            }
                                            if ($reference_guided_back ne "yes3" && $reference_guided_back ne "yes_both")
                                            {
EXT3_PART_single_BACK:                          foreach my $extensions_group3_id (%extensionsb_group3_old)
                                                {
                                                    my $extensions_group3 = $extensionsb_group3_old{$extensions_group3_id};
                                                    if (length($extensions_group3) > 15)
                                                    {
                                                        my $extensions_group3_part = substr $extensions_group3, 0, 25;
                                                        my @ref3_single = build_partialb_4dots $extensions_group3_part;
                                                        foreach my $best_extension3_part2_single (@ref3_single)
                                                        {                                    
                                                            if ($ref_check_tmp =~ s/$best_extension3_part2_single/$best_extension3_part2_single/ || $ref_check_tmp2 =~ s/$best_extension3_part2_single/$best_extension3_part2_single/)
                                                            {    
                                                                if ($reference_guided_back eq "")
                                                                {
                                                                    $reference_guided_back = "yes3";
                                                                }
                                                                else
                                                                {
                                                                    $reference_guided_back = "yes_both";
                                                                }
                                                                print OUTPUT5 "REFERENCE_GUIDED3_single\n";
                                                                print OUTPUT5 $best_extension3_tmp." BEST_EXTENSION3_single\n\n";
                                                                $best_extension = $best_extension3_tmp;
                                                                last EXT3_PART_single_BACK;
                                                            }
                                                        }
                                                        undef @ref3_single;
                                                    }
                                                }
                                            }
                                            if ($reference_guided_back ne "yes3" && $reference_guided_back ne "yes_both" && length($best_extension3_partb) > 13)
                                            {
                                                my @ref3b = build_partialb_4dots $best_extension3_partb;
EXT3_PARTB_BACK:                                foreach my $best_extension3_part2b (@ref3b)
                                                {                                    
                                                    if ($ref_check_tmp =~ s/$best_extension3_part2b/$best_extension3_part2b/ || $ref_check_tmp2 =~ s/$best_extension3_part2b/$best_extension3_part2b/)
                                                    {  
                                                        if ($reference_guided_back eq "")
                                                        {
                                                            $reference_guided_back = "yes3";
                                                        }
                                                        else
                                                        {
                                                            $reference_guided_back = "yes_both";
                                                        }
                                                        print OUTPUT5 "REFERENCE_GUIDED3c\n";
                                                        print OUTPUT5 $best_extension3_tmp." BEST_EXTENSION3\n\n";
                                                        $best_extension = $best_extension3_tmp;
                                                        last EXT3_PARTB_BACK;
                                                    }
                                                }
                                                undef @ref3b;
                                            }
                                        }
                                        if ($count_split > 3 && $reference_guided_back ne "yes_both")
                                        {
                                            if (length($best_extension4_part) > 12)
                                            {
                                                my @ref4 = build_partialb_4dots $best_extension4_part;
EXT4_PART_BACK:                                 foreach my $best_extension4_part2 (@ref4)
                                                {                                    
                                                    if ($ref_check_tmp =~ s/$best_extension4_part2/$best_extension4_part2/ || $ref_check_tmp2 =~ s/$best_extension4_part2/$best_extension4_part2/)
                                                    {    
                                                        if ($reference_guided_back eq "")
                                                        {
                                                            $reference_guided_back = "yes4";
                                                        }
                                                        else
                                                        {
                                                            $reference_guided_back = "yes_both";
                                                        }
                                                        print OUTPUT5 "REFERENCE_GUIDED\n";
                                                        print OUTPUT5 $best_extension4_tmp." BEST_EXTENSION4\n\n";
                                                        $best_extension = $best_extension4_tmp;
                                                        last EXT4_PART_BACK;
                                                    }
                                                }
                                                undef @ref4;
                                            }
                                            if ($reference_guided_back ne "yes4" && $reference_guided_back ne "yes_both")
                                            {
EXT4_PART_single_BACK:                          foreach my $extensions_group4_id (%extensionsb_group4_old)
                                                {
                                                    my $extensions_group4 = $extensionsb_group4_old{$extensions_group4_id};
                                                    if (length($extensions_group4) > 15)
                                                    {
                                                        my $extensions_group4_part = substr $extensions_group4, 0, 25;
                                                        my @ref4_single = build_partialb_4dots $extensions_group4_part;
                                                        foreach my $best_extension4_part2_single (@ref4_single)
                                                        {                                    
                                                            if ($ref_check_tmp =~ s/$best_extension4_part2_single/$best_extension4_part2_single/ || $ref_check_tmp2 =~ s/$best_extension4_part2_single/$best_extension4_part2_single/)
                                                            {   
                                                                if ($reference_guided_back eq "")
                                                                {
                                                                    $reference_guided_back = "yes4";
                                                                }
                                                                else
                                                                {
                                                                    $reference_guided_back = "yes_both";
                                                                }
                                                                print OUTPUT5 "REFERENCE_GUIDED\n";
                                                                print OUTPUT5 $best_extension4_tmp." BEST_EXTENSION4_single\n\n";
                                                                $best_extension = $best_extension4_tmp;
                                                                last EXT4_PART_single_BACK;
                                                            }
                                                        }
                                                        undef @ref4_single;
                                                    }
                                                }
                                            }
                                            if ($reference_guided_back ne "yes4" && $reference_guided_back ne "yes_both" && length($best_extension4_partb) > 13)
                                            {
                                                my @ref4b = build_partialb_4dots $best_extension4_partb;
EXT4_PARTB_BACK:                                foreach my $best_extension4_part2b (@ref4b)
                                                {                                    
                                                    if ($ref_check_tmp =~ s/$best_extension4_part2b/$best_extension4_part2b/ || $ref_check_tmp2 =~ s/$best_extension4_part2b/$best_extension4_part2b/)
                                                    {   
                                                        if ($reference_guided_back eq "")
                                                        {
                                                            $reference_guided_back = "yes4";
                                                        }
                                                        else
                                                        {
                                                            $reference_guided_back = "yes_both";
                                                        }
                                                        print OUTPUT5 "REFERENCE_GUIDED\n";
                                                        print OUTPUT5 $best_extension4_tmp." BEST_EXTENSION4\n\n";
                                                        $best_extension = $best_extension4_tmp;
                                                        last EXT4_PARTB_BACK;
                                                    }
                                                }
                                                undef @ref4b;
                                            }
                                        }
                                        if ($reference_guided_back eq "yes_both")
                                            {
                                                $best_extension = "";
                                                $reference_guided_back = "";
                                                goto INDEL_BACK;
                                            }
                                            elsif ($reference_guided_back ne "")
                                            {
                                                if ($reference_guided_back eq "yes1")
                                                {
                                                    $best_extension2 = "";
                                                    $best_extension3 = "";
                                                    $best_extension4 = "";
                                                }
                                                elsif ($reference_guided_back eq "yes2")
                                                {
                                                    $best_extension1 = "";
                                                    $best_extension3 = "";
                                                    $best_extension4 = "";
                                                }
                                                elsif ($reference_guided_back eq "yes3")
                                                {
                                                    $best_extension1 = "";
                                                    $best_extension2 = "";
                                                    $best_extension4 = "";
                                                }
                                                elsif ($reference_guided_back eq "yes4")
                                                {
                                                    $best_extension1 = "";
                                                    $best_extension3 = "";
                                                    $best_extension2 = "";
                                                }
                                                $reference_guided_back = "yes";
                                                $split = "";
                                                goto AFTER_EXT_BACK;
                                            }
                                            else
                                            {
                                                $best_extension = "";
                                            }
                                        }
                                    }
                                }
                                last CHECK_REF_BACK;
                            }
                            elsif (length($read) > 1100 && $p > $p_prev+15)
                            {
CHECK_BACK_REF0_BACK:           $p_prev = $p;
                                my $length_forward = '1000';
                                if ($further eq "yes")
                                {
                                    $length_forward = '5000';
                                }
                                elsif ($further eq "yes2")
                                {
                                    $length_forward = '10000';
                                }
                                elsif ($further eq "yes3")
                                {
                                    $length_forward = '20000';
                                }
                                my $read_part_forward = substr $read, $length_forward+$p-150, 200;
                                my @ref_id3_new;
                                undef  @ref_id3_new;
                                my $ref_part_tmp2;
CHECK_BACK_REF_BACK:                foreach my $ref_id (@ref_id3)
                                {
                                    $ref_part_tmp2 = $ref_id3{$ref_id};
                                    if (exists($hashref2{$ref_id-$length_forward}))
                                    {
                                        my $ref_part_forward  = $hashref2{$ref_id-$length_forward};
                                        if ($y > $startprint2)
                                        {
                                            print OUTPUT5 $ref_part_forward." REF_PART_FORWARD\n";
                                        }
                                        my @ref_part_forward = build_partialb_4dots $ref_part_forward;
                                        foreach my $ref_part_forward_tmp (@ref_part_forward)
                                        {
                                            my $found = $read_part_forward =~ s/$ref_part_forward_tmp/$ref_part_forward_tmp/;
                                            if ($found > 0)
                                            {                                           
                                                push @ref_id3_new, $ref_id;
                                                next CHECK_BACK_REF_BACK;
                                            }
                                        }
                                        undef @ref_part_forward;
                                    }
                                }
                                if (@ref_id3_new eq 1)
                                {
                                    undef @ref_id3;
                                    @ref_id3 = @ref_id3_new;
                                    $found_further_back = "yes";
                                    $ref_part_prev = $ref_part_tmp2;
                                }
                                elsif ($further eq "" && length($read) > 5200+$p)
                                {
                                    $further = "yes";
                                    goto CHECK_BACK_REF0_BACK;
                                }
                                elsif ($further eq "yes" && length($read) > 10200+$p)
                                {
                                    $further = "yes2";
                                    goto CHECK_BACK_REF0_BACK;
                                }
                                elsif ($further eq "yes2" && length($read) > 20200+$p)
                                {
                                    $further = "yes3";
                                    goto CHECK_BACK_REF0_BACK;
                                }
                                else
                                {
                                    undef @ref_id3;
                                }
                            } 
                        $p++;
                    }
                    if (($variance_detection eq "yes" || $heteroplasmy ne "") && $split eq "" && $repetitive_detect_back eq "")
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 reverse($best_extension)." BEST_EXTENSION_BACK2\n\n";
                        }
                        $best_extension_back_prev{$id} = $best_extension;
                        goto AFTER_EXT_BACK;
                    }
                }
INDEL_BACK:     
                $split_forward        = "yes";
                my $star_check_start = $read_start =~ tr/\*/\*/;
                
                if ($jump_rep_back eq "yes" || ($extensions_before ne "yes" && ($delete_first eq "" || $delete_second eq "" || $delete_third eq "") && $before_back ne "yes"
                    && $reference_guided_back ne "yes" && $SNR_critical_back eq "" && ($heteroplasmy eq "" || $hp_seed_assemble ne "" || $SNP_active_back ne "")) && $star_check_start eq '0')
                {                   
                    my $before_shorter = "";
                    my $count_one = '0';
                    my $count_two = '0';
                    my $count_three = '0';
                    my $count_four = '0';
                    
                    my $max_overhang_hp = '0';
                    if ($hp_seed_assemble ne "")
                    {
                        foreach my $SNP_tmp (keys %SNPs)
                        {
                            if ($SNP_tmp > -$position_back && ($read_length-($position_back-(-$SNP_tmp))-1) > $max_overhang_hp)
                            {
                                $max_overhang_hp = $read_length-($position_back-(-$SNP_tmp))-1
                            }
                        }
                    }
                    my $overhangb = ($read_length/$ext_total_back)*8;
                    if ($overhangb < 1+($read_length/40))
                    {
                        $overhangb = 1+($read_length/40);
                    }
                    if ($overhangb > 1+($read_length/1.5))
                    {
                        $overhangb = 1+($read_length/1.5);
                    }
                    if ($type eq "mito_plant" && $hp_seed_assemble eq "")
                    {
                        $overhangb += 2;
                        if ($ext_total_back > $average_coverage_ext*2)
                        {
                            $overhangb += 4;
                        }
                    }
                    my $overhang = sprintf("%.0f", $overhangb);
                    my $overhang_for_pairs = $overhang;
                    if ($overhang_for_pairs > 35 && $average_coverage_ext > 20)
                    {
                        $overhang = 35;
                    }
                    if ($overhang_for_pairs > 20 && $average_coverage_ext > 65)
                    {
                        $overhang = 20;
                    }
                    delete $jump_rep_back{$id};
BEFORE_BACK:
                    my $s = '0';
                    
                    if ($before_shorter eq "yes")
                    {
                        $overhang += 5;
                    }
                    $before_shorter = "";
                   
                    print OUTPUT5 $overhang." OVERHANG_BACK\n";
                    my %extensions_yuyu;
                    my %before1F;
                    my %before2F;
                    my %before3F;
                    my %before4F;
                    my %before1B;
                    my %before2B;
                    my %before3B;
                    my %before4B;
                    my %filter_before1;
                    my %filter_before2;
                    my %filter_before3;
                    my %filter_before4;
                    undef %extensions_yuyu;
                    undef %before1F;
                    undef %before2F;
                    undef %before3F;
                    undef %before4F;
                    undef %before1B;
                    undef %before2B;
                    undef %before3B;
                    undef %before4B;
                    undef %filter_before1;
                    undef %filter_before2;
                    undef %filter_before3;
                    undef %filter_before4;
                    
                    my $skip_overhang = "";
                    if ($AT_rich_before_back eq "yes")
                    {
                        my $before_split_tmp = substr $read_short_start2, 0, $read_length-$overhang;
                        $skip_overhang = AT_rich_test ($before_split_tmp, '3');
                        if ($skip_overhang eq "yes")
                        {
                            print OUTPUT5 $skip_overhang." SKIP OVERHANG BACK\n";
                            $overhang -= 5;
                        }
                    }
                    my $first_nuc1 = substr $best_extension1, 0, 1;
                    my $first_nuc2 = substr $best_extension2, 0, 1;
                    my $first_nuc3 = substr $best_extension3, 0, 1;
                    my $first_nuc4 = substr $best_extension4, 0, 1;

                    foreach my $id_tmp (keys %extensions_for_before)
                    {        
                        if (length($extensions_for_before{$id_tmp}) <= $overhang)
                        {
                            my $extensions_for_before2 = $extensions_for_before_match{$id_tmp};
                            if ($use_quality ne "")
                            {
                                if (exists($merged_match_back1{$id_tmp}))
                                {
                                    $extensions_for_before2 =~ tr/1234/ACTG/;
                                }
                                elsif (exists($merged_match_back2{$id_tmp}))
                                {
                                    $extensions_for_before2 =~ tr/1234ACTG/TGACTGAC/;
                                }
                            }
                            elsif (exists($merged_match_back2{$id_tmp}))
                            {
                                $extensions_for_before2 =~ tr/ACTG/TGAC/;
                            }
                            substr $extensions_for_before2, 0, length($extensions_for_before{$id_tmp}),"";
                            
                            my $first_nuc = substr $extensions_for_before{$id_tmp}, 0, 1;
                            if ($first_nuc eq $first_nuc1 && $first_nuc ne "")
                            {
                                $before1B{$id_tmp} = $extensions_for_before2;
                                $extensions_yuyu{$id_tmp} = $extensions_for_before{$id_tmp};
                            }
                            elsif ($first_nuc eq $first_nuc2 && $first_nuc ne "")
                            {
                                $before2B{$id_tmp} = $extensions_for_before2;
                                $extensions_yuyu{$id_tmp} = $extensions_for_before{$id_tmp}
                            }
                            elsif ($first_nuc eq $first_nuc3 && $count_split > 2 && $first_nuc ne "")
                            {
                                $before3B{$id_tmp} = $extensions_for_before2;
                                $extensions_yuyu{$id_tmp} = $extensions_for_before{$id_tmp}
                            }
                            elsif ($first_nuc eq $first_nuc4 && $count_split > 3 && $first_nuc ne "")
                            {
                                $before4B{$id_tmp} = $extensions_for_before2;
                                $extensions_yuyu{$id_tmp} = $extensions_for_before{$id_tmp}
                            }
                        }
                    }
                    if ($last_chance ne "yes")
                    { 
                        my $overhang_tmp = $overhang;
                        if ($hp_seed_assemble ne "")
                        {
                            $overhang_tmp = $max_overhang_hp;
                        }                                        
                        $s = '0';
                        my $before_split = substr $read_short_start2, $read_length-$left-1-$overhang_tmp-$overlap, $overhang_tmp+$overlap;
                        my $star0 = '0';

                        print OUTPUT5 $before_split." BEFORE_SPLIT0\n";
                        if ($containX_short_start2 > 0)
                        {
                            my $before_split2 = substr $read_short_start2, 0, $read_length-$left-1;
                            $star0 = $before_split2 =~ tr/\*/\*/;
                            if ($star0 > 0)
                            {
                                $before_split = substr $read_short_start2, $read_length-$left-1-$overhang_tmp-$overlap+$star0, $overhang_tmp+$overlap+($star0*2);
                            }
                        }
                          
                        my $star0b = $before_split =~ tr/\*/\*/;
                        while ($s <= length($before_split)-$overlap-($star0b*2))
                        {
                            my $line_tmp_reverse = substr $before_split, $s, $overlap;
                            
                            if ($star0 > 0 || $star0b > 0)
                            {
                                my $star = $line_tmp_reverse =~ tr/\*//;
                                $line_tmp_reverse = substr $before_split, $s, $overlap+($star*2);
                                my $star2 = $line_tmp_reverse =~ tr/\*//;                                                
                                while ($star2 > $star)
                                {
                                    $line_tmp_reverse = substr $before_split, $s, $overlap+($star2*2);
                                    $star = $star2;
                                    $star2 = $line_tmp_reverse =~ tr/\*//;
                                } 
                            }
                            
                            my %line_tmp = build_partial3b $line_tmp_reverse, "reverse_back";
                            foreach my $line_reverse (keys %line_tmp)
                            {
                                $line_reverse =~ tr/ACTG/TGAC/;
                                my $line = reverse($line_reverse);
                                if (exists($hash2b{$line}))
                                {                       
                                    my $search = $hash2b{$line};
                                    $search = substr $search, 1;
                                    my @search = split /,/,$search;
                                    
                                    foreach my $search (@search)
                                    {                             
                                        my $search_tmp = substr $search, 0, -1;
                                        my $search_end = substr $search, -1;
                                        if (exists($hash{$search_tmp}))
                                        {
                                            my @search_tmp = split /,/,$hash{$search_tmp};
                                            my $found;
                                            if ($search_end eq "1")
                                            {
                                                $found = $search_tmp[0];
                                            }
                                            elsif ($search_end eq "2")
                                            {
                                                $found = $search_tmp[1];
                                            }
                                            if ($use_quality ne "")
                                            {
                                                $found =~ tr/1234/ACTG/;
                                            }
                                            if ($encrypt eq "yes")
                                            {
                                                $found = decrypt $found;
                                            }
                                            my $found_new;
                                            my $first_10 = substr $found, $read_length-1-$overhang_tmp+$s-10-$star0, 10;
                                            my $first_10b = substr $found, $read_length-1-$overhang_tmp+$s-10, 10;
                                            my $first_nuc;
                                            $first_10 =~ tr/ACTG/TGAC/;
                                            $first_10b =~ tr/ACTG/TGAC/;
                                            my $first_10r = reverse($first_10);
                                            my $first_10rb = reverse($first_10b);
                                            my $first_10_read_start = substr $read_start, 0, 10;
                                            my $check_first10 = $first_10r =~ s/$first_10_read_start/$first_10_read_start/;
                                            my $check_first10b = $first_10rb =~ s/$first_10_read_start/$first_10_read_start/;
                                            if ($check_first10 > 0)
                                            {
                                                $found_new = substr $found, 0, $read_length-1-$overhang_tmp+$s-$star0,"";
                                                $first_nuc = substr $found, 0, 1;
                                            }
                                            elsif ($check_first10b > 0)
                                            {
                                                $found_new = substr $found, 0, $read_length-1-$overhang_tmp+$s,"";
                                                $first_nuc = substr $found, 0, 1;
                                            }
                                            if ($check_first10 > 0 || $check_first10b > 0)
                                            {
                                                $first_nuc =~ tr/ACTG/TGAC/;
                                                $found_new =~ tr/ACTG/TGAC/;
                                                $found =~ tr/ACTG/TGAC/;
                                                my $first_nuc1 = substr $best_extension1, 0, 1;
                                                my $first_nuc2 = substr $best_extension2, 0, 1;
                                                my $first_nuc3 = substr $best_extension3, 0, 1;
                                                my $first_nuc4 = substr $best_extension4, 0, 1;
                                                
                                                my $found_reverse = reverse($found_new);
                                                my $extension_yuyu = $found;
                                                $extensions_yuyu{$search} = $extension_yuyu;
        
                                                if ($first_nuc eq $first_nuc1 && ($check_first10 > 0 || $check_first10b > 0) && $first_nuc ne "")
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                    }
                                                    $before1B{$search} = $found_reverse;
                                                }
                                                elsif ($first_nuc eq $first_nuc2 && ($check_first10 > 0 || $check_first10b > 0) && $first_nuc ne "")
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                    }
                                                    $before2B{$search} = $found_reverse;
                                                }
                                                elsif ($first_nuc eq $first_nuc3 && ($check_first10 > 0 || $check_first10b > 0) && $first_nuc ne "")
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                    }
                                                    $before3B{$search} = $found_reverse;
                                                }
                                                elsif ($first_nuc eq $first_nuc3 && ($check_first10 > 0 || $check_first10b > 0) && $first_nuc ne "")
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                    }
                                                    $before4B{$search} = $found_reverse;
                                                }
                                                if ($save_reads ne "")
                                                {                                  
                                                    $save_reads{$search_tmp} = undef;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            $s++;
                        }
                    }
                    my %before_all1 = (%before1B, %before1F);
                    my %before_all2 = (%before2B, %before2F);
                    my %before_all3 = (%before3B, %before3F);
                    my %before_all4 = (%before4B, %before4F);
                    my @keys1 = keys %before_all1;
                    my @keys2 = keys %before_all2;
                    my @keys3 = keys %before_all3;
                    my @keys4 = keys %before_all4;
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 @keys1." COUNT_TEST1\n";
                        print OUTPUT5 @keys2." COUNT_TEST2\n";
                        print OUTPUT5 @keys3." COUNT_TEST3\n";
                        print OUTPUT5 @keys4." COUNT_TEST4\n";
                    }


                    my $start_short_tmp = substr $read_short_start2, 0, $read_length+20;
  
BEFORE_EXTRA_BACK:       
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $start_short_tmp." START_SHORT_TMP\n\n";
                    }
                    my $first_yuyu2 = '0';
                    my $second_yuyu2 = '0';
                    my $third_yuyu2 = '0';
                    my $fourth_yuyu2 = '0';
                    my $count1_pair = '0';
                    my $count2_pair = '0';
                    my $count3_pair = '0';
                    my $count4_pair = '0';
                    my @filter_dot_before1;
                    my @filter_dot_before2;
                    my @filter_dot_before3;
                    my @filter_dot_before4;
                    my @extensions_before;
                    my @extensions_before1;
                    my @extensions_before2;
                    my @extensions_before3;
                    my @extensions_before4;
                    undef @filter_dot_before1;
                    undef @filter_dot_before2;
                    undef @filter_dot_before3;
                    undef @filter_dot_before4;
                    undef @extensions_before;
                    undef @extensions_before1;
                    undef @extensions_before2;
                    undef @extensions_before3;
                    undef @extensions_before4;
                    
                    my $start_short_tmp_part = substr $start_short_tmp, 0, $read_length-$overhang-5-1; 
                    
                    foreach my $search (keys %before_all2)
                    {
                        my $overhang_tmp = $overhang;
                        my $yuyu0 = $before_all2{$search};
                        my $yuyu2 = $yuyu0;
                        if (length($yuyu2) >= $read_length-$overhang_tmp-5-1)
                        {
                            $yuyu2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                            my $yuyu2_tmp = $yuyu2;
                            my $check_yuyuy2 = $yuyu2_tmp =~ s/$start_short_tmp_part/$start_short_tmp_part/;

                            if ($check_yuyuy2 > 0)
                            {
                                my $start_short_tmp_part = substr $start_short_tmp, 0, length($yuyu2);
                                my $start_short_tmp_part2;
                                my $star = $start_short_tmp_part =~ tr/\*//;
                                my $check_yuyuy2b2 = '0';
                                if ($star > 0)
                                {
                                    $start_short_tmp_part = substr $start_short_tmp, 0, length($yuyu2)+($star*2);
                                    $start_short_tmp_part2 = substr $start_short_tmp, 0, length($yuyu2)+($star);
                                    my $yuyu2_tmp2 = $yuyu2;
                                    $check_yuyuy2b2 = $yuyu2_tmp2 =~ s/$start_short_tmp_part2/$start_short_tmp_part2/;
                                }      
                                my $yuyu2_tmp3 = $yuyu2;
                                my $check_yuyuy2b = $yuyu2_tmp3 =~ s/$start_short_tmp_part/$start_short_tmp_part/;
                                if ($check_yuyuy2b > 0 || $check_yuyuy2b2 > 0)
                                {
                                    $second_yuyu2++;
                                    push @filter_dot_before2, $yuyu0;
                                    if (exists($extensions_yuyu{$search}))
                                    {     
                                        if ($y > $startprint2)
                                        {
                                        }
                                        push @extensions_before, $extensions_yuyu{$search};
                                        push @extensions_before2, $extensions_yuyu{$search};
                                    }
                                    if (exists($extensions_for_before_match_pair{$search}))
                                    {
                                        my $temp = $extensions_for_before_match_pair{$search};
                                        if ($use_quality ne "")
                                        {
                                            $temp =~ tr/1234ACTG/TGACTGAC/;
                                        }
                                        else
                                        {
                                            $temp =~ tr/ACTG/TGAC/;
                                        }
                                        $filter_before2{$search} = $temp;
                                        $count2_pair++;
                                        if ($y > $startprint2)
                                        {
                                        }
                                    }
                                }
                            }
                        }
                    }
                    foreach my $search (keys %before_all1)
                    {
                        my $overhang_tmp = $overhang;   
                        my $yuyu0 = $before_all1{$search};
                        my $yuyu1 = $yuyu0;
                        if (length($yuyu1) >= $read_length-$overhang_tmp-5-1)
                        {
                            $yuyu1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                            my $yuyu1_tmp = $yuyu1;
                            my $check_yuyuy = $yuyu1_tmp =~ s/$start_short_tmp_part/$start_short_tmp_part/;
                            
                            if ($check_yuyuy > 0)
                            {
                                my $start_short_tmp_part = substr $start_short_tmp, 0, length($yuyu1)-1;
                                my $star = $start_short_tmp_part =~ tr/\*//;
                                my $check_yuyuy1b2 = '0';
                                my $start_short_tmp_part2;
                                if ($star > 0)
                                {
                                    $start_short_tmp_part = substr $start_short_tmp, 0, length($yuyu1)-1+($star*2);
                                    $start_short_tmp_part2 = substr $start_short_tmp, 0, length($yuyu1)-1+($star);
                                    my $yuyu1_tmp2 = $yuyu1;
                                    $check_yuyuy1b2 = $yuyu1_tmp2 =~ s/$start_short_tmp_part2/$start_short_tmp_part2/;
                                }
                                my $yuyu1_tmp3 = $yuyu1;
                                my $check_yuyuy1b = $yuyu1_tmp3 =~ s/$start_short_tmp_part/$start_short_tmp_part/;
                                if ($check_yuyuy1b > 0 || $check_yuyuy1b2 > 0)
                                {
                                    $first_yuyu2++;
                                    push @filter_dot_before1, $yuyu0;
                                    if (exists($extensions_yuyu{$search}))
                                    {
                                        if ($y > $startprint2)
                                        {
                                        }
                                        push @extensions_before, $extensions_yuyu{$search};
                                        push @extensions_before1, $extensions_yuyu{$search};
                                    }
                                    if (exists($extensions_for_before_match_pair{$search}))
                                    {
                                        my $temp = $extensions_for_before_match_pair{$search};
                                        if ($use_quality ne "")
                                        {
                                            $temp =~ tr/1234ACTG/TGACTGAC/;
                                        }
                                        else
                                        {
                                            $temp =~ tr/ACTG/TGAC/;
                                        }
                                        $filter_before1{$search} = $temp;
                                        $count1_pair++;
                                        if ($y > $startprint2)
                                        {
                                        }
                                    }
                                }
                            }
                        }
                    }
                    foreach my $search (keys %before_all3)
                    {
                        my $overhang_tmp = $overhang;
                        my $yuyu0 = $before_all3{$search};
                        my $yuyu3 = $yuyu0;
                        if (length($yuyu3) >= $read_length-$overhang_tmp-5-1)
                        {
                            $yuyu3 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                            my $yuyu3_tmp = $yuyu3;
                            my $check_yuyuy = $yuyu3_tmp =~ s/$start_short_tmp_part/$start_short_tmp_part/;
                            
                            if ($check_yuyuy > 0)
                            {
                                my $start_short_tmp_part = substr $start_short_tmp, 0, length($yuyu3)-1;
                                my $star = $start_short_tmp_part =~ tr/\*//;
                                my $check_yuyuy3b2 = '0';
                                my $start_short_tmp_part2;
                                if ($star > 0)
                                {
                                    $start_short_tmp_part = substr $start_short_tmp, 0, length($yuyu3)-1+($star*2);
                                    $start_short_tmp_part2 = substr $start_short_tmp, 0, length($yuyu3)-1+($star);
                                    my $yuyu3_tmp2 = $yuyu3;
                                    $check_yuyuy3b2 = $yuyu3_tmp2 =~ s/$start_short_tmp_part2/$start_short_tmp_part2/;
                                }
                                my $yuyu3_tmp3 = $yuyu3;
                                my $check_yuyuy3b = $yuyu3_tmp3 =~ s/$start_short_tmp_part/$start_short_tmp_part/;
                                if ($check_yuyuy3b > 0 || $check_yuyuy3b2 > 0)
                                {
                                    $third_yuyu2++;
                                    push @filter_dot_before3, $yuyu0;
                                    if (exists($extensions_yuyu{$search}))
                                    {
                                        if ($y > $startprint2)
                                        {
                                        }
                                        push @extensions_before, $extensions_yuyu{$search};
                                        push @extensions_before3, $extensions_yuyu{$search};
                                    }
                                    if (exists($extensions_for_before_match_pair{$search}))
                                    {
                                        my $temp = $extensions_for_before_match_pair{$search};
                                        if ($use_quality ne "")
                                        {
                                            $temp =~ tr/1234ACTG/TGACTGAC/;
                                        }
                                        else
                                        {
                                            $temp =~ tr/ACTG/TGAC/;
                                        }
                                        $filter_before3{$search} = $temp;
                                        $count3_pair++;
                                        if ($y > $startprint2)
                                        {
                                        }
                                    }
                                }
                            }
                        }
                    }
                    foreach my $search (keys %before_all4)
                    {
                        my $yuyu0 = $before_all4{$search};
                        my $yuyu4 = $yuyu0;
                        if (length($yuyu4) >= $read_length-$overhang-5-1)
                        {
                            $yuyu4 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                            my $yuyu4_tmp = $yuyu4;
                            my $check_yuyuy = $yuyu4_tmp =~ s/$start_short_tmp_part/$start_short_tmp_part/;
                            
                            if ($check_yuyuy > 0)
                            {
                                my $start_short_tmp_part = substr $start_short_tmp, 0, length($yuyu4)-1;
                                my $star = $start_short_tmp_part =~ tr/\*//;
                                my $check_yuyuy4b2 = '0';
                                my $start_short_tmp_part2;
                                if ($star > 0)
                                {
                                    $start_short_tmp_part = substr $start_short_tmp, 0, length($yuyu4)-1+($star*2);
                                    $start_short_tmp_part2 = substr $start_short_tmp, 0, length($yuyu4)-1+($star);
                                    my $yuyu4_tmp2 = $yuyu4;
                                    $check_yuyuy4b2 = $yuyu4_tmp2 =~ s/$start_short_tmp_part2/$start_short_tmp_part2/;
                                }
                                my $yuyu4_tmp3 = $yuyu4;
                                my $check_yuyuy4b = $yuyu4_tmp3 =~ s/$start_short_tmp_part/$start_short_tmp_part/;
                                if ($check_yuyuy4b > 0 || $check_yuyuy4b2 > 0)
                                {
                                    $fourth_yuyu2++;
                                    push @filter_dot_before4, $yuyu0;
                                    if (exists($extensions_yuyu{$search}))
                                    {
                                        if ($y > $startprint2)
                                        {
                                        }
                                        push @extensions_before, $extensions_yuyu{$search};
                                        push @extensions_before4, $extensions_yuyu{$search};
                                    }
                                    if (exists($extensions_for_before_match_pair{$search}))
                                    {
                                        my $temp = $extensions_for_before_match_pair{$search};
                                        if ($use_quality ne "")
                                        {
                                            $temp =~ tr/1234ACTG/TGACTGAC/;
                                        }
                                        else
                                        {
                                            $temp =~ tr/ACTG/TGAC/;
                                        }
                                        $filter_before4{$search} = $temp;
                                        $count4_pair++;
                                        if ($y > $startprint2)
                                        {
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $first_yuyu2." FIRST_YUYU\n";
                        print OUTPUT5 $second_yuyu2." SECOND_YUYU\n";
                        print OUTPUT5 $third_yuyu2." THIRD_YUYU\n";
                        print OUTPUT5 $fourth_yuyu2." FOURTH_YUYU\n";
                        
                        print OUTPUT5 $count1_pair." PAIR1\n";
                        print OUTPUT5 $count2_pair." PAIR2\n";
                        print OUTPUT5 $count3_pair." PAIR3\n";
                        print OUTPUT5 $count4_pair." PAIR4\n";
                    }
                    my $correction = '0';
                    my $count_all = '0';
                    $count_all = (@filter_dot_before1) + (@filter_dot_before2) + (@filter_dot_before3) + (@filter_dot_before4);
                    my $start_short_tmp2 = substr $read_short_start2, 0, $read_length-$overhang-5-1;
                    my $check_dot = $start_short_tmp2 =~ tr/\./\./;
                    if ($check_dot eq "")
                    {
                        $check_dot = '0'
                    }
                    my $check_star = $start_short_tmp2 =~ tr/\*/\*/;
                    my $check_star2 = "";
                    my $deletion = "";
print OUTPUT5 $check_star." CHECK_STAR\n";
print OUTPUT5 $count_all." COUNT_ALL\n";
                    my $no_correction = "";
                    if ($count_all > 2 && ($check_dot > 0 || $check_star > 0) && $type ne "mito_plant" && $heteroplasmy eq "")
                    {
                        my @split_dot = split /\./, $start_short_tmp2;
                        my $size = '0';
                        my $size2 = '1';
                        my $length_total = '0';
                        my @filter_dot_before_all;
                        undef @filter_dot_before_all;
                        @filter_dot_before_all = (@filter_dot_before1, @filter_dot_before2, @filter_dot_before3, @filter_dot_before4);
                        
                        if ($check_star > 0)
                        {
                            my @deletion = split //, $start_short_tmp2;
                            my $found_star = "";
                            foreach my $nuc (@deletion)
                            {
                                if ($found_star eq "yes")
                                {
                                    $found_star = "";
                                    $deletion .= $nuc;
                                }
                                if ($nuc eq "*")
                                {
                                    $found_star = "yes";
                                }
                            }
                            print OUTPUT5 $deletion." NUC0\n";
                        }
                        foreach my $dot_split (@split_dot)
                        {
                           $size++; 
                        }
                        foreach my $dot_split (@split_dot)
                        {
                            if ($size2 ne $size)
                            {
                                $length_total += length($dot_split);
                                my $A = '0';
                                my $C = '0';
                                my $T = '0';
                                my $G = '0';
                                my $check_star2_part = "";
                                if ($check_star > 0)
                                {
                                    $check_star2_part = substr $start_short_tmp2, 0, $length_total;
                                    $check_star2 = $check_star2_part =~ tr/\*/\*/;
                                    print OUTPUT5 $check_star2." CHECK_STAR2\n";
                                }
                                foreach my $dot_before2 (@filter_dot_before_all)
                                {  
                                    my $dot = substr $dot_before2, $length_total, 1;
                                    if ($check_star2 > 0)
                                    {
                                        print OUTPUT5 $deletion." DEL_DOT\n";
                                        my $check_star2_part_tmp1 = $check_star2_part;
                                        $check_star2_part_tmp1 =~ tr/\*//d;
                                        my $dot_before2_tmp = $dot_before2;
                                        my $check_star1 = $dot_before2_tmp =~ s/$check_star2_part_tmp1/$check_star2_part_tmp1/;
                                        if ($check_star1 > 0)
                                        {
                                            $dot = substr $dot_before2, $length_total-$check_star2, 1;
                                        }
                                        else
                                        {
                                            $dot = substr $dot_before2, $length_total-($check_star2*2), 1;
                                        }
                                    }
                                    if ($dot eq "A")
                                    {
                                        $A++;
                                    }
                                    elsif ($dot eq "C")
                                    {
                                        $C++;
                                    }
                                    elsif ($dot eq "T")
                                    {
                                        $T++;
                                    }
                                    elsif ($dot eq "G")
                                    {
                                        $G++;
                                    } 
                                }
                                if (($A > 2 && ($C+$T+$G) eq 0) || ($A > ($C+$T+$G)*10 && $repetitive_detect eq ""))
                                {
                                    substr $read_new1, $length_total, 1, "A";
                                    print OUTPUT5 "DOT AAAAAAAAAAAA\n";
                                    $correction++;
                                }
                                if (($C > 2 && ($A+$T+$G) eq 0) || ($C > ($A+$T+$G)*10 && $repetitive_detect eq ""))
                                {
                                    substr $read_new1, $length_total, 1, "C";
                                    print OUTPUT5 "DOT CCCCCCCCCCCC\n";
                                    $correction++;
                                }
                                if (($T > 2 && ($C+$A+$G) eq 0) || ($T > ($C+$A+$G)*10 && $repetitive_detect eq ""))
                                {
                                    substr $read_new1, $length_total, 1, "T";
                                    print OUTPUT5 "DOT TTTTTTTTTTTT\n";
                                    $correction++;
                                }
                                if (($G > 2 && ($C+$T+$A) eq 0) || ($G > ($C+$T+$A)*10 && $repetitive_detect eq ""))
                                {
                                    substr $read_new1, $length_total, 1, "G";
                                    print OUTPUT5 "DOT GGGGGGGGGGGGG\n";
                                    $correction++;
                                }
                                $length_total += 1;
                            }
                            $size2++;
                        }
                    }
                    else
                    {
                        $no_correction = "yes";
                    }
                    my %count1234;
                    my %count1234b;
                    undef %count1234;
                    undef %count1234b;
                    
                    $count1234{'1'} = $count1_pair;
                    $count1234{'2'} = $count2_pair;
                    $count1234{'3'} = $count3_pair;
                    $count1234{'4'} = $count4_pair;
                    
                    my $morethan3 = '0';
                    my $difference = "";
                    
                    foreach my $count1234 (keys %count1234)
                    {
                        if ($count1234{$count1234} > 3)
                        {
                            $morethan3++;
                        }
                    }
                        
                    my $h = '10';
                    if ($type eq "mito_plant" && ($first_yuyu2+$second_yuyu2+$third_yuyu2+$fourth_yuyu2) > $average_coverage_ext*0.8)
                    {
                        $h = '20';
                    }
                    if ($type eq "mito_plant" && ($first_yuyu2+$second_yuyu2+$third_yuyu2+$fourth_yuyu2) > $average_coverage_ext*4 && $average_coverage_ext > 0)
                    {
                        $h = ($first_yuyu2+$second_yuyu2+$third_yuyu2+$fourth_yuyu2)/($average_coverage_ext/6);
                    }

                    if (($first_yuyu2 > 3 && ($second_yuyu2+$third_yuyu2+$fourth_yuyu2) eq '0' || ($first_yuyu2 > ($second_yuyu2+$third_yuyu2+$fourth_yuyu2)*$h && ($second_yuyu2+$third_yuyu2+$fourth_yuyu2) ne '0' && $repetitive_detect_back2 ne "yes")) && ($correction eq $check_dot || $no_correction ne ""|| $overhang >= $read_length-($overlap+15)))
                    {
                        if (@extensions_before > 3000000000)
                        {
                            $ext_before = "yes";
                            @extensions_before = @extensions_before1;
                            goto EXT_BEFORE_BACK;
                        }
                        $best_extension2 = "";
                        $best_extension3 = "";
                        $best_extension4 = "";
                        $best_extension = $best_extension1;
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nONLY FIRST\n\n";
                        }
                        delete $SNP_active_back{$id};
                        delete $before_back{$id};
                        delete $before_shorter_skip_back{$id};
                        if ($split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep_back eq "" && $repetitive_detect_back eq "")
                        {
                            $split = "";
                            $before_back = "yes";
                            goto REFERENCE_BACK;
                        }
                        goto AFTER_EXT_BACK;
                    }
                    elsif (($second_yuyu2 > 3 && ($first_yuyu2+$third_yuyu2+$fourth_yuyu2) eq '0' || ($second_yuyu2 > ($first_yuyu2+$third_yuyu2+$fourth_yuyu2)*$h && ($first_yuyu2+$third_yuyu2+$fourth_yuyu2) ne '0' && $repetitive_detect_back2 ne "yes")) && ($correction eq $check_dot || $no_correction ne ""|| $overhang >= $read_length-($overlap+15)))
                    {
                        if (@extensions_before > 3000000000)
                        {
                            $ext_before = "yes";
                            @extensions_before = @extensions_before2;
                            goto EXT_BEFORE_BACK;
                        }
                        $best_extension1 = "";
                        $best_extension3 = "";
                        $best_extension4 = "";
                        $best_extension = $best_extension2;
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nONLY SECOND\n\n";
                            print OUTPUT5 $best_extension2." BEST_E2\n\n";
                        }
                        delete $SNP_active_back{$id};
                        delete $before_back{$id};
                        delete $before_shorter_skip_back{$id};
                        
                        if ($split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep_back eq "" && $repetitive_detect_back eq "")
                        {
                            $split = "";
                            $before_back = "yes";
                            goto REFERENCE_BACK;
                        }
                        goto AFTER_EXT_BACK;
                    }
                    elsif (($third_yuyu2 > 3 && ($first_yuyu2+$second_yuyu2+$fourth_yuyu2) eq '0' || ($third_yuyu2 > ($first_yuyu2+$second_yuyu2+$fourth_yuyu2)*$h && ($first_yuyu2+$second_yuyu2+$fourth_yuyu2) ne '0' && $repetitive_detect_back2 ne "yes")) && ($correction eq $check_dot || $no_correction ne ""|| $overhang >= $read_length-($overlap+15)))
                    {
                        if (@extensions_before > 3000000000)
                        {
                            $ext_before = "yes";
                            @extensions_before = @extensions_before3;
                            goto EXT_BEFORE_BACK;
                        }
                        $best_extension1 = "";
                        $best_extension2 = "";
                        $best_extension4 = "";
                        $best_extension = $best_extension3;
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nONLY THIRD\n\n";
                        }
                        delete $SNP_active_back{$id};
                        delete $before_back{$id};
                        delete $before_shorter_skip_back{$id};

                        if ($split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep_back eq "" && $repetitive_detect_back eq "")
                        {
                            $split = "";
                            $before_back = "yes";  
                            goto REFERENCE_BACK;
                        }
                        goto AFTER_EXT_BACK;
                    }
                    elsif (($fourth_yuyu2 > 3 && ($first_yuyu2+$third_yuyu2+$second_yuyu2) eq '0' || ($fourth_yuyu2 > ($first_yuyu2+$third_yuyu2+$second_yuyu2)*$h && ($first_yuyu2+$third_yuyu2+$second_yuyu2) ne '0' && $repetitive_detect_back2 ne "yes")) && ($correction eq $check_dot || $no_correction ne ""|| $overhang >= $read_length-($overlap+15)))
                    {
                        if (@extensions_before > 3000000000)
                        {
                            $ext_before = "yes";
                            @extensions_before = @extensions_before4;
                            goto EXT_BEFORE_BACK;
                        }
                        $best_extension1 = "";
                        $best_extension2 = "";
                        $best_extension3 = "";
                        $best_extension = $best_extension4;
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nONLY FOURTH\n\n";
                        }
                        delete $SNP_active_back{$id};
                        delete $before_back{$id};
                        delete $before_shorter_skip_back{$id};
                        
                        if ($split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep_back eq "" && $repetitive_detect_back eq "")
                        {
                            $split = "";
                            $before_back = "yes";
                            goto REFERENCE_BACK;
                        }
                        goto AFTER_EXT_BACK;
                    }
                    elsif($count_all < 3 && $overhang < $read_length-($overlap+15) && $skip_overhang ne "yes")
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nMAKE BEFORE SHORTER\n\n";
                        }
                        $before_shorter = "yes";
                        goto BEFORE_BACK;
                    }
                    elsif((($morethan3 eq 0 && $overhang < $read_length-($overlap*1.5)) || ($morethan3 > 0 && length($read) <= $insert_size && $overhang < 30)) && $skip_overhang ne "yes")
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nMAKE BEFORE SHORTER2\n\n";
                        }
                        $before_shorter = "yes";
                        goto BEFORE_BACK;
                    }
                    elsif ($overhang_for_pairs > $overhang && $average_coverage_ext < 80 && $skip_overhang eq "" && $hp_seed_assemble eq "")
                    {
                        if ($y > $startprint2)
                        {
                            print OUTPUT5 "\nINCREASE_OVERHANG_BACK\n\n";
                        }
                        $overhang = $overhang_for_pairs;
                        goto BEFORE_BACK;
                    }
                    else
                    {
                        my $SNR_check1;
                        my $SNR_check2;
                        if (length($best_extension1) > 6)
                        {
                            my $SNR_check1 = AT_rich_test ($best_extension1,length($best_extension1)/2.5);
                        }
                        if (length($best_extension2) > 6)
                        {
                            my $SNR_check2 = AT_rich_test ($best_extension2,length($best_extension2)/2.5);
                        }
                        
                        
                        if ($morethan3 > 0 && length($read) > $insert_size && $last_chance_back ne "yes")
                        {
                            my $count1b = '0';
                            my $count2b = '0';
                            my $count3b = '0';
                            my $count4b = '0';
                            my $count1b_no = '0';
                            my $count2b_no = '0';
                            my $count3b_no = '0';
                            my $count4b_no = '0';
                                                                                                   
                            my $size = keys %read_short_end_tmp;
                            undef @extensions_before;
                            undef @extensions_before1;
                            undef @extensions_before2;
                            undef @extensions_before3;
                            undef @extensions_before4;                                              
                            
                            my $read_short_start_tempie_long = substr $read, 0, $insert_size*2.1;
                            $read_short_start_tempie_long =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                            my $last_nuc_tmp = substr $read_short_start_tempie_long, 0, 1;
                            my $last_nuc_tmp2 = substr $read_short_start_tempie_long, 1, 1;
                            while ($last_nuc_tmp eq "*" || $last_nuc_tmp2 eq "*")
                            {              
                                chop $read_short_start_tempie_long;
                                if ($last_nuc_tmp eq "*")
                                {
                                    substr $read_short_start_tempie_long, 0, 1, "";
                                }
                                $last_nuc_tmp = substr $read_short_start_tempie_long, 0, 1;
                            }

                            undef %read_short_start_tmp;

                            my %read_short_start_tmp_long = build_partial3c ($read_short_start_tempie_long,"","no_delete");
                            my $star_groups = keys %read_short_start_tmp_long;
                            $star_groups--;
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $read_short_start_tempie_long." READ_SHORT\n";
                            }
                        
                            my $ff = '0';
                            my %hash_read_short_start_for_before;
                            undef %hash_read_short_start_for_before;
                            foreach my $read_short_start_tempie (keys %read_short_start_tmp_long)
                            {
                                $ff = '0';
                                while ($ff < (length($read_short_start_tempie)-$read_length+30+2))
                                {
                                    my $read_short_start_part = substr $read_short_start_tempie, $ff, $read_length-30;
                                    if ($star_groups eq '1')
                                    {
                                        my @split_tmp = split /\+/, $read_short_start_tmp_long{$read_short_start_tempie};
                                        if ($ff > $split_tmp[1])
                                        {
                                            $ff += $split_tmp[0];
                                        }
                                    }                               
                                    $hash_read_short_start_for_before{$read_short_start_part} = $ff;
                                    $ff++;
                                }
                            }                          
                           
                            my $w = '0';
                            my $kmer_tmp = '13';
                            my %hash_read_short_start_for_before_short;
                            undef %hash_read_short_start_for_before_short;

                            while (length($read_short_start_tempie_long)-$w-$kmer_tmp > 0)
                            {
                                my $seq_part = substr $read_short_start_tempie_long, $w, $kmer_tmp;
                                if (exists($hash_read_short_start_for_before_short{$seq_part}))
                                {
                                    $hash_read_short_start_for_before_short{$seq_part} .= ",$w";
                                }
                                else
                                {
                                    $hash_read_short_start_for_before_short{$seq_part} = $w;
                                }
                                $w++;
                            }
                            
                            my %hash_read_short_start_for_before_full;
                            undef %hash_read_short_start_for_before_full;
                            
                            foreach my $read_short_start_tempie (keys %read_short_start_tmp_long)
                            {
            print OUTPUT5 $star_groups." TESTh\n";
                                my $ff2 = '0';
                                while ($ff2 < (length($read_short_start_tempie)-$read_length))
                                {
                                    my $read_short_start_part = substr $read_short_start_tempie, $ff2, $read_length;
                                    if ($star_groups eq '1')
                                    {
                                        my @split_tmp = split /\+/, $read_short_start_tmp_long{$read_short_start_tempie};
                                        if ($ff2 > $split_tmp[1])
                                        {
                                            $ff2 += $split_tmp[0];
                                        }
                                    }
                                    $hash_read_short_start_for_before_full{$read_short_start_part} = $ff2;
                                    $ff2++;
                                }
                            }
                                                      
                            my %matches_read_short_start_long1_pos;
                            my %matches_read_short_start_long2_pos;
                            my %matches_read_short_start_long3_pos;
                            my %matches_read_short_start_long4_pos;
                            my %matches_read_short_start_long1_neg;
                            my %matches_read_short_start_long2_neg;
                            my %matches_read_short_start_long3_neg;
                            my %matches_read_short_start_long4_neg;
                            undef %matches_read_short_start_long1_pos;
                            undef %matches_read_short_start_long2_pos;
                            undef %matches_read_short_start_long3_pos;
                            undef %matches_read_short_start_long4_pos;
                            undef %matches_read_short_start_long1_neg;
                            undef %matches_read_short_start_long2_neg;
                            undef %matches_read_short_start_long3_neg;
                            undef %matches_read_short_start_long4_neg;
                            
                            my $xx = '1';
                            while ($xx < length($read_short_start_tempie_long))
                            {
                                $matches_read_short_start_long1_pos{$xx} = '0';
                                $matches_read_short_start_long1_neg{$xx} = '0';
                                $matches_read_short_start_long2_pos{$xx} = '0';
                                $matches_read_short_start_long2_neg{$xx} = '0';
                                $matches_read_short_start_long3_pos{$xx} = '0';
                                $matches_read_short_start_long3_neg{$xx} = '0';
                                $matches_read_short_start_long4_pos{$xx} = '0';
                                $matches_read_short_start_long4_neg{$xx} = '0';
                                $xx++;
                            }
                            
                            my @read_short_start_tempie_long = split //, $read_short_start_tempie_long;
          
                            foreach my $exb0 (keys %filter_before1)
                            { 
                                my $exb = $filter_before1{$exb0};                        
                                my $is_a_match = "";
                                if (exists($hash_read_short_start_for_before_full{$exb}))
                                {
                                    $is_a_match = "yes";
                                    my $xx_tmp = '1';
                                    while ($xx_tmp < length($exb) && $star_groups < 2)
                                    {
                                        my $pos_tmp = $xx_tmp+$hash_read_short_start_for_before_full{$exb};
                                        my $count_tmp = $matches_read_short_start_long1_pos{$pos_tmp}+1;
                                        $matches_read_short_start_long1_pos{$pos_tmp} = $count_tmp;
                                        $xx_tmp++;
                                    }
                                }
                                else
                                {
                                    my $th = '0';
                                    my $no_match = "";
                                    my $d = '0';
                                    my @read_pair_tmp = split //, $exb;
                                                                         
                                    my $match_pair_middle = substr $exb, 15, length($exb)-30;
                                    if (exists($hash_read_short_start_for_before{$match_pair_middle}))
                                    {
                                        $th = $hash_read_short_start_for_before{$match_pair_middle}-15;
                                        $is_a_match = "yes";
                                    }
                                    else
                                    {
                                        my $o = '0';
                                        my $start_pos_read = "";
                                        my $start_pos_ref = "";
                                        my $current_pos = "";
                                        my $match_tmp = "";
                                        
                                        while ($o < length($exb)-13)
                                        {
                                            my $part_tmp = substr $exb, $o, 13;
                                            if (exists($hash_read_short_start_for_before_short{$part_tmp}))
                                            {
                                                my @split_pos = split /,/, $hash_read_short_start_for_before_short{$part_tmp};
                                                if (@split_pos eq '1' && $start_pos_ref eq "")
                                                {
                                                    $start_pos_ref = $split_pos[0];
                                                    $start_pos_read = $o;
                                                    $current_pos = $split_pos[0];
                                                    $match_tmp = "yes";
                                                }
                                                elsif ($start_pos_ref ne "")
                                                {
                                                    foreach my $split_pos (@split_pos)
                                                    {
                                                        if ($split_pos > $current_pos && $split_pos < $current_pos+15 && $start_pos_ref-$start_pos_read eq $split_pos-$o)
                                                        {
                                                            $current_pos = $split_pos;
                                                            $match_tmp = "yes";
                                                        }
                                                    }
                                                }
                                            }
                                            elsif ($match_tmp eq "yes")
                                            {
                                                $match_tmp = "no";
                                                $o += 11;
                                            }
                                            $o++;
                                        }
                                        if ($current_pos-$start_pos_ref > length($exb)*0.75)
                                        {
                                            $th = $start_pos_ref-$start_pos_read;
                                        }
                                        else
                                        {
                                            $no_match = "yes";
                                        }
                                    }
                                    if ($no_match ne "yes")
                                    {
                                        $d = '0';
                                        my $count_matches = '0';
                                        my $star_detect = "";
                                        if ($y > $startprint2 && $count1_pair < 100)
                                        {
                                        }
                                        
                                        while ($d < length($exb))
                                        {
                                            my $pos_tmp = $d+$th+1;
                                            if ($pos_tmp > 0 && $pos_tmp <= length($read_short_start_tempie_long))
                                            {
                                                if ($read_short_start_tempie_long[$d+$th+1] eq "*")
                                                {
                                                    if ($read_pair_tmp[$d] eq $read_short_start_tempie_long[$d+$th])
                                                    {
                                                        $star_detect = "1";
                                                    }
                                                    else
                                                    {
                                                        while ($read_short_start_tempie_long[$d+$th+1] eq "*")
                                                        {
                                                            $th += 2;
                                                        }
                                                    }
                                                }
                                                
                                                if ($read_pair_tmp[$d] eq $read_short_start_tempie_long[$d+$th])
                                                {
                                                    my $count_tmp = $matches_read_short_start_long1_pos{$pos_tmp}+1;
                                                    $matches_read_short_start_long1_pos{$pos_tmp} = $count_tmp;
                                                    $count_matches++;
                                                }
                                                elsif ($read_pair_tmp[$d] eq "N")
                                                {
                                                }
                                                elsif ($read_short_start_tempie_long[$d+$th] eq ".")
                                                {
                                                }          
                                                else
                                                {
                                                    if ($read_short_start_tempie_long[$d+$th] eq "*" && $star_detect eq "1")
                                                    {
                                                        $d--;
                                                        $th++;
                                                    }
                                                    else
                                                    {
                                                        my $count_tmp = $matches_read_short_start_long1_neg{$pos_tmp}-1;
                                                        $matches_read_short_start_long1_neg{$pos_tmp} = $count_tmp;
                                                    }
                                                }
                                            }
                                            $d++  
                                        }
                                        if ($count_matches > length($exb)*0.9)
                                        {
                                            $is_a_match = "yes";
                                        }
                                    }
                                }
                                if ($is_a_match eq "yes")
                                {
                                    if ($y > $startprint2 && $count1_pair < 100)
                                    {
                                    }
                                    if (exists($extensions_yuyu{$exb0}))
                                    {
                                        push @extensions_before, $extensions_yuyu{$exb0};
                                        push @extensions_before1, $extensions_yuyu{$exb0};
                                    }
                                    $count1b++;
                                }
                                else
                                {
                                    $count1b_no++;
                                }
                            }
                                             
                            
                            foreach my $exb0 (keys %filter_before2)
                            { 
                                my $exb = $filter_before2{$exb0};
                                my $is_a_match = "";
                                
                                if (exists($hash_read_short_start_for_before_full{$exb}))
                                {
                                    $is_a_match = "yes";
                                    my $xx_tmp = '1';
                                    while ($xx_tmp < length($exb) && $star_groups < 2)
                                    {
                                        my $pos_tmp = $xx_tmp+$hash_read_short_start_for_before_full{$exb};
                                        my $count_tmp = $matches_read_short_start_long2_pos{$pos_tmp}+1;
                                        $matches_read_short_start_long2_pos{$pos_tmp} = $count_tmp;
                                        $xx_tmp++;
                                    }
                                }
                                else
                                {
                                    my $th = '0';
                                    my $no_match = "";
                                    my $d = '0';
                                    my @read_pair_tmp = split //, $exb;
                                                                         
                                    my $pos_middle = sprintf("%.0f",length($exb)/2)-25;
                                    my $match_pair_middle = substr $exb, 15, length($exb)-30;
                                    if (exists($hash_read_short_start_for_before{$match_pair_middle}))
                                    {
                                        $th = $hash_read_short_start_for_before{$match_pair_middle}-15;
                                        $is_a_match = "yes";
                                    }
                                    else
                                    {
                                        my $o = '0';
                                        my $start_pos_read = "";
                                        my $start_pos_ref = "";
                                        my $current_pos = "";
                                        my $match_tmp = "";
                                        while ($o < length($exb)-13)
                                        {
                                            my $part_tmp = substr $exb, $o, 13;
                                            if (exists($hash_read_short_start_for_before_short{$part_tmp}))
                                            {
                                                my @split_pos = split /,/, $hash_read_short_start_for_before_short{$part_tmp};
                                                if (@split_pos eq '1' && $start_pos_ref eq "")
                                                {
                                                    $start_pos_ref = $split_pos[0];
                                                    $start_pos_read = $o;
                                                    $current_pos = $split_pos[0];
                                                    $match_tmp = "yes";
                                                }
                                                elsif ($start_pos_ref ne "")
                                                {
                                                    foreach my $split_pos (@split_pos)
                                                    {
                                                        if ($split_pos > $current_pos && $split_pos < $current_pos+15 && $start_pos_ref-$start_pos_read eq $split_pos-$o)
                                                        {
                                                            $current_pos = $split_pos;
                                                            $match_tmp = "yes";
                                                        }
                                                    }
                                                }
                                            }
                                            elsif ($match_tmp eq "yes")
                                            {
                                                $match_tmp = "no";
                                                $o += 11;
                                            }
                                            $o++;
                                        }
                                        if ($current_pos-$start_pos_ref > length($exb)*0.75)
                                        {
                                            $th = $start_pos_ref-$start_pos_read;
                                        }
                                        else
                                        {
                                            $no_match = "yes";
                                        }
                                    }
                                    if ($no_match ne "yes")
                                    {
                                        $d = '0';
                                        my $count_matches = '0';
                                        my $star_detect = "";
                                        while ($d < length($exb))
                                        {
                                            my $pos_tmp = $d+$th+1;
                                            if ($pos_tmp > 0 && $pos_tmp <= length($read_short_start_tempie_long))
                                            {
                                                if ($read_short_start_tempie_long[$d+$th+1] eq "*")
                                                {
                                                    if ($read_pair_tmp[$d] eq $read_short_start_tempie_long[$d+$th])
                                                    {
                                                        $star_detect = "1";
                                                    }
                                                    else
                                                    {
                                                        while ($read_short_start_tempie_long[$d+$th+1] eq "*")
                                                        {
                                                            $th += 2;
                                                        }
                                                    }
                                                }
                                                
                                                if ($read_pair_tmp[$d] eq $read_short_start_tempie_long[$d+$th])
                                                {
                                                    my $count_tmp = $matches_read_short_start_long2_pos{$pos_tmp}+1;
                                                    $matches_read_short_start_long2_pos{$pos_tmp} = $count_tmp;
                                                    $count_matches++;
                                                }
                                                elsif ($read_pair_tmp[$d] eq "N")
                                                {
                                                }
                                                elsif ($read_short_start_tempie_long[$d+$th] eq ".")
                                                {
                                                }          
                                                else
                                                {
                                                    if ($read_short_start_tempie_long[$d+$th] eq "*" && $star_detect eq "1")
                                                    {
                                                        $d--;
                                                        $th++;
                                                    }
                                                    else
                                                    {
                                                        my $count_tmp = $matches_read_short_start_long2_neg{$pos_tmp}-1;
                                                        $matches_read_short_start_long2_neg{$pos_tmp} = $count_tmp;
                                                    }
                                                }
                                            }
                                            $d++  
                                        }
                                        if ($count_matches > length($exb)*0.9)
                                        {
                                            $is_a_match = "yes";
                                        }
                                    }       
                                }
                                if ($is_a_match eq "yes")
                                {
                                    if ($y > $startprint2 && $count2_pair < 100)
                                    {
                                    }
                                    if (exists($extensions_yuyu{$exb0}))
                                    {
                                        push @extensions_before, $extensions_yuyu{$exb0};
                                        push @extensions_before2, $extensions_yuyu{$exb0};
                                    }
                                    $count2b++;
                                }
                                else
                                {
                                    $count2b_no++;
                                }
                            }
                            
                            foreach my $exb0 (keys %filter_before3)
                            { 
                                my $exb = $filter_before3{$exb0};                        
                                my $is_a_match = "";
                                
                                if (exists($hash_read_short_start_for_before_full{$exb}))
                                {
                                    $is_a_match = "yes";
                                    my $xx_tmp = '1';
                                    while ($xx_tmp < length($exb))
                                    {
                                        my $pos_tmp = $xx_tmp+$hash_read_short_start_for_before_full{$exb};
                                        my $count_tmp = $matches_read_short_start_long3_pos{$pos_tmp}+1;
                                        $matches_read_short_start_long3_pos{$pos_tmp} = $count_tmp;
                                        $xx_tmp++;
                                    }
                                }
                                else
                                {
                                    my $th = '0';
                                    my $no_match = "";
                                    my $d = '0';
                                    my @read_pair_tmp = split //, $exb;
                                                                         
                                    my $match_pair_middle = substr $exb, 15, length($exb)-30;
                                    if (exists($hash_read_short_start_for_before{$match_pair_middle}))
                                    {
                                        $th = $hash_read_short_start_for_before{$match_pair_middle}-15;
                                        $is_a_match = "yes";
                                    }
                                    else
                                    {
                                        my $o = '0';
                                        my $start_pos_read = "";
                                        my $start_pos_ref = "";
                                        my $current_pos = "";
                                        my $match_tmp = "";
                                        while ($o < length($exb)-13)
                                        {
                                            my $part_tmp = substr $exb, $o, 13;
                                            if (exists($hash_read_short_start_for_before_short{$part_tmp}))
                                            {
                                                my @split_pos = split /,/, $hash_read_short_start_for_before_short{$part_tmp};
                                                if (@split_pos eq '1' && $start_pos_ref eq "")
                                                {
                                                    $start_pos_ref = $split_pos[0];
                                                    $start_pos_read = $o;
                                                    $current_pos = $split_pos[0];
                                                    $match_tmp = "yes";
                                                }
                                                elsif ($start_pos_ref ne "")
                                                {
                                                    foreach my $split_pos (@split_pos)
                                                    {
                                                        if ($split_pos > $current_pos && $split_pos < $current_pos+15 && $start_pos_ref-$start_pos_read eq $split_pos-$o)
                                                        {
                                                            $current_pos = $split_pos;
                                                            $match_tmp = "yes";
                                                        }
                                                    }
                                                }
                                            }
                                            elsif ($match_tmp eq "yes")
                                            {
                                                $match_tmp = "no";
                                                $o += 11;
                                            }
                                            $o++;
                                        }
                                        
                                        if ($current_pos-$start_pos_ref > length($exb)*0.75)
                                        {
                                            $th = $start_pos_ref-$start_pos_read;
                                        }
                                        else
                                        {
                                            $no_match = "yes";
                                        }
                                    }
                                    if ($no_match ne "yes")
                                    {
                                        $d = '0';
                                        my $count_matches = '0';
                                        
                                        while ($d < length($exb))
                                        {
                                            my $pos_tmp = $d+$th+1;                                          
                                            if ($pos_tmp > 0 && $pos_tmp <= length($read_short_start_tempie_long))
                                            {
                                                if ($read_pair_tmp[$d] eq $read_short_start_tempie_long[$d+$th])
                                                {
                                                    my $count_tmp = $matches_read_short_start_long3_pos{$pos_tmp}+1;
                                                    $matches_read_short_start_long3_pos{$pos_tmp} = $count_tmp;
                                                    $count_matches++;
                                                }
                                                elsif ($read_pair_tmp[$d] eq "N")
                                                {
                                                }
                                                elsif ($read_short_start_tempie_long[$d+$th] eq ".")
                                                {
                                                }          
                                                else
                                                {
                                                    my $count_tmp = $matches_read_short_start_long3_neg{$pos_tmp}-1;
                                                    $matches_read_short_start_long3_neg{$pos_tmp} = $count_tmp;
                                                }
                                            }
                                            $d++  
                                        }
                                        if ($count_matches > length($exb)*0.9)
                                        {
                                            $is_a_match = "yes";
                                        }
                                    }  
                                }
                                
                                if ($is_a_match eq "yes")
                                {
                                    if ($y > $startprint2 && $count3_pair < 100)
                                    {
                                    }
                                    if (exists($extensions_yuyu{$exb0}))
                                    {
                                        push @extensions_before, $extensions_yuyu{$exb0};
                                        push @extensions_before3, $extensions_yuyu{$exb0};
                                    }
                                    $count3b++;
                                }
                                else
                                {
                                    $count3b_no++;
                                }
                            }
                            
                            foreach my $exb0 (keys %filter_before4)
                            { 
                                my $exb = $filter_before4{$exb0};                        
                                my $is_a_match = "";
                                
                                if (exists($hash_read_short_start_for_before_full{$exb}))
                                {
                                    $is_a_match = "yes";
                                    my $xx_tmp = '1';
                                    while ($xx_tmp < length($exb))
                                    {
                                        my $pos_tmp = $xx_tmp+$hash_read_short_start_for_before_full{$exb};
                                        my $count_tmp = $matches_read_short_start_long4_pos{$pos_tmp}+1;
                                        $matches_read_short_start_long4_pos{$pos_tmp} = $count_tmp;
                                        $xx_tmp++;
                                    }
                                }
                                else
                                {
                                    my $th = '0';
                                    my $no_match = "";
                                    my $d = '0';
                                    my @read_pair_tmp = split //, $exb;
                                                                         
                                    my $match_pair_middle = substr $exb, 15, length($exb)-30;
                                    if (exists($hash_read_short_start_for_before{$match_pair_middle}))
                                    {
                                        $th = $hash_read_short_start_for_before{$match_pair_middle}-15;
                                        $is_a_match = "yes";
                                    }
                                    else
                                    {
                                        my $o = '0';
                                        my $start_pos_read = "";
                                        my $start_pos_ref = "";
                                        my $current_pos = "";
                                        my $match_tmp = "";
                                        while ($o < length($exb)-13)
                                        {
                                            my $part_tmp = substr $exb, $o, 13;
                                            if (exists($hash_read_short_start_for_before_short{$part_tmp}))
                                            {
                                                my @split_pos = split /,/, $hash_read_short_start_for_before_short{$part_tmp};
                                                if (@split_pos eq '1' && $start_pos_ref eq "")
                                                {
                                                    $start_pos_ref = $split_pos[0];
                                                    $start_pos_read = $o;
                                                    $current_pos = $split_pos[0];
                                                    $match_tmp = "yes";
                                                }
                                                elsif ($start_pos_ref ne "")
                                                {
                                                    foreach my $split_pos (@split_pos)
                                                    {
                                                        if ($split_pos > $current_pos && $split_pos < $current_pos+15 && $start_pos_ref-$start_pos_read eq $split_pos-$o)
                                                        {
                                                            $current_pos = $split_pos;
                                                            $match_tmp = "yes";
                                                        }
                                                    }
                                                }
                                            }
                                            elsif ($match_tmp eq "yes")
                                            {
                                                $match_tmp = "no";
                                                $o += 11;
                                            }
                                            $o++;
                                        }
                                        
                                        if ($current_pos-$start_pos_ref > length($exb)*0.75)
                                        {
                                            $th = $start_pos_ref-$start_pos_read;
                                        }
                                        else
                                        {
                                            $no_match = "yes";
                                        }
                                    }
                                    if ($no_match ne "yes")
                                    {
                                        $d = '0';
                                        my $count_matches = '0';
                                        
                                        while ($d < length($exb))
                                        {
                                            my $pos_tmp = $d+$th+1;                                          
                                            if ($pos_tmp > 0 && $pos_tmp <= length($read_short_start_tempie_long))
                                            {
                                                if ($read_pair_tmp[$d] eq $read_short_start_tempie_long[$d+$th])
                                                {
                                                    my $count_tmp = $matches_read_short_start_long4_pos{$pos_tmp}+1;
                                                    $matches_read_short_start_long4_pos{$pos_tmp} = $count_tmp;
                                                    $count_matches++;
                                                }
                                                elsif ($read_pair_tmp[$d] eq "N")
                                                {
                                                }
                                                elsif ($read_short_start_tempie_long[$d+$th] eq ".")
                                                {
                                                }          
                                                else
                                                {
                                                    my $count_tmp = $matches_read_short_start_long4_neg{$pos_tmp}-1;
                                                    $matches_read_short_start_long4_neg{$pos_tmp} = $count_tmp;
                                                }
                                            }
                                            $d++  
                                        }
                                        if ($count_matches > length($exb)*0.9)
                                        {
                                            $is_a_match = "yes";
                                        }
                                    }  
                                }
                                
                                if ($is_a_match eq "yes")
                                {
                                    if ($y > $startprint2 && $count4_pair < 100)
                                    {
                                    }
                                    if (exists($extensions_yuyu{$exb0}))
                                    {
                                        push @extensions_before, $extensions_yuyu{$exb0};
                                        push @extensions_before4, $extensions_yuyu{$exb0};
                                    }
                                    $count4b++;
                                }
                                else
                                {
                                    $count4b_no++;
                                }
                            }
                            
                            print OUTPUT5 "\nREF__";
                            foreach my $nuc_tmp (@read_short_start_tempie_long)
                            {
                                print OUTPUT5 $nuc_tmp;
                            }
                            print OUTPUT5 "\nNEG1_";
                            my $corr = '0';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long1_neg)
                            {      
                                if ($matches_read_short_start_long1_neg{$pos_tmp} < 0)
                                {
                                    print OUTPUT5 $matches_read_short_start_long1_neg{$pos_tmp}."";
                                    $corr += length($matches_read_short_start_long1_neg{$pos_tmp})-1;
                                }
                                elsif ($corr > 0)
                                {
                                    $corr--;
                                }
                                else
                                {
                                    print OUTPUT5 "_";
                                }
                            }
                            print OUTPUT5 "\nNEG2_";
                            $corr = '0';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long2_neg)
                            {
                                if ($matches_read_short_start_long2_neg{$pos_tmp} < 0)
                                {
                                    print OUTPUT5 $matches_read_short_start_long2_neg{$pos_tmp}."";
                                    $corr += length($matches_read_short_start_long2_neg{$pos_tmp})-1;
                                }
                                elsif ($corr > 0)
                                {
                                    $corr--;
                                }
                                else
                                {
                                    print OUTPUT5 "_";
                                }
                            }
                            
                            my $twenty = '1';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long1_neg)
                            {
                                print OUTPUT5 $matches_read_short_start_long1_neg{$pos_tmp}."\t";  
                                if ($twenty eq '25')
                                {
                                    $twenty = '0';
                                    print OUTPUT5 "\n";
                                }
                                $twenty++;
                            }
                            print OUTPUT5 "\n\n";
                            $twenty = '1';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long1_neg)
                            {
                                print OUTPUT5 $matches_read_short_start_long1_pos{$pos_tmp}+$matches_read_short_start_long1_neg{$pos_tmp}."\t";
                                if ($matches_read_short_start_long1_neg{$pos_tmp} < '-1')
                                {
                                    if (($matches_read_short_start_long2_pos{$pos_tmp} > 0 || $matches_read_short_start_long3_pos{$pos_tmp} > 0 || $matches_read_short_start_long4_pos{$pos_tmp} > 0)
                                        && ($matches_read_short_start_long1_pos{$pos_tmp} eq '0' ||
                                        ($matches_read_short_start_long1_pos{$pos_tmp} < '5' && $matches_read_short_start_long1_neg{$pos_tmp} < $matches_read_short_start_long1_pos{$pos_tmp}*(-5))))
                                    {
                                        $count1b = '0';
                                    }
                                }
                                if ($twenty eq '25')
                                {
                                    $twenty = '0';
                                    print OUTPUT5 "\n";
                                }
                                $twenty++;
                            }
                            print OUTPUT5 "\n\n";
                            
                            $twenty = '1';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long2_neg)
                            {
                                print OUTPUT5 $matches_read_short_start_long2_neg{$pos_tmp}."\t";  
                                if ($twenty eq '25')
                                {
                                    $twenty = '0';
                                    print OUTPUT5 "\n";
                                }
                                $twenty++;
                            }
                            print OUTPUT5 "\n\n";
                            
                            $twenty = '1';
                            foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long2_neg)
                            {
                                print OUTPUT5 $matches_read_short_start_long2_pos{$pos_tmp}+$matches_read_short_start_long2_neg{$pos_tmp}."\t";
                                if ($matches_read_short_start_long2_neg{$pos_tmp} < '-1')
                                {
                                    if (($matches_read_short_start_long1_pos{$pos_tmp} > 0 || $matches_read_short_start_long3_pos{$pos_tmp} > 0 || $matches_read_short_start_long4_pos{$pos_tmp} > 0)
                                        && ($matches_read_short_start_long2_pos{$pos_tmp} eq '0' ||
                                        ($matches_read_short_start_long2_pos{$pos_tmp} < '5' && $matches_read_short_start_long2_neg{$pos_tmp} < $matches_read_short_start_long2_pos{$pos_tmp}*(-5))))
                                    {
                                        $count2b = '0';
                                    }
                                }
                                if ($twenty eq '25')
                                {
                                    $twenty = '0';
                                    print OUTPUT5 "\n";
                                }
                                $twenty++;
                            }
                            print OUTPUT5 "\n\n";
                            
                            if ($third_yuyu2 > 0)
                            {
                                $twenty = '1';
                                foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long3_neg)
                                {
                                    print OUTPUT5 $matches_read_short_start_long3_neg{$pos_tmp}."\t";  
                                    if ($twenty eq '25')
                                    {
                                        $twenty = '0';
                                        print OUTPUT5 "\n";
                                    }
                                    $twenty++;
                                }
                                print OUTPUT5 "\n\n";
                                
                                $twenty = '1';
                                foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long3_neg)
                                {
                                    print OUTPUT5 $matches_read_short_start_long3_pos{$pos_tmp}+$matches_read_short_start_long3_neg{$pos_tmp}."\t";
                                    if ($matches_read_short_start_long3_neg{$pos_tmp} < '-1')
                                    {
                                        if (($matches_read_short_start_long1_pos{$pos_tmp} > 0 || $matches_read_short_start_long2_pos{$pos_tmp} > 0 || $matches_read_short_start_long4_pos{$pos_tmp} > 0)
                                            && ($matches_read_short_start_long3_pos{$pos_tmp} eq '0' ||
                                            ($matches_read_short_start_long3_pos{$pos_tmp} < '5' && $matches_read_short_start_long3_neg{$pos_tmp} < $matches_read_short_start_long3_pos{$pos_tmp}*(-5))))
                                        {
                                            $count3b = '0';
                                        }
                                    }
                                    if ($twenty eq '25')
                                    {
                                        $twenty = '0';
                                        print OUTPUT5 "\n";
                                    }
                                    $twenty++;
                                }
                                print OUTPUT5 "\n\n";
                            }
                            
                            if ($fourth_yuyu2 > 0)
                            {
                                $twenty = '1';
                                foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long4_neg)
                                {
                                    print OUTPUT5 $matches_read_short_start_long4_neg{$pos_tmp}."\t";  
                                    if ($twenty eq '25')
                                    {
                                        $twenty = '0';
                                        print OUTPUT5 "\n";
                                    }
                                    $twenty++;
                                }
                                print OUTPUT5 "\n\n";
                                
                                $twenty = '1';
                                foreach my $pos_tmp (sort { $a <=> $b } keys %matches_read_short_start_long4_neg)
                                {
                                    print OUTPUT5 $matches_read_short_start_long4_pos{$pos_tmp}+$matches_read_short_start_long4_neg{$pos_tmp}."\t";
                                    if ($matches_read_short_start_long4_neg{$pos_tmp} < '-1')
                                    {
                                        if (($matches_read_short_start_long1_pos{$pos_tmp} > 0 || $matches_read_short_start_long2_pos{$pos_tmp} > 0 || $matches_read_short_start_long3_pos{$pos_tmp} > 0)
                                            && ($matches_read_short_start_long4_pos{$pos_tmp} eq '0' ||
                                            ($matches_read_short_start_long4_pos{$pos_tmp} < '5' && $matches_read_short_start_long4_neg{$pos_tmp} < $matches_read_short_start_long4_pos{$pos_tmp}*(-5))))
                                        {
                                            $count4b = '0';
                                        }
                                    }
                                    if ($twenty eq '25')
                                    {
                                        $twenty = '0';
                                        print OUTPUT5 "\n";
                                    }
                                    $twenty++;
                                }
                                print OUTPUT5 "\n\n";
                            }

                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $count1b." COUNT1B\n";
                                print OUTPUT5 $count2b." COUNT2B\n";
                                print OUTPUT5 $count3b." COUNT3B\n";
                                print OUTPUT5 $count4b." COUNT4B\n";
                            }
                            my $f = '7';
                            if ($SNR_check1 ne "" || $SNR_check2 ne "")
                            {
                                $f = '8';
                            }
                            if ($repetitive_detect_back ne "")
                            {
                                $f = '10';
                            }
                            if ($type eq "mito_plant")
                            {
                                $f = '10';
                            }
                            if ($type eq "mito_plant" && ($count1b+$count2b+$count3b+$count4b) > '25')
                            {
                                $f = '20';
                            }
                            my $dup = "";
                            my $r = '4';
                            if ($type eq "mito_plant" && ($count1b+$count2b+$count3b+$count4b) > $average_coverage_ext*4)
                            {
                                $dup = "yes";
                                $r = 6;
                            }
                            
                            $count1234b{'1'} = $count1b;
                            $count1234b{'2'} = $count2b;
                            $count1234b{'3'} = $count3b;
                            $count1234b{'4'} = $count4b;
                            
                            my $differenceb1 = "";
                            my $differenceb2 = "";
                            my $differenceb3 = "";
                            my $differenceb4 = "";
                            
                            foreach my $count1234b (keys %count1234b)
                            {   
                                if ($count1234b ne '1' && $count1234b{$count1234b} > 0 && $count1b > $f*$count1234b{$count1234b} && $differenceb1 ne "no")
                                {
                                    $differenceb1 = "yes";
                                }
                                elsif ($count1234b ne '1' && $count1234b{$count1234b} > 0 && $count1b <= $f*$count1234b{$count1234b})
                                {
                                    $differenceb1 = "no";
                                }
                                if ($count1234b ne '2' && $count1234b{$count1234b} > 0 && $count2b > $f*$count1234b{$count1234b} && $differenceb2 ne "no")
                                {
                                    $differenceb2 = "yes";
                                }
                                elsif ($count1234b ne '2' && $count1234b{$count1234b} > 0 && $count2b <= $f*$count1234b{$count1234b})
                                {
                                    $differenceb2 = "no";
                                }
                                if ($count1234b ne '3' && $count1234b{$count1234b} > 0 && $count3b > $f*$count1234b{$count1234b} && $differenceb3 ne "no")
                                {
                                    $differenceb3 = "yes";
                                }
                                elsif ($count1234b ne '3' && $count1234b{$count1234b} > 0 && $count3b <= $f*$count1234b{$count1234b})
                                {
                                    $differenceb3 = "no";
                                }
                                if ($count1234b ne '4' && $count1234b{$count1234b} > 0 && $count4b > $f*$count1234b{$count1234b} && $differenceb4 ne "no")
                                {
                                    $differenceb4 = "yes";
                                }
                                elsif ($count1234b ne '4' && $count1234b{$count1234b} > 0 && $count4b <= $f*$count1234b{$count1234b})
                                {
                                    $differenceb4 = "no";
                                }
                            }
                            
                            if (($count1b > 2 && ($count2b+$count3b+$count4b) eq '0') || ($differenceb1 eq "yes" && $differenceb2 eq "" && $differenceb3 eq "" && $differenceb4 eq "") && ($dup ne "yes" || ($count2b+$count3b+$count4b) < $average_coverage_ext/$r))
                            {
                                if (@extensions_before > 15000000000000 && $repetitive_detect_back2 eq "")
                                {
                                    $ext_before = "yes";
                                    @extensions_before = @extensions_before1;
                                    goto EXT_BEFORE_BACK;
                                }
                                $best_extension2 = "";
                                $best_extension3 = "";
                                $best_extension4 = "";
                                $best_extension = $best_extension1;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nREVERSE_DELETE SPLIT_BEFORE5\n\n";
                                }
                                delete $SNP_active_back{$id};
                                delete $before_back{$id};
                                delete $before_shorter_skip_back{$id};
                                if ($split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep_back eq "" && $repetitive_detect_back eq "")
                                {
                                    $split = "";
                                    $before_back = "yes";
                                    goto REFERENCE_BACK;
                                }
                                goto AFTER_EXT_BACK;
                            }
                            elsif (($count2b > 2 && ($count1b+$count3b+$count4b) eq '0') || ($differenceb2 eq "yes" && $differenceb1 eq "" && $differenceb3 eq "" && $differenceb4 eq "") && ($dup ne "yes" || ($count1b+$count3b+$count4b) < $average_coverage_ext/$r))
                            {
                                if (@extensions_before > 15000000000000 && $repetitive_detect_back2 eq "")
                                {
                                    $ext_before = "yes";
                                    @extensions_before = @extensions_before2;
                                    goto EXT_BEFORE_BACK;
                                }
                                $best_extension1 = "";
                                $best_extension3 = "";
                                $best_extension4 = "";
                                $best_extension = $best_extension2;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nREVERSE_DELETE SPLIT_BEFORE6\n\n";
                                }
                                delete $SNP_active_back{$id};
                                delete $before_back{$id};
                                delete $before_shorter_skip_back{$id};
                                if ($split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep_back eq "" && $repetitive_detect_back eq "")
                                {
                                    $split = "";
                                    $before_back = "yes";
                                    goto REFERENCE_BACK;
                                }
                                goto AFTER_EXT_BACK;
                            }
                            elsif (($count3b > 2 && ($count1b+$count2b+$count4b) eq '0') || ($differenceb3 eq "yes" && $differenceb2 eq "" && $differenceb1 eq "" && $differenceb4 eq "") && ($dup ne "yes" || ($count2b+$count1b+$count4b) < $average_coverage_ext/$r))
                            {
                                if (@extensions_before > 15000000000000 && $repetitive_detect_back2 eq "")
                                {
                                    $ext_before = "yes";
                                    @extensions_before = @extensions_before3;
                                    goto EXT_BEFORE_BACK;
                                }
                                $best_extension1 = "";
                                $best_extension2 = "";
                                $best_extension4 = "";
                                $best_extension = $best_extension3;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nREVERSE_DELETE SPLIT_BEFORE7\n\n";
                                }
                                delete $SNP_active_back{$id};
                                delete $before_back{$id};
                                delete $before_shorter_skip_back{$id};
                                if ($split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep_back eq "" && $repetitive_detect_back eq "")
                                {
                                    $split = "";
                                    $before_back = "yes";
                                    goto REFERENCE_BACK;
                                }
                                goto AFTER_EXT_BACK;
                            }
                            elsif (($count4b > 2 && ($count1b+$count2b+$count3b) eq '0') || ($differenceb4 eq "yes" && $differenceb2 eq "" && $differenceb3 eq "" && $differenceb1 eq "") && ($dup ne "yes" || ($count2b+$count3b+$count1b) < $average_coverage_ext/$r))
                            {
                                if (@extensions_before > 150000000000000 && $repetitive_detect_back2 eq "")
                                {
                                    $ext_before = "yes";
                                    @extensions_before = @extensions_before4;
                                    goto EXT_BEFORE_BACK;
                                }
                                $best_extension1 = "";
                                $best_extension3 = "";
                                $best_extension2 = "";
                                $best_extension = $best_extension4;
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nREVERSE_DELETE SPLIT_BEFORE8\n\n";
                                }
                                delete $SNP_active_back{$id};
                                delete $before_back{$id};
                                delete $before_shorter_skip_back{$id};
                                if ($split_forward eq "yes" && ($variance_detection ne "" || $heteroplasmy ne "") && $jump_rep_back eq "" && $repetitive_detect_back eq "")
                                {
                                    $split = "";
                                    $before_back = "yes";
                                    goto REFERENCE_BACK;
                                }
                                goto AFTER_EXT_BACK;
                            }
                            elsif(($count1b+$count2b+$count3b+$count4b) < 10 && $overhang < $read_length-($overlap*1.5) && $before_shorter_skip_back ne "yes" && $skip_overhang ne "yes")
                            {
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nMAKE BEFORE SHORTER3\n\n";
                                }
                                $before_shorter = "yes";
                                goto BEFORE_BACK;
                            }
                            elsif (($count1b+$count2b+$count3b+$count4b) > 9 && $extensions_before ne "yes" && $repetitive_detect_back2 ne "yes" && $before_shorter_skip_back ne "yes" && $heteroplasmy eq "" && (length($best_extension1) < 7 || length($best_extension2) < 7) && $hp_seed_assemble eq "")
                            {
                                $l = 0;
                                my $ll1 = '0';
                                my $ll2 = '0';
                                if ($count1b ne 0)
                                { 
                                    foreach my $ext1 (@extensions_before1)
                                    {
                                        if (length($ext1) > $ll1)
                                        {
                                            $ll1 = length($ext1);
                                        }
                                    }
                                    $ll = $ll1;
                                }
                                if ($count2b ne 0)
                                { 
                                    foreach my $ext2 (@extensions_before2)
                                    {
                                        if (length($ext2) > $ll2)
                                        {
                                            $ll2 = length($ext2);
                                        }
                                    }
                                    if ($ll2 < $ll1)
                                    {
                                        $ll = $ll2;
                                    } 
                                }
                                $best_extension = "";
                                $SNP = "";
                                $ext = '0';
                                foreach my $ext_b (@extensions_before)
                                {
                                    $ext++;
                                    $extensionsb{$ext} = $ext_b;
                                }
                                $extensions_before = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 "\nEXTENSIONS FROM BEFORE BACK\n\n";
                                }
                                $best_extension_old1 = $best_extension1;
                                $best_extension_old2 = $best_extension2;
                                $best_extension_old3 = $best_extension3;
                                $best_extension_old4 = $best_extension4;
                                $SNP_active_back = "yes";
                                $before_shorter_skip_back{$id} = "yes";
                                $best_extension1 = "";
                                $best_extension2 = "";
                                $best_extension3 = "";
                                $best_extension4 = "";
                                $split = "";
                                undef %extensionsb_group1;
                                undef %extensionsb_group2;
                                undef %extensionsb_group3;
                                undef %extensionsb_group4;
                                goto NUCLEO_BACK;
                            }         
                        }
                        elsif (@extensions_before > 10 && $jump_rep_back ne "yes" && (length($best_extension1) < 7 || length($best_extension2) < 7))
                        {
                            $ext_before = "yes";
                        }
EXT_BEFORE_BACK:        if ($ext_before eq "yes" && $hp_seed_assemble eq "")
                        {
                            $l = 0;
                            $best_extension = "";
                            $SNP = "";
                            $ext = '0';
                            foreach my $ext_b (@extensions_before)
                            {
                                $ext++;
                                $extensionsb{$ext} = $ext_b;
                                print OUTPUT5 $ext_b." EXT\n";
                            }
                            $extensions_before = "yes";
                            if ($y > $startprint2)
                            {
                                print OUTPUT5 $ext." EXTENSIONS FROM BEFORE BACK2\n\n";
                            }
                            
                            $best_extension_old1 = $best_extension1;
                            $best_extension_old2 = $best_extension2;
                            $best_extension_old3 = $best_extension3;
                            $best_extension_old4 = $best_extension4;
                            $SNP_active_back = "yes";
                            $before_shorter_skip_back{$id} = "yes";
                            $best_extension1 = "";
                            $best_extension2 = "";
                            $best_extension3 = "";
                            $best_extension4 = "";
                            $split = "";
                            undef %extensionsb_group1;
                            undef %extensionsb_group2;
                            undef %extensionsb_group3;
                            undef %extensionsb_group4;
                            goto NUCLEO_BACK;
                        }    
                        $before_back{$id} = "yes";
                        $best_extension = "";
                        $read_new = $read_new1;
                        $before_shorter_skip_back{$id} = "yes";
                        if ($before_shorter_skip_back eq "yes")
                        {
                            $before_back{$id} = "yes";
                        }
                        
                        if ($count_split > 2)
                        {
                            my $tmp = '0';
                            if ($first_yuyu2 eq '0' || (($count1b_tmp+$count2b_tmp+$count3b_tmp+$count4b_tmp) > 4 && $count1b_tmp eq '0'))
                            {
                                $yuyu_option_back{$id.$firstSNP_max[$tmp]} = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $firstSNP_max[$tmp]." FIRST_YUYU\n";
                                }
                            }
                            $tmp++;
                            if ($second_yuyu2 eq '0' || (($count1b_tmp+$count2b_tmp+$count3b_tmp+$count4b_tmp) > 4 && $count2b_tmp eq '0'))
                            {
                                $yuyu_option_back{$id.$firstSNP_max[$tmp]} = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $firstSNP_max[$tmp]." SECOND_YUYU\n";
                                }
                            }
                            $tmp++;
                            if ($third_yuyu2 eq '0' || (($count1b_tmp+$count2b_tmp+$count3b_tmp+$count4b_tmp) > 4 && $count3b_tmp eq '0'))
                            {
                                $yuyu_option_back{$id.$firstSNP_max[$tmp]} = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $firstSNP_max[$tmp]." THIRD_YUYU\n";
                                }
                            }
                            $tmp++;
                            if ($fourth_yuyu2 eq '0' || (($count1b_tmp+$count2b_tmp+$count3b_tmp+$count4b_tmp) > 4 && $count4b_tmp eq '0'))
                            {
                                $yuyu_option_back{$id.$firstSNP_max[$tmp]} = "yes";
                                if ($y > $startprint2)
                                {
                                    print OUTPUT5 $firstSNP_max[$tmp]." FOURTH_YUYU\n";
                                }
                            }
                        }
                    }
                }
              
                my $count_best_ext = '0';
                if ($best_extension1 ne "")
                {
                    $count_best_ext++;
                }
                if ($best_extension2 ne "")
                {
                    $count_best_ext++;
                }
                if ($best_extension3 ne "")
                {
                    $count_best_ext++;
                }
                if ($best_extension4 ne "")
                {
                    $count_best_ext++;
                }
                if ($y > $startprint2)
                {
                    print OUTPUT5 $count_best_ext." COUNT_BEST_EXT\n";
                }
                if ($SNP_active_back eq "" && $count_best_ext > 1 )
                {
                    $best_extension = "";
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "SNP_ACTIVE_BACK\n";
                    }
                    $SNP_active_back{$id} = "yes";

                    $read_new = $read_new1;
                    goto FINISH;
                }
                elsif ($count_best_ext < 2 || $deletion_back ne "")
                {
                    goto AFTER_EXT_BACK;
                }
                else
                {
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 "ELSE\n";
                    }
                    $noback{$id} = "stop";
                    $noback = "stop";
                    $read_new = $read_new1;
                    $best_extension = "";
                }
            }
            else
            {                               
                if ($y > $startprint2)
                {
                    print OUTPUT5 reverse($best_extension)." BEST_EXTENSION_BACK\n\n";
                }
                $best_extension_back_prev{$id} = $best_extension; 
            }  
AFTER_EXT_BACK:

                                            chomp $best_extension;
                                            
                                            my $vk2 = '0';
                                            
                                            if ($SNR_read_back eq "" && length($best_extension) > 2 && $heteroplasmy eq "")
                                            {
                                                my @dot2 = split //, $best_extension;
                                                my $ut2 = length($best_extension);
                                                
                                                while ($dot2[$ut2-1] eq "." || $dot2[$ut2-1] eq "*")
                                                {              
                                                    if ($dot2[$ut2-1] eq "*")
                                                    {
                                                        chop $best_extension;
                                                        chop $best_extension;
                                                        $vk2++;
                                                        $vk2++;
                                                        $ut2--;
                                                        $ut2--;
                                                    }
                                                    else
                                                    {                                                     
                                                        chop $best_extension;
                                                        $vk2++;
                                                        $ut2--;
                                                    }
                                                }
                                            }
 
                                            if ($noback ne "stop" && ($best_extension ne "" && $best_extension ne " "))
                                            {                                                                               
                                                $read_new = reverse($best_extension).$read_new1;                                     
                                                $position_back += length($best_extension);                                        
                                                $position_back -= $vk2;
                                                                               
                                                my $position_back_tmp = $position_back{$id};
                                                delete $position_back{$id};
                                                $position_back{$id} = $position_back;
                                                $position_back = $position_back_tmp;
                                                
                                                if (exists($large_variance_back{$id}))
                                                {
                                                    $NUMT_back{$id} = $NUMT_back{$id}+length($best_extension);
                                                }
                                                
                                                if (exists($last_ref_seq_back{$id}) && $split eq "" && $ref_check_back ne "" && $save_seq_ref_back ne "no2")
                                                {
                                                    my $seq_tmp = $last_ref_seq_back{$id};
                                                    my $extra_seq = substr $ref_check_back, 0, length($best_extension);
                                                    $last_ref_seq_back{$id} = reverse($extra_seq).$seq_tmp;
                                                    if (exists($last_ref_pos_back{$id}))
                                                    {
                                                        $last_ref_pos_back{$id} = $last_ref_pos_back{$id}-length($extra_seq);
                                                    }
                                                    
                                                }
                                                if (exists($large_variance_back{$id}) && $split eq "")
                                                {
                                                    $large_variance_length_back{$id} = $large_variance_length_back{$id}+length($best_extension);
                                                }
                                                
                                                $best_extension = "";
                                                delete $regex_back{$id};
                                                delete $last_chance_back{$id};
                                                delete $SNR_critical_back{$id};
                                                delete $SNP_active_back{$id};
                                                if ($SNR_read_back ne "" && $last_chance_back eq "yes")
                                                {
                                                    $last_chance_back{$id} = "yes";
                                                }
                                                else
                                                {
                                                    delete $last_chance_back{$id};
                                                }
                                                if ($split_forward eq "" || $extensions_before ne "")
                                                {
                                                    delete $before_back{$id};
                                                    delete $before_shorter_skip_back{$id};
                                                }   
                                                
                                                $id_test = $id;
                                                
                                                if ($split eq "")
                                                {
                                                    delete $yuyu_option_back{$id."A"};
                                                    delete $yuyu_option_back{$id."C"};
                                                    delete $yuyu_option_back{$id."T"};
                                                    delete $yuyu_option_back{$id."G"};
                                                    delete $before_shorter_skip_back{$id};
                                                    $need_longer_ext_back = "";
                                                }
                                                if ($hp_seed_assemble_last_chance_back eq "yes" && length($read) < $insert_size*1.6 && $split eq "")
                                                {
                                                    $hp_seed_assemble_last_chance_back = "";
                                                }
                                                if ($split eq "")
                                                {
                                                    foreach my $add_read2 (keys %extensionsb)
                                                    {
                                                        my $add_read = substr $add_read2, 0, -1;
                                                        $count_reads{$add_read} = undef;
                                                    }
                                                }
                                            }
                                            elsif ($SNR_critical_back eq "yes1")
                                            {
                                                $read_new = $read_new1;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "OPTION_CRITICAL_BACK\n";
                                                }
                                            }
                                            elsif ($use_regex_back ne "yes" && ($SNP_active_back ne "yes" || $split_forward eq "") && $repetitive_detect_back eq "" && $last_chance_back ne "yes" && $noback ne "stop")
                                            {                                              
                                                delete $regex_back{$id};
                                                if ($split_forward eq "")
                                                {
                                                    $regex_back{$id} = "yes";
                                                }
                                                elsif ($split_forward ne "")
                                                {
                                                    $SNP_active_back{$id} = "yes";
                                                }
                                                $read_new = $read_new1;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "2B\n";
                                                }
                                            }
                                            elsif ($use_regex_back ne "yes" && $last_chance_back ne "yes" && $SNP_active_back eq "")
                                            {
                                                $SNP_active_back{$id} = "yes";
                                                $read_new = $read_new1;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "3B\n";
                                                }
                                            }
                                            elsif (($use_regex_back eq "yes" || $repetitive_detect_back ne "") && $last_chance_back ne "yes" && $noback ne "stop" && $AT_rich_before_back eq "")
                                            {
                                                $read_new = $read_new1;
                                                delete $last_chance_back{$id};
                                                $last_chance_back{$id} = "yes";
                                                delete $regex_back{$id};
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "5B\n";
                                                }
                                            }
                                            elsif ($last_chance_back eq "yesssssssssssssssssssssssssssssssssss" && $SNR_read_back ne "" && $noback ne "stop")
                                            {
                                                $read_new = $read_new1;
                                                delete $last_chance_back{$id};
                                                $last_chance_back{$id} = "yes";
                                                $last_chance = "";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "6B\n";
                                                }
                                            }
                                            elsif ($last_chance_back eq "yes" && $noback ne "stop" && $use_regex_back ne "yes" && $hp_seed_assemble eq "")
                                            {
                                                $read_new = $read_new1;
                                                delete $last_chance_back{$id};
                                                $last_chance_back{$id} = "yes";
                                                delete $regex_back{$id};
                                                $regex_back{$id} = "yes";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "7B\n";
                                                }
                                            }
                                            elsif (length($read) < $insert_size+100 && $hp_seed_assemble ne "" && $best_extension_forward ne "")
                                            {
                                                delete $last_chance_back{$id};
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "FINISH_HP_BACK\n";
                                                }
                                            }
                                            elsif (($last_chance_back eq "yes" || $AT_rich_before_back ne "") && $noforward ne "stop" && $noback ne "stop" && $use_regex_back eq "yes")
                                            {
                                                $read_new = $read_new1;
                                                delete $last_chance_back{$id};
                                                $noback = "stop";
                                                $noback{$id} = "stop";
                                                delete $regex_back{$id};
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "8B\n";
                                                }
                                            }
                                            elsif (exists($old_id{$id}) && $noforward eq "stop")
                                            {
                                                $merge_now = "yes2";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "8B_MERGE\n";
                                                }
                                                goto MERGE;
                                            }
                                            elsif (exists($seed_split{$id}))
                                            {
                                                delete $seed{$id};
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "9B\n";
                                                }
                                                my $old_rep_old_check = "";
                                                if (exists ($old_rep_old{$id}))
                                                {
                                                    $old_rep_old_check = "yes";
                                                }
                                                if (length($read) > 250 && $old_rep_old_check eq "")
                                                {
                                                    my $check_id = $id;
                                                    if ($id =~ m/(.*_|)(\d+)$/)
                                                    {
                                                        $check_id = $2;
                                                    }
                                                    if ($contig_num eq '1')
                                                    {       
                                                        $contigs{$contig_num."+".$check_id} = $read;
                                                        contig_start ($read); 
                                                    }
                                                    else
                                                    {
                                                       $contigs{$contig_num."+".$check_id} = $read; 
                                                    }
                                                    $contig_num++;
                                                    $seed_old{$id} = $read;
                                                }
                                                if ($y > $startprint2)
                                                {                                                                                 
                                                    print OUTPUT5 ">".$id."\n";
                                                    print OUTPUT5 $read."\n";
                                                }
                                                goto SEED;
                                            }
                                            else
                                            {
                                                $noback = "stop";
                                                $noback{$id} = "stop";
                                                print OUTPUT5 "10B\n";
                                            }                                  
        }
        elsif ($last_chance_back ne "yes" && $noback ne "stop" && $AT_rich_before_back eq "")
        {
            $read_new = $read_new1;
            delete $last_chance_back{$id};
            $last_chance_back{$id} = "yes";
            delete $regex_back{$id};
            if ($y > $startprint2)
            {
                print OUTPUT5 "5Bb\n";
            }
        }
FINISH:
        if ($read_end eq $read_end_stuck{$id} && $noforward eq "")
        {
            $read_end_stuck_count{$id} = $read_end_stuck_count{$id}+1;
            if ($read_end_stuck_count{$id} > 8)
            {
                $noforward{$id} = "stop";
                print OUTPUT5 "ASSEMBLY_STUCK_READ_END_COUNT\n";
            }
        }
        else
        {
            $read_end_stuck_count{$id} = '1';
        }
        if ($read_start eq $read_start_stuck{$id} && $noback eq "")
        {
            $read_start_stuck_count{$id} = $read_start_stuck_count{$id}+1;
            if ($read_end_stuck_count{$id} > 5)
            {
                $noback{$id} = "stop";
            }
        }
        else
        {
            $read_start_stuck_count{$id} = '1';
        }
        $read_end_stuck{$id} = $read_end;
        $read_start_stuck{$id} = $read_start;
                                            if ($ref_skip_before_back eq "yes")
                                            {
                                                if (exists($last_ref_seq_back{$id}) && $split eq "")
                                                {
                                                    my $seq_tmp = $last_ref_seq_back{$id};
                                                    $last_ref_seq_back{$id} = reverse($best_extension).$seq_tmp;
                                                    if (exists($last_ref_pos_back{$id}))
                                                    {
                                                        $last_ref_pos_back{$id} = $last_ref_pos_back{$id}-length($best_extension);
                                                    }
                                                }
                                                if (exists($large_variance_back{$id}) && $split eq "")
                                                {
                                                    $large_variance_length_back{$id} = $large_variance_length_back{$id}+length($best_extension);
                                                }
                                            }
                                            
                                            my $count_seed = '0';
                                            foreach my $count_seed2 (keys %seed)
                                            {
                                                $count_seed++;
                                            }
                                            if ($y > $startprint2)
                                            {
                                                if ($noback ne "")
                                                {
                                                    print OUTPUT5 $noback." NOBACK\n";
                                                }
                                                if ($noforward ne "")
                                                {
                                                    print OUTPUT5 $noforward." NOFORWARD\n";
                                                }
                                                if ($last_chance ne "")
                                                {
                                                    print OUTPUT5 $last_chance." LASTCHANCE\n";
                                                }
                                                if ($use_regex_back ne "")
                                                {
                                                    print OUTPUT5 $use_regex_back." REGEX_BACK\n";
                                                }
                                                if ($last_chance_back ne "")
                                                {
                                                    print OUTPUT5 $last_chance_back." LASTCHANCE_BACK\n";
                                                }
                                                print OUTPUT5 $count_seed." COUNTSEED\n";
                                            }
                                            if ($position+$position_back > $no_hp_one_turn)
                                            {
                                                $no_hp_one_turn = "";
                                            }
                                            if ($position > $no_hp_one_turn2)
                                            {
                                                $no_hp_one_turn2 = "";
                                            }
                                            if ($position_back > $no_hp_one_turn2_back)
                                            {
                                                $no_hp_one_turn2_back = "";
                                            }
                                            my $cut_forward_test = "";
FINISH_HP:                                            
                                            if ($merge ne "yes" && $reference_next_seed ne "yes" && $circle eq "" && (($noback ne "stop" || ($noforward ne "stop" && $delete_first ne "yes2"))) && ($AT_rich ne "yes" || $noback ne "stop") && $bad_read eq "")
                                            {
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "FINISH2\n";
                                                }
                                            }
                                            elsif ($merge ne "yes" && $reference_next_seed ne "yes" && $circle eq "" && $AT_rich ne "yes" && $bad_read eq "" && $delete_first eq "yes2" && $last_chance ne "yes" && $SNR_next_seed ne "yes")
                                            {
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;
                                                delete $last_chance{$id};
                                                $last_chance{$id} = "yes";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "FINISH3\n";
                                                }
                                            }
                                            elsif ($hp_back ne "" && $position_back eq '0' && $hp_back ne "yes2")
                                            {
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;
                                                $noforward{$id} = "stop";
                                                $noforward = "stop";
                                                delete $noback{$id};
                                                $noback = "";
                                                $hp_back = "yes2";

                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "FINISH_HP_BACK\n";
                                                }
                                            }
                                            elsif ($position < $insert_size && $hp_seed_assemble eq "yes")
                                            {
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;
                                                delete $last_chance{$id};
                                                $last_chance{$id} = "yes";
                                                if ($noback_HP ne "yes")
                                                {
                                                    delete $noback{$id};
                                                }
                                                $hp_seed_assemble = "yes2";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "FINISH_HP\n";
                                                }
                                            }
                                            elsif ($hp_seed_assemble ne "" && $hp_seed_assemble_last_chance_back eq "" && $hp_seed_assemble_last_chance_forward eq "" && ($noback_HP eq "" || $noforward eq ""))
                                            {
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;
                                                delete $last_chance{$id};
                                                delete $last_chance_back{$id};
                                                if ($noback_HP ne "yes")
                                                {
                                                    delete $noback{$id};
                                                    $hp_seed_assemble_last_chance_back = "yes";
                                                }
                                                if ($noforward_HP ne "yes")
                                                {
                                                    delete $noforward{$id};
                                                    $hp_seed_assemble_last_chance_forward = "yes";
                                                }
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "FINISH_HP_LAST\n";
                                                }
                                            }
                                            elsif ($hp_seed_assemble ne "" && $hp_cut_forward eq "" && $cut_forward_test eq "" && length($hp_seed)+50 > $position && ($noback_HP eq "" || $noforward eq "")
                                                   && $NUMT eq "" && $NUMT_back eq "")
                                            {
                                                foreach my $SNPs_tmp (sort {$b <=> $a} keys %SNPs)
                                                {
                                                    my $length_to_remove = $position-$SNPs_tmp-2;
                                                    if ($length_to_remove > 0 && length($read)-$length_to_remove > $overlap+15)
                                                    {
                                                        substr $read_new, -$length_to_remove, $length_to_remove, "";
                                                        $position -= $length_to_remove;
                                                        $position{$id} = $position;
                                                    }
                                                    elsif ($hp_cut_back eq "yes" || $position_back > 50)
                                                    {
                                                        delete $seed{$id};     
                                                        goto HP_END;
                                                    }
                                                    else
                                                    {
                                                        $cut_forward_test = "yes";
                                                        goto FINISH_HP;
                                                    }
                                                    last;
                                                }
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;
                                                delete $last_chance{$id};
                                                delete $last_chance_back{$id};
                                                delete $last_ref_seq_forward{$id};
                                                delete $last_ref_pos_forward{$id};
                                                delete $large_variance_forward{$id};
                                                if ($noback_HP ne "yes")
                                                {
                                                    delete $noback{$id};
                                                    $hp_seed_assemble_last_chance_back = "";
                                                }
                                                if ($noforward_HP ne "yes")
                                                {
                                                    delete $noforward{$id};
                                                    $hp_seed_assemble_last_chance_forward = "";
                                                }
                                                $hp_cut_forward = "yes";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "CUT_FORWARD\n";
                                                }
                                            }
                                            elsif ($hp_seed_assemble ne "" && $hp_cut_back eq "" && $position_back < 50 && ($noback_HP eq "" || $noforward eq "")
                                                   && $NUMT eq "" && $NUMT_back eq "")
                                            {
                                                foreach my $SNPs_tmp (sort {$a <=> $b} keys %SNPs)
                                                {
                                                    my $length_to_remove = $position_back+$SNPs_tmp-3;
                                                    if ($length_to_remove > 0 && length($read)-$length_to_remove > $overlap+15 && $length_to_remove < $read_length*0.8)
                                                    {
                                                        substr $read_new, 0, $length_to_remove, "";
                                                        $position_back -= $length_to_remove;
                                                        $position_back{$id} = $position_back;
                                                    }
                                                    else
                                                    {
                                                        delete $seed{$id};     
                                                        goto HP_END;
                                                    }
                                                    last;
                                                }
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;
                                                delete $last_chance{$id};
                                                delete $last_chance_back{$id};
                                                delete $last_ref_seq_back{$id};
                                                delete $last_ref_pos_back{$id};
                                                if ($noback_HP ne "yes")
                                                {
                                                    delete $noback{$id};
                                                    $hp_seed_assemble_last_chance_back = "";
                                                }
                                                if ($noforward_HP ne "yes")
                                                {
                                                    delete $noforward{$id};
                                                    $hp_seed_assemble_last_chance_forward = "";
                                                }
                                                $hp_cut_back = "yes";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "CUT_BACK\n";
                                                }
                                            }
                                            elsif ($no_next_seed ne "yes" && $contig_num eq '1' && exists($old_id{$id}) && (($SNR_next_seed eq "yes" && ($last_chance_back eq "yes" || $noback eq "stop")) || ($nosecond eq "" && $CP_check ne "yes" && length($read) > $read_length+150 && $circle eq "" && (($last_chance eq "yes" || $noforward eq "stop") && ($last_chance_back eq "yes" || $noback eq "stop")) || ($AT_rich eq "yes" && $count_seed ne "0") || ($bad_read ne "" && $count_seed ne "0"))))
                                            {
                                                contig_start ($seed_old{$old_id{$id}});                                       
                                                $merge_now = "yes2";
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "MERGE NOW\n";
                                                }
                                                goto MERGE;
                                            }
                                            elsif (exists($seed_split{$id}))
                                            {
                                                delete $seed{$id};
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "9BBB\n";
                                                }
                                                my $old_rep_old_check = "";
                                                if (exists ($old_rep_old{$id}))
                                                {
                                                    $old_rep_old_check = "yes";
                                                }
                                                if (length($read) > 250 && $old_rep_old_check eq "")
                                                {
                                                    my $check_id = $id;
                                                    if ($id =~ m/(.*_|)(\d+)$/)
                                                    {
                                                        $check_id = $2;
                                                    }
                                                    if ($contig_num eq '1')
                                                    {       
                                                        $contigs{$contig_num."+".$check_id} = $read;
                                                        contig_start ($read);       
                                                    }
                                                    else
                                                    {
                                                       $contigs{$contig_num."+".$check_id} = $read; 
                                                    }
                                                    $contig_num++;
                                                    $seed_old{$id} = $read;
                                                }
                                                if ($y > $startprint2)
                                                {                                                                                 
                                                    print OUTPUT5 ">".$id."\n";
                                                    print OUTPUT5 $read."\n";
                                                }
                                                goto SEED;
                                            }
                                            elsif ($heteroplasmy ne "" && $hp_seed_assemble eq "" && $no_hp_one_turn eq "")
                                            {
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;
                                                if ($hp_back ne "")
                                                {
                                                    delete $noback{$id};
                                                }
                                                else
                                                {
                                                    delete $noforward{$id};
                                                }
                                                $no_hp_one_turn = $position+$position_back;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "NO_HP_ONE_TURN\n";
                                                }
                                            }
                                            elsif ($heteroplasmy ne "" && $hp_seed_assemble ne "" && $position-$last_SNP_hp < ($insert_size+($insert_size*0.2)) && $no_hp_one_turn2 eq "" && $PCR_free ne "")
                                            {
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;

                                                delete $noforward{$id};

                                                $no_hp_one_turn2 = $position;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "NO_HP_ONE_TURN2\n";
                                                }
                                            }
                                            elsif ($heteroplasmy ne "" && $hp_seed_assemble ne "" && $position_back+$last_SNP_hp < ($insert_size+($insert_size*0.2)) && $no_hp_one_turn2_back eq "" && $PCR_free ne "")
                                            {
                                                delete $seed{$id};                                         
                                                $seed{$id} = $read_new;

                                                delete $noback{$id};

                                                $no_hp_one_turn2_back = $position_back;
                                                if ($y > $startprint2)
                                                {
                                                    print OUTPUT5 "NO_HP_ONE_TURN2_BACK\n";
                                                }
                                            }
                                            elsif ($heteroplasmy eq "" && $no_next_seed ne "yes" && (($SNR_next_seed eq "yes" && ($last_chance_back eq "yes" || $noback eq "stop")) ||
                                            ($nosecond eq "" && $CP_check ne "yes" && length($read) > $read_length+150 && $circle eq "" && (($last_chance eq "yes" || $noforward eq "stop")
                                            && ($last_chance_back eq "yes" || $noback eq "stop")) || ($AT_rich eq "yes" && $count_seed ne "0") || ($bad_read ne "" && $count_seed ne "0"))))
                                            {
                                                my $id_original;
                                                if ($id_original eq "")
                                                {
                                                    $id_original = $id;
                                                }
                                                if ($bad_read ne "")
                                                {
                                                    $read = $seed_old{$id_old};
                                                }
                                                else
                                                {
                                                    if ($y > $startprint2)
                                                    {
                                                        print OUTPUT5 ">".$id."\n";
                                                        print OUTPUT5 $read."\n";
                                                    }
                                                    my $lastbit_contig = substr $read, -20;
                                                    $lastbit_contig =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                    
                                                    if (length($read) > $read_length+70 && ($lastbit_contig_prev !~ m/.*.$lastbit_contig.*/ || length($read) > $read_length+300))
                                                    {
                                                        print OUTPUT6 ">".$id."\n";
                                                        print OUTPUT6 $read."\n";
                                                        $lastbit_contig_prev = substr $read, -100;
                                                        $lastbit_contig_prev =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                                                    }                                                 

                                                    if (exists $old_id{$id})
                                                    {
                                                        if (exists($contigs_id{$old_id{$id}}) && length($seed_old{$old_id{$id}}) > $read_length+30)
                                                        {
                                                        }
                                                        else
                                                        {  
                                                            print OUTPUT5 $seed_old{$old_id{$id}}." SEED_OLD_CONTIG\n";
                                                            if ($contig_num eq '1')
                                                            {
                                                                $contigs{$contig_num."+".$id} = $seed_old{$old_id{$id}};
                                                                contig_start ($seed_old{$old_id{$id}});  
                                                            }
                                                            else
                                                            {
                                                                $contigs{$contig_num."+".$id} = $seed_old{$old_id{$id}};
                                                            }
                                                            $contig_num++;
                                                        }
                                                        delete $old_id{$id};
                                                    }
                                                    $seed_old{$id} = $read;
                                                    $id_old = $id;
                                                }                                     
                                                
                                                delete $seed{$id};
                                                if (exists($seed_old{$id}))
                                                {
                                                    $seed_old{$id} = $read;
                                                }
                                                
                                                my $SNR_skip = "yes";
                                                my $xy = -($overlap+3);
                                                my $tt = '-200';
                                                my $second_seed = "";                                           
                                                my $u = '9';
                                                my $skip;
                                                while ($SNR_skip eq "yes")
                                                { 
                                                    my $new_seed_part_tmp = substr $read, -$u, 9;
                                                    $new_seed_part_tmp =~ tr/N|K|R|Y|S|W|M|B|D|H|V|\./\./;
                                                    my $SNR_checkA = $new_seed_part_tmp =~ tr/A\./A\./;
                                                    my $SNR_checkC = $new_seed_part_tmp =~ tr/C\./C\./;
                                                    my $SNR_checkT = $new_seed_part_tmp =~ tr/T\./T\./;
                                                    my $SNR_checkG = $new_seed_part_tmp =~ tr/G\./G\./;                                      
                                                    
                                                    if ($SNR_checkA > 4 || $SNR_checkC > 4 || $SNR_checkG > 4 || $SNR_checkT > 4)
                                                    {
                                                        $SNR_skip = "yes";
                                                        $u += 9;
                                                    }
                                                    elsif ($skip eq "")
                                                    {
                                                        $skip = "yes";
                                                        $SNR_skip = "yes";
                                                        $u += 9;
                                                    }
                                                    else
                                                    {
                                                        $SNR_skip = "";
                                                    }
                                                }
                    my $middle_next = '0';
                    $u -= 9;
                    
NEXT1:
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $u." U\n";
                    }
                    my %extensions_yuyu_next;
                    my %before_pair;
                    undef %extensions_yuyu_next;
                    undef %before_pair;
                    my $overhang = 40;
                    my $before_split = substr $read_short_end2, -($read_length-$left-1)-$u-$overhang, $overhang+$overlap+$u;
                    my $star3 = '0';
                    my $next_seed;
                    if ($containX_short_end2 > 0)
                    {
                        my $before_split2 = substr $read_short_end2, -($read_length-$left-1)-$u-$overhang, $overhang+$overlap+$u;
                        $star3 = $before_split2 =~ tr/\*/\*/;
                        if ($star3 > 0)
                        {
                            $before_split = substr $read_short_end2, -($read_length-$left-1+($star3*2))-$u-$overhang, $overhang+$overlap+$u+($star3*2);
                        }
                    }
                    
                    if ($reference_next_seed eq "yes" && $next_seed_ref ne "")
                    {
                        $before_split = $next_seed_ref;
                    }
                    
                    my $s = '0';
                    while ($s <= length($before_split)-$overlap)
                    {
                        my $line_tmp = substr $before_split, $s, $overlap;
                        if ($star3 > 0)
                        {
                            my $star = $line_tmp =~ tr/\*/\*/;
                            $line_tmp = substr $before_split, $s, $overlap+($star*2);
                            my $star2 = $line_tmp =~ tr/\*/\*/;                                                
                            while ($star2 > $star)
                            {
                                $line_tmp = substr $before_split, $s, $overlap+($star*2)+(($star2-$star)*2);
                                $star = $star2;
                                $star2 = $line_tmp =~ tr/\*/\*/;
                            }   
                        }
                        my %line_tmp = build_partial3b $line_tmp, "";
                        foreach my $line (keys %line_tmp)
                        {
                            if (exists($hash2b{$line}))
                            {                        
                                my $search0 = $hash2b{$line};
                                my $search_rev;
                                $search0 = substr $search0, 1;
                                my @search = split /,/,$search0;
                                                                            
                                foreach my $search (@search)
                                {                             
                                    my $search_tmp = substr $search, 0, -1;
                                    my $search_end = substr $search, -1;
                                    if (exists($hash{$search_tmp}))
                                    {
                                        my @search_tmp = split /,/,$hash{$search_tmp};
                                        my $found;
                                        my $found_rev;
                                        if ($search_end eq "1")
                                        {
                                            $found = $search_tmp[0];
                                            $found_rev = $search_tmp[1];
                                            $search_rev = $search_tmp."2";
                                        }
                                        elsif ($search_end eq "2")
                                        {
                                            $found = $search_tmp[1];
                                            $found_rev = $search_tmp[0];
                                            $search_rev = $search_tmp."1";
                                        }
                                        if ($use_quality ne "")
                                        {
                                            $found =~ tr/1234/ACTG/;
                                            $found_rev =~ tr/1234/ACTG/;
                                        }
                                        if ($encrypt eq "yes")
                                        {
                                            $found = decrypt $found;
                                            $found_rev = decrypt $found_rev;
                                        }
                                        my $found_new;
                                        my $first_nuc;

                                        my $middle = substr $found, $left, -(15+$middle_next);
                                        my $middle_read_end = substr $read_short_end2, -($read_length-$left-1)+$s-$u-$overhang+2, length($middle)-4;
                                        if ($reference_next_seed eq "yes" && $next_seed_ref ne "")
                                        {
                                            $middle_read_end = $middle;
                                            $middle = $next_seed_ref;
                                        }
                                        my $check_middle = $middle =~ s/(.)$middle_read_end/$1$middle_read_end/;
                                                                                

                                        if ($check_middle > 0)
                                        {
                                            $found_rev  =~ tr/ACTG/TGAC/;
                                            my $found_rev2 = reverse($found_rev);
                                            if ($reference_next_seed eq "yes" && $next_seed_ref ne "")
                                            {
                                                $found_rev2 = $found;
                                            }
                                            $before_pair{$found_rev2} = $search_rev;
                                        }
                                        if ($save_reads ne "")
                                        {                                  
                                            $save_reads{$search_tmp} = undef;
                                        }
                                    }
                                }
                            }
                        }
                        $s++;
                    }
                    if (%before_pair < 1 && $middle_next eq '0')
                    {
                        $middle_next = $read_length/4;
                        goto NEXT1;
                    }
                    elsif (%before_pair < 1 && $middle_next < ($read_length/4)+3)
                    {
                        $middle_next = ($read_length/4)+6;
                        $u += 20;
                        goto NEXT1;
                    }
                    elsif (%before_pair < 1 && $reference ne "" && $reference_next_seed eq "")
                    {
                        $reference_next_seed{$id} = "yes";
                        delete $noforward{$id};
                        $seed_id = $id;
                        $seed{$id} = $read;
                        print OUTPUT5 "GO BACK TO SEED\n";
                        goto SEED;
                    }
                    my $ll = '25';
NEXT1b:                    
                    my $id_tmp;
                    my %before_pair_final;
                    undef %before_pair_final;
                    foreach my $before_pair (keys %before_pair)
                    {
                        $id_tmp = $before_pair{$before_pair};

                        my $read_end_test2 = substr $read_short_end2, -30, 13;
                        my $read_end_test3 = substr $read_short_end2, -60, 13;
                        my $read_end_test4 = substr $read_short_end2, -100, 13;
                        my $read_end_test5 = substr $read_short_end2, -150, 13;
                        my $read_end_test6 = substr $read_short_end2, -200, 13;
                        
                        my $next_seed_tmp = substr $before_pair, $ll;
                        my $check_test2 = $next_seed_tmp =~ s/(.)$read_end_test2/$1.$read_end_test2/;
                        my $check_test3 = $next_seed_tmp =~ s/(.)$read_end_test3/$1.$read_end_test3/;
                        my $check_test4 = $next_seed_tmp =~ s/(.)$read_end_test4/$1.$read_end_test4/;
                        my $check_test5 = $next_seed_tmp =~ s/(.)$read_end_test5/$1.$read_end_test5/;
                        my $check_test6 = $next_seed_tmp =~ s/(.)$read_end_test6/$1.$read_end_test6/;
                        
                        if ($before_pair ne "" && $check_test2 eq "" && $check_test3 eq "" && $check_test4 eq "" && $check_test5 eq "" && $check_test6 eq "")
                        {
                            print OUTPUT5 $before_pair." FOUND_SEED\n";
                            $before_pair_final{$before_pair} = $id_tmp;
                        }
                    }
                    my @before_pair_final = keys %before_pair_final;
                    if (@before_pair_final < 1 && $ll+15 < $read_length-45)
                    {
                        $ll += 15;
                        goto NEXT1b;
                    }
                    my $count_match = '0';
                    my $count_match_tmp = '0';
                    my $next_seed0;
                    my %skip;
                    undef %skip;
NEXT2:              foreach my $before_pair_final (keys %before_pair_final)
                    {
                        if (exists($skip{$before_pair_final}))
                        {
                            next NEXT2;
                        }
                        my $pair_test1 = substr $before_pair_final, 17, 30;
                        my $pair_test2 = substr $before_pair_final, -47, 30;
                        foreach my $before_pair_final_tmp (keys %before_pair_final)
                        {
                            my $check_test1 = $before_pair_final_tmp =~ s/(.)$pair_test1/$1.$pair_test1/;
                            my $check_test2 = $before_pair_final_tmp =~ s/(.)$pair_test2/$1.$pair_test2/;
                            if ($check_test1 > 0 || $check_test2 > 0)
                            {
                                $count_match_tmp++;
                            }
                        }
                        if ($count_match_tmp > $count_match)
                        {
                            $count_match = $count_match_tmp;
                            $next_seed0 = $before_pair_final;
                            $id_tmp = $before_pair_final{$before_pair_final};
                        }
                        $count_match_tmp = '0';
                        $id = $before_pair_final{$before_pair_final};
                    }
                    
                    print OUTPUT5 $next_seed0." NEXT SEED CORRECT\n";
                    
                    if ($next_seed0 ne "")
                    {
                        $next_seed = correct ($next_seed0, \%before_pair, $heteroplasmy);
                    }
                    my $check_dot = $next_seed =~ tr/\./\./;
                    if ($check_dot > (3 +($read_length/60)))
                    {
                        $skip{$next_seed} = undef;
                        $next_seed0 = "";
                        $next_seed = "";
                        goto NEXT2;
                    }
                    
                    if ($next_seed eq "" && $middle_next eq '0')
                    {
                        $middle_next = $read_length/4;
                        goto NEXT1;
                    }
                    elsif ($next_seed eq "" && $middle_next < ($read_length/4)+3)
                    {
                        $middle_next = ($read_length/4)+6;
                        $u += 20;
                        goto NEXT1;
                    }
                    elsif ($next_seed eq "" && $reference ne "" && $reference_next_seed eq "")
                    {
                        $reference_next_seed{$id} = "yes";
                        delete $noforward{$id};
                        $seed_id = $id;
                        $seed{$id} = $read;
                        goto SEED;
                    }
                    
                    if ($y > $startprint2)
                    {
                        print OUTPUT5 $next_seed." NEXT_SEED\n";
                    }
                    
                    if ($next_seed ne "")
                    {
                        delete $seed{$id_original};
                        delete $seed{$id};
                        
                        while (exists($seed{$id_tmp}))
                        {
                            $id_tmp = '0'.$id_tmp;
                        }
                        $id = $id_tmp;                 
                        
                                                                                                                                                  
                        $seed{$id} = $next_seed;
                        $seed_id = $id;
                        $seeds_check{$id} = undef;
                        $position{$id} = length($next_seed);
                        $old_id{$id} = $id_old;
                        $old_id2{$id} = undef;
                        delete $noforward{$id};
    
                        $insert_size2{$id} = $insert_size;
                        
                        my $count_contig_tmp = $contig_count;
                        while ($count_contig_tmp > 0)
                        {
                            $contig_gap_min{$id."_".$count_contig_tmp} = $contig_gap_min{$id_old."_".$count_contig_tmp};
                            $contig_gap_max{$id."_".$count_contig_tmp} = $contig_gap_max{$id_old."_".$count_contig_tmp};
                            $count_contig_tmp--;    
                        } 
                        
                        $contig_count++;
                        $contig_count{$id} = $contig_count;
                        goto ITERATION;
                    }
                    
                                                print OUTPUT5 $xy." XY ".$tt." TT\n";
NEXT_SEED:                                      while ($xy > $tt)
                                                {
                                                    my $new_seed_part = substr $read, $xy-$u+10, $overlap;
                                                    
                                                    if (exists($hash2c{$new_seed_part}))
                                                    {
                                                        my $id_tmp = $hash2c{$new_seed_part};
                                                        my $id_tmp2 = substr $id_tmp, 1;
                                                        my @id_tmp = split /,/,$id_tmp2;
                                                            
                                                        foreach my $id_tmp3 (@id_tmp)
                                                        {
                                                            chomp ($id_tmp3);
                                                            my $id_match_end = chop $id_tmp3;
                                                            my $seed_tmp;

                                                            if (exists($hash{$id_tmp3}) && $id_tmp3)
                                                            {
                                                                my @id_tmp3 = split /,/, $hash{$id_tmp3};
                                                                if ($id_match_end eq "1")
                                                                {
                                                                    $seed_tmp = $id_tmp3[1];
                                                                }
                                                                elsif ($id_match_end eq "2")
                                                                {
                                                                    $seed_tmp  = $id_tmp3[0];
                                                                }
                                                                if ($use_quality ne "")
                                                                {
                                                                    $seed_tmp =~ tr/1234/ACTG/;
                                                                }
                                                                if ($encrypt eq "yes")
                                                                {
                                                                    $seed_tmp = decrypt $seed_tmp;
                                                                }
                                                                
                                                                $seed_tmp =~ tr/ACTG/TGAC/;
                                                                my $seed_tmp2 = reverse($seed_tmp);                             
                                                                my $yx = '0';
                                                                while ($yx < length($seed_tmp2)-($overlap+1))
                                                                {
                                                                    my $seed_tmp2_part = substr $seed_tmp2, $yx, $overlap;                                                           
                                                                    if (exists($hash2b{$seed_tmp2_part}))
                                                                    {
                                                                        my $id2 = $hash2b{$seed_tmp2_part};
                                                                        my $id5 = substr $id2, 1;
                                                                        my @id_tmp2 = split /,/,$id5;
                                                                        my $id_b = $id_tmp2[0];
                                                                        my $id_tmp2_end = chop $id_b;                                                                                                                                              
                                                                    
                                                                        if ($second_seed eq "ddd")
                                                                        {
                                                                            my @id_b = split /,/, $hash{$id_b};
                                                                            if ($id_tmp2_end eq "1")
                                                                            {
                                                                                $read = $id_b[0];
                                                                            }
                                                                            elsif ($id_tmp2_end eq "2")
                                                                            {
                                                                                $read = $id_b[1];
                                                                            }
                                                                            if ($use_quality ne "")
                                                                            {
                                                                                $read =~ tr/1234/ACTG/;
                                                                            }
                                                                            $second_seed = "yes";
                                                                            if ($encrypt eq "yes")
                                                                            {
                                                                                $read = decrypt $read;
                                                                            }
                                                                            
                                                                            $tt = -length($read);
                                                                            goto NEXT_SEED;
                                                                        }
                                                                        if ($y > $startprint2)
                                                                        {
                                                                            print OUTPUT5 $id_b." ID_B!!!!\n";
                                                                        }
                                                                        if (exists($id_bad{$id_b}))
                                                                        {
                                                                            goto SAME_ID;
                                                                        }                                                                
                                                                        elsif (exists($hash{$id_b}))
                                                                        {
                                                                            my @id_b = split /,/, $hash{$id_b};
                                                                            if ($id_tmp2_end eq "1")
                                                                            {
                                                                                $seed = $id_b[0];
                                                                            }
                                                                            elsif ($id_tmp2_end eq "2")
                                                                            {
                                                                                $seed = $id_b[1];
                                                                            }
                                                                            if ($use_quality ne "")
                                                                            {
                                                                                $seed =~ tr/1234/ACTG/;
                                                                            }
                                                                            if ($encrypt eq "yes")
                                                                            {
                                                                                $seed = decrypt $seed;
                                                                            }
                                                                            my $part2 = substr $seed, -$overlap-15;
                                                                            my $s = '0';
                                                                            my $most_match_total = '0';
                                                                            while ($s < length($part2)-$overlap)
                                                                            {
                                                                                my $part2b = substr $part2, $s, $overlap;
                                                                                my $part2b_reverse = reverse($part2b);
                                                                                $part2b_reverse =~ tr/ACTG/TGAC/;
                                                                                if (exists($hash2b{$part2b}))
                                                                                {
                                                                                    $most_match_total++;
                                                                                }
                                                                                if (exists($hash2c{$part2b}))
                                                                                {
                                                                                    $most_match_total++;
                                                                                }
                                                                                if (exists($hash2b{$part2b_reverse}))
                                                                                {
                                                                                    $most_match_total++;
                                                                                }
                                                                                if (exists($hash2c{$part2b_reverse}))
                                                                                {
                                                                                    $most_match_total++;
                                                                                }
                                                                                $s++;
                                                                            }
                                                                            if ($most_match_total > 2)
                                                                            {
                                                                                my %empty_hash;
                                                                                undef %empty_hash;
                                                                                $empty_hash{$seed} = undef;
                                                                                $seed = correct ($seed, \%empty_hash, $heteroplasmy);
                                                                                my $f = '0';
                                                                                my $read_part = substr $read, -$insert_size*$insert_range;
                                                                                while ($f < length($seed)-30)
                                                                                {
                                                                                    my $middle1 = substr $seed, $f, 30;
                                                                                    my $check_read1 = $read_part =~ s/$middle1/$middle1/;
                                                                                    if ($check_read1 > 0)
                                                                                    {
                                                                                        $xy--;
                                                                                        $id_bad{$id_b} = undef;
                                                                                        goto NEXT_SEED;
                                                                                    }
                                                                                    $f += 10;
                                                                                }                                                                              
                                                                                
                                                                                my $seed_test = substr $seed, -$overlap-30;
                                                                                my $A_rich_test3 = $seed_test =~ tr/A/A/;
                                                                                my $T_rich_test3 = $seed_test =~ tr/T/T/;
                                                                                my $G_rich_test3 = $seed_test =~ tr/G/G/;
                                                                                my $C_rich_test3 = $seed_test =~ tr/C/C/;
                                                                                my $dot_rich_test3 = $seed_test =~ tr/\./\./;
                                                                                if ($A_rich_test3+$dot_rich_test3 > length($seed_test)-5 || $T_rich_test3+$dot_rich_test3 > length($seed_test)-5 || $G_rich_test3+$dot_rich_test3 > length($seed_test)-5 || $C_rich_test3+$dot_rich_test3 > length($seed_test)-5)
                                                                                {
                                                                                    $xy--;
                                                                                    $id_bad{$id_b} = undef;
                                                                                    goto NEXT_SEED;
                                                                                }
                                                                            }
                                                                            else
                                                                            {
                                                                                $xy--;
                                                                                $id_bad{$id_b} = undef;
                                                                                goto NEXT_SEED;
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                           $id_bad{$id_b} = undef;
                                                                           goto SAME_ID;
                                                                        }
                                                                        if ($y > $startprint2)
                                                                        {
                                                                            print OUTPUT5 $id_b." SECOND!!!!\n";
                                                                            print OUTPUT5 $seed." SEED!!!!\n";
                                                                        }
                                                                        delete $seed{$id_original};
                                                                        delete $seed{$id};
                                                                        
   
                                                                        $id_bad{$id_b} = undef;
                                                                                                                                              
                                                                        $seed{$id_b} = $seed;
                                                                        $seeds_check{$id_b} = undef;
                                                                        $position{$id_b} = length($seed);
                                                                        $old_id{$id_b} = $id_old;
                                                                        $old_id2{$id_b} = undef;
                  
                                                                        $insert_size2{$id_b} = $insert_size;
                                                                        
                                                                        my $count_contig_tmp = $contig_count;
                                                                        while ($count_contig_tmp > 0)
                                                                        {
                                                                            $contig_gap_min{$id_b."_".$count_contig_tmp} = $contig_gap_min{$id_old."_".$count_contig_tmp};
                                                                            $contig_gap_max{$id_b."_".$count_contig_tmp} = $contig_gap_max{$id_old."_".$count_contig_tmp};
                                                                            $count_contig_tmp--;    
                                                                        } 
                                                                        
                                                                        $contig_count++;
                                                                        $contig_count{$id_b} = $contig_count;
                                                                        my $gap_min = ($insert_size*0.62)-(2*$read_length)+$xy + $overlap-16 + $yx;
                                                                        my $gap_max= ($insert_size*1.38)-(2*$read_length)+$xy + $overlap-16 + $yx; 
                                                                        $contig_gap_min{$id_b."_".$contig_count} = $gap_min;
                                                                        $contig_gap_max{$id_b."_".$contig_count} = $gap_max;
                                                                        goto ITERATION;
SAME_ID:       
                                                                    }
                                                                    $yx++;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    $xy--;
                                                }
                                                my $count_seeds_tmp = keys %seed;
                                                print OUTPUT5 $count_seeds_tmp." NO_MATCHES_NEXT_SEED\n";
                                                $id = $id_original;
                                                $no_next_seed = "yes";
                                                $no_next_seed{$id} = "yes";
                                                $seed{$id} = $read;
                                                goto FINISH;
                                            }
                                            elsif($circle eq "" && (($last_chance eq "yes" || $noforward eq "stop") && ($last_chance_back eq "yes" || $noback eq "stop")) || ($AT_rich eq "yes" && $count_seed ne "0") || ($bad_read ne "" && $count_seed ne "0"))
                                            {
                                                delete $seed{$id};                                         
                                                delete $last_chance{$id};
                                                if ($y > $startprint2)
                                                {                                                                                 
                                                    print OUTPUT5 "DELETE READS AND SEED\n";
                                                    print OUTPUT5 ">".$id."\n";
                                                    print OUTPUT5 $read."\n";
                                                }
                                                if (exists($old_id{$id}))
                                                {
                                                    my $read_tmp = $seed_old{$old_id{$id}};
                                                    if (length($read_tmp) > 250)
                                                    {
                                                        $contigs{$contig_num."+".$old_id{$id}} = $read_tmp;
                                                        $contig_num++;
                                                    }
                                                }                                               
                                                else
                                                {
                                                    if (length($read) > 250)
                                                    {
                                                        my $check_id = $id;
                                                        if ($id =~ m/(.*_|)(\d+)$/)
                                                        {
                                                            $check_id = $2;
                                                        }
                                                        if ($contig_num eq '1')
                                                        {       
                                                            $contigs{$contig_num."+".$check_id} = $read;
                                                            contig_start ($read);  
                                                        }
                                                        else
                                                        {
                                                           $contigs{$contig_num."+".$check_id} = $read; 
                                                        }
                                                        $contig_num++;
                                                    }
                                                }
                                            }
                                            elsif($circle eq "yes" && $heteroplasmy eq "")
                                            {
                                                my $output_file  = "Circularized_assembly_".$option."_".$project.".fasta";
                                                open(OUTPUT, ">" .$output_file) or die "Can't open file $output_file, $!\n";
                                                
                                                delete $seed{$id};
                                                $read =~ tr/\./N/;
                                                $read =~ tr/X//d;
                                                my @contigs = split /L+/, $read;
                                                my $l = '0';
                                                my $largest_contig = '0';
                                                my $miminum_contig = '100000000000000000000000000000';
                                                
                                                print "\b" x length($progress_before);
                                                print ' ' x length($progress_before);
                                                print "\b" x length($progress_before);
                                                print "\n-----------------Assembly ".$option." finished successfully: The genome has been circularized-----------------\n\n";
                                                print OUTPUT4 "\n-----------------Assembly ".$option." finished successfully: The genome has been circularized-----------------\n\n";
                                                print OUTPUT5 "\n-----------------Assembly ".$option." finished successfully: The genome has been circularized-----------------\n\n";
                                                $assembly_length = '1';            
                                                foreach (@contigs)
                                                {
                                                    $l++;
                                                    my $fin = $_;
                                                    my $fin2 = $fin;
                                                    $fin =~ s/(.{1,150})/$1\n/gs;
                                                    
                                                    if ($l > 1)
                                                    {
                                                        my $gap_min = sprintf("%.0f", $contig_gap_min{$id."_".($l-1)});
                                                        my $gap_max = sprintf("%.0f", $contig_gap_max{$id."_".($l-1)});
                                                            print " (Check manually if the two contigs overlap to merge them together!)\n";
                                                            print OUTPUT4 " (Check manually if the two contigs overlap to merge them together!)\n";
                                                    }                                          
                                                    print OUTPUT ">Contig".$l."\n";
                                                    print OUTPUT $fin;
                                                    if (length($fin2) > $largest_contig)
                                                    {
                                                        $largest_contig = length($fin2);
                                                    }
                                                    if (length($fin2) < $miminum_contig)
                                                    {
                                                        $miminum_contig = length($fin2);
                                                    }
                                                    print "Contig ".$l."                  : ".length($fin2)." bp\n";
                                                    print OUTPUT4 "Contig ".$l."                  : ".length($fin2)." bp\n";
                                                    $assembly_length += length($fin2);
                                                }
                                                $assembly_success = "yes";
                                                if ($y > $startprint2)
                                                {                                                                                 
                                                    print OUTPUT5 ">".$id."\n";
                                                    print OUTPUT5 $read."\n\n\n";
                                                }
                                                
                                                print "\nTotal contigs              : ".$l."\n";
                                                print "Largest contig             : ".$largest_contig." bp\n";
                                                print "Smallest contig            : ".$miminum_contig." bp\n";
                                                print "Average insert size        : ".$insert_size." bp\n\n";
                                                print OUTPUT4 "\nTotal contigs              : ".$l."\n";
                                                print OUTPUT4 "Largest contig             : ".$largest_contig." bp\n";
                                                print OUTPUT4 "Smallest contig            : ".$miminum_contig." bp\n";
                                                print OUTPUT4 "Average insert size        : ".$insert_size." bp\n\n";
                                                $option++;
                                                close OUTPUT;
                                                $finish = "yes";
                                            }
                                            elsif($circle eq "yes" && $heteroplasmy ne "")
                                            {
                                                $finish = "yes";
                                                delete $seed{$id};
                                            }
                                            elsif ($circle ne "contigs" && $heteroplasmy eq "" && $count_seed < 2)
                                            {
                                                my $output_file2  = "Uncircularized_assemblies_".$option."_".$project.".fasta";
                                                open(OUTPUT2, ">" .$output_file2) or die "Can't open file $output_file2, $!\n";
                                                
                                                if (length($read) > 250)
                                                {
                                                    $contigs{$contig_num."+".$id} = $read;
                                                    $contig_num++;
                                                }
                                                
                                                delete $seed{$id};
          
                                                $read =~ tr/\./N/;
                                                $read =~ tr/X//d;
                                                my @contigs = split /L+/, $read;
                                                my $l = '0';
                                                my $largest_contig = '0';
                                                my $miminum_contig = '100000000000000000000000000000';
                                                
                                                print "\b" x length($progress_before);
                                                print ' ' x length($progress_before);
                                                print "\b" x length($progress_before);
                                                print "\n-----------------Assembly ".$option." finished incomplete: The genome has not been circularized-----------------\n\n";
                                                print OUTPUT4 "\n-----------------Assembly ".$option." finished incomplete: The genome has not been circularized-----------------\n\n";
                                                print OUTPUT5 "\n-----------------Assembly ".$option." finished incomplete: The genome has not been circularized-----------------\n\n";

                                                if ($y > $startprint2)
                                                {                                                                                 
                                                    print OUTPUT5 ">".$id."\n";
                                                    print OUTPUT5 $read."\n\n\n";
                                                }

                                                foreach my $contig_tmp (keys %contigs)
                                                {
                                                    if ($contig_tmp =~ m/(\d+)\+*\d*/)
                                                    {
                                                        my $contig_tmp3 = $1;
                                                        if ($contig_tmp3 < 10)
                                                        {
                                                            $contigs{"0".$contig_tmp} = $contigs{$contig_tmp};
                                                            delete $contigs{$contig_tmp};
                                                        }
                                                    }
                                                }
                                                foreach my $contig_tmp (sort keys %contigs)
                                                {
                                                    my $contig_tmp2;
                                                    if ($contig_tmp =~ m/(\d+)\+*\d*/)
                                                    {
                                                        $contig_tmp2 = $1;
                                                    }
                                                    $read = $contigs{$contig_tmp};
                                                    $read =~ tr/\./N/;
                                                    $read =~ tr/X//d;
                                                    my @contigs = split /L+/, $read;
                                                    my $jj = '0';
                                                    foreach (@contigs)
                                                    {
                                                        $l++;
                                                        $jj++;
                                                        my $fin = $_;
                                                        my $fin2 = $fin;
                                                        $fin =~ s/(.{1,150})/$1\n/gs;
                                                        
                                                        if ($jj > 1)
                                                        {
                                                            my $gap_min = sprintf("%.0f", $contig_gap_min{$id."_".($jj-1)});
                                                            my $gap_max = sprintf("%.0f", $contig_gap_max{$id."_".($jj-1)});
                                                                print " (Check manually if the two contigs overlap to merge them together!)\n";
                                                                print OUTPUT4 " (Check manually if the two contigs overlap to merge them together!)\n";
                                                        }                                          
                                                        print OUTPUT2 ">Contig".$contig_tmp."\n";
                                                        print OUTPUT2 $fin;
                                                        if (length($fin2) > $largest_contig)
                                                        {
                                                            $largest_contig = length($fin2);
                                                        }
                                                        if (length($fin2) < $miminum_contig)
                                                        {
                                                            $miminum_contig = length($fin2);
                                                        }
                                                        print "Contig ".$contig_tmp2."           : ".length($fin2)." bp\n";
                                                        print OUTPUT4 "Contig ".$contig_tmp2."           : ".length($fin2)." bp\n";
                                                    }
                                                    if ($y > $startprint2)
                                                    {                                                                                 
                                                        print OUTPUT5 ">Contig".$contig_tmp."\n";
                                                        print OUTPUT5 $read."\n";
                                                    }
                                                }
                                                print "\nTotal contigs          : ".$l."\n";
                                                print "Largest contig         : ".$largest_contig." bp\n";
                                                print "Smallest contig        : ".$miminum_contig." bp\n";
                                                print "Average insert size    : ".$insert_size." bp\n\n";
                                                print OUTPUT4 "\nTotal contigs          : ".$l."\n";
                                                print OUTPUT4 "Largest contig         : ".$largest_contig." bp\n";
                                                print OUTPUT4 "Smallest contig        : ".$miminum_contig." bp\n";
                                                print OUTPUT4 "Average insert size    : ".$insert_size." bp\n\n";
                                                $option++;
                                                close OUTPUT2;
                                                $finish = "yes";
                                            }
                                            elsif($circle ne "contigs" && $heteroplasmy ne "")
                                            {
                                                $finish = "yes";
                                                delete $seed{$id};
                                            }
    }
    HP_END:
    if ($y > $startprint2 && $benchmark_time eq "yes")
    {
        if (time-$time_back > 1)
        {
            print OUTPUT5 time-$time_back." TIME_END\n";
        }
    }
}
$y++;
    
    if ($y eq $iterations)
    {
        foreach my $seedprint (keys %seed)
        {
            print OUTPUT5 "\n".$seedprint."\n";
            print OUTPUT5 $seed{$seedprint}."\n\n";
        }
    }
    if (@insert_size > 500 && (@insert_size < 8000 || $y < 10) && $insert_size_correct eq "yes" && $paired eq "PE")
    {          
        my $insert_total = '0';
        my $k = '0';
        foreach my $insert1 (@insert_size)
        {
            $insert_total += $insert1;
            $k++;
        }
        
        my $insert_size_temp = $insert_total/$k;
        $insert_size = int($insert_size_temp + $insert_size_temp/abs($insert_size_temp*2));
        if ($y > $startprint2)
        {
            print OUTPUT5 $insert_size." Insert Size\n";
        }
    }
    elsif (@insert_size >= 8000)
    {
        $insert_size_correct = "";
    }
}
FINISH2:

    if ($finish ne "yes")
    {
        foreach my $seed_id_tmp (keys %seed)
        {
            if (length($seed{$seed_id_tmp}) > 250)
            {
                $contigs{$contig_num."+".$seed_id_tmp} = $seed{$seed_id_tmp};
                $contig_num++; 
            }
            delete $seed{$seed_id_tmp};
        }
                                                
        foreach my $contig_tmp (keys %contigs)
        {
            if ($contig_tmp =~ m/(\d+)\+*\d*/)
            {
                my $contig_tmp3 = $1;
                if ($contig_tmp3 < 10)
                {
                    $contigs{"0".$contig_tmp} = $contigs{$contig_tmp};
                    delete $contigs{$contig_tmp};
                }
            }
        }
    }
    my $count_contigs = keys %contigs;

    my $tree_succes = "";
    if($circle ne "yes" && $count_contigs > 1 && $heteroplasmy eq "")
    {
        open(OUTPUT7, ">" .$output_file7) or die "\nCan't open file $output_file7, $!\n";
        my $h = '0';
        my $terminate = '0';
        my %node;
        my %row_nodes;
        my %contig_num;
        my %contigs2;
        my %repetitive;
        undef %contigs2;
        undef %node;
        undef %row_nodes;
        undef %contig_num;
        undef %repetitive;
        foreach my $contig_tmp (keys %contigs)
        {
            if ($contig_tmp =~ m/(\d+)\+*(.*)/)
            {
                my $contig_num = $1;
                my $contig_code = $2;
                if ($contig_code =~ m/.*_(\d+)$/)
                {
                    $contig_code = $1;
                }
                $contig_num{$contig_code} = $contig_num;
                $contigs2{$contig_num} = $contigs{$contig_tmp};
            }
        }
        print OUTPUT7 "LINKS BETWEEN CONTIGS\n";
        print OUTPUT7 "---------------------\n\n";
        foreach my $tree (keys %tree)
        {
            my $tree2 = $tree;
            my $tree3 = $tree{$tree2};
            if ($tree2 =~ m/.*_(\d+(REP)*)$/)
            {
                $tree = $1;
            }
            if ($tree3 =~ m/.*_(\d+(REP))$/)
            {
                $tree3 = $1;
            }
            delete $tree{$tree2};
            $tree{$tree} = $tree3;
            my $tree_tmp = $tree;
            my $tree_tmp2 = $tree{$tree};

            my @ids_split = split /\*/, $tree_tmp2;
            foreach my $id_split (@ids_split)
            {
                foreach my $contig_num (keys %contig_num)
                {
                    if ($id_split  =~ m/^$contig_num(REP)*$/)
                    {
                        if ($tree_tmp2 =~ m/^(.*\*)*$contig_num(REP)*(\*.*)*$/)
                        {
                            if (defined($1))
                            {
                                $tree_tmp2 = $1.$contig_num{$contig_num};
                            }
                            else
                            {
                                $tree_tmp2 = $contig_num{$contig_num};
                            }
                            if (defined($2))
                            {
                                $tree_tmp2 = $tree_tmp2."REP";
                            }
                            if (defined($3))
                            {
                                $tree_tmp2 = $tree_tmp2.$3;
                            }
                        }
                    }
                    if ($contig_num eq $tree_tmp)
                    {
                        $tree_tmp = $contig_num{$contig_num};
                    }
                }
            }
            my $rep_test = substr $tree_tmp2, -3;
            $tree_tmp2 =~ s/\*/ OR /g;
            if ($rep_test eq "REP")
            {
                my $tree_tmp2a = substr $tree_tmp2,0, -3;
                print OUTPUT7 $tree_tmp."----> REPETITIVE REGION----> ".$tree_tmp2a."\n";
            }
            else
            {
                print OUTPUT7 $tree_tmp."----> ".$tree_tmp2."\n";
            }
        }
        if (exists($tree{"START"}))
        {
            $row{$h} = "01";
            $node{$h} = $tree{"START"};
        }
        if ($hasL eq "yes")
        {
            print OUTPUT7 "\n(Contigs broken up by long homopolymer stretches are linked together as one contig with 15 N's, they can be merged manually in some cases)\n";
            print OUTPUT7 "\n(If the region before and after the N zone overlaps, you can merge them by deleting the regions next to N zone from both sides (those are the least reliable))\n\n";

        }                                     
        my %row_circle;
        undef %row_circle;
TERMINATE:                                      while (keys %node)
        {
            foreach my $h1 (keys %node)
            {
                undef %row_nodes;
                %row_nodes = map { $_ => undef } split(/\+/, $row{$h1});
                my @row_nodes = map { $_ => undef } split(/\+/, $row{$h1});
                if(exists($tree{$node{$h1}}))
                {
                    if ($tree{$node{$h1}} eq $node{$h1})
                    {
                        delete $node{$h1};
                        delete $row{$h1};
                    }
                    elsif ($tree{$node{$h1}} eq "END_REVERSE")
                    {
                        delete $node{$h1};
                        delete $row{$h1};
                    }
                    elsif ($tree{$node{$h1}} eq "END")
                    {
                        delete $node{$h1};
                        $row_circle{$h1} = $row{$h1};
                    }
                    elsif ($tree{$node{$h1}} =~ m/(.*)\*(.*)/)
                    {                                                          
                        my @id_node = split /\*/, $tree{$node{$h1}};
                        foreach my $id_node (@id_node)
                        {
                            my $count1 = '0';
                            foreach my $row_n (@row_nodes)
                            {
                                if ($id_node eq $row_n)
                                {
                                    $count1++;
                                }                                                                   
                            }
                            if ($id_node eq $node{$h1})
                            {
                            }
                            elsif ($count1 > 0)
                            {
                            }
                            else
                            {
                                $h++;
                                $node{$h} = $id_node;
                                $row{$h} = $row{$h1}."+".$id_node;
                            }
                        }
                        delete $node{$h1};
                        delete $row{$h1};
                    }
                    elsif ($tree{$node{$h1}} =~ m/(.*)REP/)
                    {
                        $h++;       
                        $row{$h} = $row{$h1}."+".$1."R";
                        $node{$h} = $1;
                        delete $node{$h1};
                        delete $row{$h1};
                        $repetitive{$1} = undef;
                    }
                    else
                    {
                        $h++;
                        if ($row{$h1} =~ m/^(.*)\+\d+$/)
                        {
                            $row{$h1} = $1;
                        }
                        if ($row{$h1} =~ m/^01$/)
                        {
                            $row{$h} = $row{$h1}
                        }
                        else
                        {
                            $row{$h} = $row{$h1}."+".$tree{$node{$h1}};
                        }
                        $node{$h} = $tree{$node{$h1}};
                        delete $node{$h1};
                        delete $row{$h1};
                    }
                }
                else
                {
                   delete $node{$h1};
                   delete $row{$h1};
                }
                $terminate++;
                if ($terminate > 1500)
                {
                    delete $row{$h1};
                    last TERMINATE;
                } 
            }
        }
        my $g = '1';
        my $count_options = '0';

        foreach my $row (keys %row_circle)
        {
            foreach my $contig_num (keys %contig_num)
            {
                $row{$row} =~ s/\+$contig_num\+/\+$contig_num{$contig_num}\+/g;
                $row{$row} =~ s/\+$contig_num$/\+$contig_num{$contig_num}/g;
                $row{$row} =~ s/\+$contig_num(R)\+/\+$contig_num{$contig_num}R\+/g;
                $row{$row} =~ s/\+$contig_num(R)$/\+$contig_num{$contig_num}R/g;
            }
            
            my @row = split /\+/,$row{$row};
            my $assembly = "";
            
            foreach my $cont (@row)
            {
                my $check = $cont =~ tr/R//d;
                if (exists($contigs2{$cont}))
                {
                    my $repe2 = substr $assembly, -1;
                    if ($cont eq '1' || $cont eq '01')
                    {
                        $assembly = $contigs2{$cont};
                    }
                    elsif ($check > 0)
                    {
                        $assembly .= "RRRRRRRRRRRRRR".$contigs2{$cont};
                    }
                    else
                    {
                        my $end_assembly = substr $assembly, -30;
                        my $end_assembly2 = substr $assembly, -80 , 30;
                        $end_assembly =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        $end_assembly2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        my $start_next_contig = substr $contigs2{$cont},0 ,500;
                        $start_next_contig =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
                        my $start_next_contig2 = $start_next_contig;
                        my $x1 = length($start_next_contig);
                        $start_next_contig =~ s/.*.$end_assembly//;
                        my $x2 = length($start_next_contig);                       
                        $start_next_contig2 =~ s/.*.$end_assembly2//;
                        my $x2b = length($start_next_contig2);
                        if ($x1-$x2 ne '0')
                        {
                            my $assembly_tmp = substr $assembly, 0, -($x1-$x2);
                            $assembly = $assembly_tmp.$contigs2{$cont};
                        }
                        elsif ($x1-$x2b ne '0')
                        {
                            my $assembly_tmp = substr $assembly, 0, -($x1-$x2b+50);
                            $assembly = $assembly_tmp.$contigs2{$cont};
                        }
                        else
                        {
                            $assembly .= "2RRRRRRRRRRRRRR".$contigs2{$cont};
                        }  
                    }
                }
            }
            my $start_assembly = substr $assembly, 50, 30;
            $start_assembly =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            my $end_last_contig = substr $assembly, -1000;
            $end_last_contig =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
            my $x1 = length($end_last_contig);
            $end_last_contig =~ s/(.)$start_assembly.*/$1/;
            my $x2 = length($end_last_contig);
            my $assembly2;
            if (-$x1+$x2 ne '0')
            {
                $assembly2 = substr $assembly, 50, -$x1+$x2;
            }
            else
            {
                $assembly2 = $assembly;
            }  
            $assembly = $assembly2;
            $assembly =~ tr/\./N/;
            
            if (length($assembly) > 500)
            {
                $count_options++;
                print OUTPUT7 "\n\nOPTION ".$g."\n-------------------\n";
                print OUTPUT7 "Contig Arrangement : ";
                print OUTPUT7 $row{$row}."\n";
                print OUTPUT7 "Assembly length    : ".length($assembly)." bp\n\n";
                my @contigs0 = split /RRRRRRRRRRRRRR/, $assembly;
                my $size_c = @contigs0;
                my $jj = '0';
                my $t ='0';
                my @order = split /\+/, $row{$row};
                foreach (@contigs0)
                {
                    $jj++;
                    my $fin = $_;
                    $fin =~ tr/L/N/;
                    my $order = "";
                    my $h = '0';
ORDER:              foreach my $tmp (@order)
                    {
                        if ($h < $t)
                        {
                            $h++;
                            next ORDER;
                        } 
                        my $R = $tmp =~ s/RRRRRRRRRRRRRR//g;
                        if ($R ne '1'&& $h > 0)
                        {
                            $order .= "+".$tmp;
                        }
                        elsif ($R ne '1' && $h eq '0')
                        {
                            $order = $tmp;
                        }
                        if ($R > 0 && $h ne '0')
                        {
                            last ORDER;
                        }
                        $t++;
                        $h++;
                    }
                    my $gg = substr $order, 0, 1;
                    if ($gg eq "+")
                    {
                        substr $order, 0, 1, "";
                    }                   
                    
                    print OUTPUT7 ">Contig ".$order."\n";
                    my $fail = substr $fin, -1;
                    if ($fail eq '2')
                    {
                        substr $fin, -1, 1, "";
                    }
                    print OUTPUT7 $fin."\n";
                    
                    if ($size_c > 1 && $jj < $size_c && $fail ne '2')
                    {
                        print OUTPUT7 "\n-------Repetitive region detected, exact length unknown-------\n\n";
                    }
                    elsif ($size_c > 1 && $jj < $size_c && $fail eq '2')
                    {
                        print OUTPUT7 "\n-------Couldn't merge automatically, try manually-------\n\n";
                    }
                }
                 
                print OUTPUT7 "\n";
                
                my $output_file9  = "Option_".$g."_".$project.".fasta";
                open(OUTPUT9, ">" .$output_file9) or die "Can't open file $output_file9, $!\n";
                $assembly =~ tr/L/N/;
                my @contigs2 = split /RRRRRRRRRRRRRR/, $assembly;
                my $ww = '0';
                foreach (@contigs2)
                {
                    $ww++;
                    my $fin = $_;
                    my $fin2 = $fin;
                    $fin =~ s/(.{1,150})/$1\n/gs;
                                                             
                    print OUTPUT9 ">Contig".$ww."\n";
                    print OUTPUT9 $fin;
                }
                close OUTPUT9;
                $g++;
                
                if (length($assembly) > $genome_range_low && length($assembly) < $genome_range_high)
                {
                    $tree_succes = "yes";
                    $assembly_length = length($assembly);
                }
            }                                                   
        }
        if ($count_options > 0)
        {
            print OUTPUT7 "\n\nEach option has a separate fasta file\n";
        }
        else
        {
            print OUTPUT7 "\n\n------Assembled contigs can not be circularized, some sequence is probably missing!------n";
        }
    }
    elsif ($count_contigs eq 1)
    {
        foreach my $contig_tmp1 (keys %contigs)
        {
            $assembly_length = length($contigs{$contig_tmp1});
        } 
    }
    if ($finish ne "yes" && $heteroplasmy eq "")
    {
                                                my $output_file2  = "Contigs_".$option."_".$project.".fasta";
                                                open(OUTPUT2, ">" .$output_file2) or die "Can't open file $output_file2, $!\n";
                                    
                                                my $l = '0';
                                                my $largest_contig = '0';
                                                my $miminum_contig = '1000000000000000000000000000000000';
                                                
                                                print "\b" x length($progress_before);
                                                print ' ' x length($progress_before);
                                                print "\b" x length($progress_before);
                                                print "\n------------Assembly ".$option." finished: Contigs are automatically merged in Merged_contigs file------------\n\n";
                                                print OUTPUT4 "\n------------Assembly ".$option." finished: Contigs are automatically merged in Merged_contigs file------------\n\n";
                                                print OUTPUT5 "\n------------Assembly ".$option." finished: Contigs are automatically merged in Merged_contigs file------------\n\n";                                     
                                                
                                                my $count_contigs_tmp = keys %contigs;
                                                if ($count_contigs_tmp < 1)
                                                {
                                                    $largest_contig = length($read);
                                                    $miminum_contig = length($read);
                                                    $contigs{"1"} = $read;
                                                }
                                                
                                                foreach my $contig_tmp (sort keys %contigs)
                                                {
                                                    my $contig_tmp2;
                                                    if ($contig_tmp =~ m/(\d+)\+*\d*/)
                                                    {
                                                        $contig_tmp2 = $1;
                                                    }
                                                    
                                                    $read = $contigs{$contig_tmp};
                                                    $read =~ tr/\./N/;
                                                    $read =~ tr/X//d;
                                                    my @contigs = split /L+/, $read;
                                                    my $jj = '0';
                                                    
                                                    foreach (@contigs)
                                                    {
                                                        $l++;
                                                        $jj++;
                                                        my $fin = $_;
                                                        my $fin2 = $fin;
                                                        $fin =~ s/(.{1,150})/$1\n/gs;
                                                        
                                                        if ($jj > 1)
                                                        {
                                                            my $gap_min = sprintf("%.0f", $contig_gap_min{$id."_".($jj-1)});
                                                            my $gap_max = sprintf("%.0f", $contig_gap_max{$id."_".($jj-1)});
                                                                print " (Check manually if the two contigs overlap to merge them together!)\n";
                                                                print OUTPUT4 " (Check manually if the two contigs overlap to merge them together!)\n";
                                                        }                                          
                                                        print OUTPUT2 ">Contig".$contig_tmp."\n";
                                                        print OUTPUT2 $fin;
                                                        if (length($fin2) > $largest_contig)
                                                        {
                                                            $largest_contig = length($fin2);
                                                        }
                                                        if (length($fin2) < $miminum_contig)
                                                        {
                                                            $miminum_contig = length($fin2);
                                                        }
                                                        print "Contig ".$contig_tmp2."                  : ".length($fin2)." bp\n";
                                                        print OUTPUT4 "Contig ".$contig_tmp2."                  : ".length($fin2)." bp\n";
                                                    }
                                                    if ($y > $startprint2)
                                                    {                                                                                 
                                                        print OUTPUT5 ">Contig".$contig_tmp."\n";
                                                        print OUTPUT5 $read."\n";
                                                    }
                                                }
                                                
                                                print "\nTotal contigs              : ".$l."\n";
                                                print "Largest contig             : ".$largest_contig." bp\n";
                                                print "Smallest contig            : ".$miminum_contig." bp\n";
                                                print "Average insert size        : ".$insert_size." bp\n\n";
                                                print OUTPUT4 "\nTotal contigs              : ".$l."\n";
                                                print OUTPUT4 "Largest contig             : ".$largest_contig." bp\n";
                                                print OUTPUT4 "Smallest contig            : ".$miminum_contig." bp\n";
                                                print OUTPUT4 "Average insert size        : ".$insert_size." bp\n\n";
                                                print OUTPUT5 "\nTotal contigs              : ".$l."\n";
                                                print OUTPUT5 "Largest contig             : ".$largest_contig." bp\n";
                                                print OUTPUT5 "Smallest contig            : ".$miminum_contig." bp\n";
                                                print OUTPUT5 "Average insert size        : ".$insert_size." bp\n\n";
                                                $option++;
                                                
                                                close OUTPUT2
    }


                                                if ($hp_seed_assemble ne "")
                                                {
                                                    goto HP0;
                                                }
                                                if ($heteroplasmy ne "")
                                                {
                                                    print "\b" x length($progress_before);
                                                    print ' ' x length($progress_before);
                                                    print "\b" x length($progress_before);
                                                    print "\n";
                                                }
                                                my $total_reads_organelle = (keys %count_reads)*2;
                                                my $total_reads_organelle_all = (keys %count_reads_all)*2;
                                                my $total_reads = (keys %hash)*2;
                                                my $organelle_percentage = sprintf("%.2f",($total_reads_organelle_all*100)/$total_reads);
                                                my $average_coverage = sprintf("%.0f",$total_reads_organelle_all*$read_length/$assembly_length);
                                                
                                                my $count_hp = '0';
                                                my $count_hp_homo = '0';
                                                if ($heteroplasmy ne "")
                                                {
                                                    if ($hp_back eq "")
                                                    {
                                                        print "\n------------------------------------Forward assembly data metrics------------------------------------\n\n";
                                                        print OUTPUT4"\n------------------------------------Forward assembly data metrics------------------------------------\n\n";
                                                    }
                                                    else
                                                    {
                                                        print "\n-------------------------------Forward & Reverse assembly data metrics-------------------------------\n\n";
                                                        print OUTPUT4"\n-------------------------------Forward & Reverse assembly data metrics-------------------------------\n\n";
                                                    }
                                                    foreach my $variance (sort { $a <=> $b } keys %variance_all)
                                                    {
                                                        $count_hp++;
                                                    }
                                                    foreach my $variance_homo (sort { $a <=> $b } keys %variance_all_homo)
                                                    {
                                                        $count_hp_homo++;
                                                    }
                                                    print "Homoplasmic positions   : ".$count_hp_homo."\n"; 
                                                    print "\nHeteroplasmic positions : ".$count_hp."\n";
                                                    print OUTPUT4 "Homoplasmic positions   : ".$count_hp_homo."\n";
                                                    print OUTPUT4 "\nHeteroplasmic positions : ".$count_hp."\n";
                                                }
                                                else
                                                {
                                                    print "\n-----------------------------------------Input data metrics-----------------------------------------\n\n";
                                                    print OUTPUT4 "\n-----------------------------------------Input data metrics-----------------------------------------\n\n";
                                                    print "Total reads                : ".$total_reads."\n";
                                                    print "Aligned reads              : ".$total_reads_organelle_all."\n";
                                                    print "Assembled reads            : ".$total_reads_organelle."\n";
                                                    if ($assembly_success eq "yes" ||  $tree_succes eq "yes")
                                                    {
                                                       print "Organelle genome %         : ".$organelle_percentage." %\n"; 
                                                    }
                                                    if ($assembly_length > 5000)
                                                    {
                                                       print "Average organelle coverage : ".$average_coverage."\n"; 
                                                    }
                                                    print OUTPUT4 "Total reads                : ".$total_reads."\n";
                                                    print OUTPUT4 "Aligned reads              : ".$total_reads_organelle_all."\n";
                                                    print OUTPUT4 "Assembled reads            : ".$total_reads_organelle."\n";
                                                    if ($assembly_success eq "yes" ||  $tree_succes eq "yes")
                                                    {
                                                       print OUTPUT4 "Organelle genome %         : ".$organelle_percentage." %\n"; 
                                                    }
                                                    if ($assembly_length > 5000)
                                                    {
                                                       print OUTPUT4 "Average organelle coverage : ".$average_coverage."\n"; 
                                                    }
                                                }                                               
                                                                                              
                                                print "\n-----------------------------------------------------------------------------------------------------\n\n";
                                                print OUTPUT4 "\n-----------------------------------------------------------------------------------------------------\n\n";
HP0:
if ($variance_detection eq "yes")
{
    foreach my $variance (sort { $a <=> $b } keys %variance_no_hp)
    {
        print OUTPUT12 $variance_no_hp{$variance}."\n";
    }
}
if ($heteroplasmy ne "" && $hp_back eq "" && $hp_seed_assemble eq "")
{
    $hp_back = "yes";
    print OUTPUT5 ">".$read." READ_FORWARD_ASSEMBLY\n";
    $seed_input = substr $read_new, -100;
    $no_hp_one_turn = "";
    $no_hp_one_turn2 = "";
    $y = '1';
    $last_150 = "";
    $first_150 = $read_length;
    goto HP_BACK;
}
elsif ($heteroplasmy ne "" && $hp_back ne "")
{
    $hp_back = "";
    $no_hp_one_turn = "";
    $no_hp_one_turn2 = "";
    $no_hp_one_turn2_back = "";
}
if ($heteroplasmy ne "")
{
    foreach my $variance (sort { $a <=> $b } keys %variance_all)
    {
    } 
}
if ($heteroplasmy ne "" && $testos < 1000)
{
    $testos++;
    undef %variance_forward;
    undef %variance_back;
    my @test_NUMTs = keys %all_NUMT_SNPs;
    if (length($hp_seed) >= length($read) && $hp_seed ne "")
    {
        if (@test_NUMTs > 0)
        {
            foreach my $NUMT_SNP (keys %all_NUMT_SNPs)
            {
                if ($NUMT_SNP > $prev_current_pos-length($hp_seed) && $NUMT_SNP <= $prev_current_pos && $NUMT_SNP ne $current_pos-1)
                {
                    substr $hp_seed, $NUMT_SNP-($prev_current_pos-length($hp_seed)), 1, "N";
                }
            }
        }
        elsif (length($hp_seed2)-$last_SNP_hp > 20)
        {  
            my $new_hp_seed = substr $hp_seed2, -($overlap+10);
            my $new_SNPs = $last_SNP_hp-(length($hp_seed2)-length($new_hp_seed));
            $SNPs{$new_SNPs} = $SNPs{$last_SNP_hp};
            delete $SNPs{$last_SNP_hp};
            $hp_seed = $new_hp_seed;
        }
        else
        {
            goto HP_SKIP;
        }
        print OUTPUT5 $prev_current_pos." PREV_CURRENT_POS\n";
        print OUTPUT5 $hp_seed." NEW_SEQ_TEST\n";
        $y = '1';
        delete $noforward{$id};
        delete $noback{$id};
        $position = length($hp_seed);
        $position{$id} = $position;
        $position_back{$id} = '0';
        $position_back = '0';
        $hp_seed_assemble_last_chance_forward = "";
        $hp_seed_assemble_last_chance_back = "";
        $hp_cut_forward = "";
        $hp_cut_back = "";
        $first_contig_start = "";
        $last_150 = "";
        $seed{$id} = $hp_seed;
        $hp_seed_assemble = "yes";
        $hp_seed = "";
        $hp_seed2 = "";
        goto ITERATION;
    }
HP_SKIP:
    my $hp_seed_prev = $hp_seed;
    $hp_seed = "";
    $hp_seed2 = "";
    my $bad_read = "";
    undef %SNPs;
    undef %noSNPs;
    undef %SNPs_indel;

    if (exists($large_variance_forward{$id}))
    {
        $NUMT = "yes";
    }
    elsif (exists($large_variance_back{$id}))
    {
        $NUMT_back = "yes";
    }
    if ($hp_seed_assemble ne "")
    {
        %linked_SNPs_save = %linked_SNPs;
        %linked_half_SNPs_save = %linked_half_SNPs;
        %not_linked_SNPs_save = %not_linked_SNPs;
    }
    my $w = '0';
    my $pos_prev = '0';
    my $pos_tmp = "";
    my %hp_deleted;
    undef %hp_deleted;
    my $add_no_linkage = "";
    
    my $NUMT_prev = $NUMT;
    my $NUMT_back_prev = $NUMT_back;
    
HP: foreach my $variance (sort {$a <=> $b} keys %variance_all)
    {
        my @variances = split /\t/, $variance_all{$variance};
        print OUTPUT5 $variance_all{$variance}." VARIE\n";
        if ($NUMT ne "" || $NUMT_back ne "")
        {
            if (exists($variance_all_SNP{$variances[1]}))
            {
            }
        }
        else
        {
            delete $NUMT_assembled{$variances[1]};
        }
        if ($hp_seed_assemble ne "")
        {             
            my $linked_SNPs_final = "";
            my $linked_half_SNPs_final = "";
            my $not_linked_SNPs_final = "";

            foreach my $linked_snp (sort { $a <=> $b }keys %linked_SNPs)
            {
                $linked_SNPs_final .= $linked_snp." ";
                if ($circos_links ne "" && $variances[1] ne $linked_snp && $NUMT eq "" && $NUMT_back eq "")
                {
                    if (exists($circos_links{$variances[1]." ".$linked_snp}))
                    {}
                    else
                    {
                        my $print_circos_links = "hsM ".$variances[1]." ".$variances[1]." hsM ".$linked_snp." ".$linked_snp." color=0,114,178\n";
                        $circos_links{$variances[1]." ".$linked_snp} = $print_circos_links;
                    }
                }
            }                   
            foreach my $linked_half_snp (sort { $a <=> $b }keys %linked_half_SNPs)
            {
                $linked_half_SNPs_final .= $linked_half_snp." ";
                if ($circos_links ne "" && $variances[1] ne $linked_half_snp && $NUMT eq "" && $NUMT_back eq "")
                {
                    if (exists($circos_half_links{$variances[1]." ".$linked_half_snp}))
                    {}
                    else
                    {
                        my $print_circos_links = "hsM ".$variances[1]." ".$variances[1]." hsM ".$linked_half_snp." ".$linked_half_snp." color=240,190,0\n";
                        $circos_half_links{$variances[1]." ".$linked_half_snp} = $print_circos_links;
                    }
                }
            }           
            foreach my $not_linked_snp (sort { $a <=> $b }keys %not_linked_SNPs)
            {
                $not_linked_SNPs_final .= $not_linked_snp." ";
                
                if ($circos_links ne "" && $variances[1] ne $not_linked_snp && $NUMT eq "" && $NUMT_back eq "")
                {
                    if (exists($circos_links{$variances[1]." ".$not_linked_snp}))
                    {}
                    elsif (exists($circos_links{$not_linked_snp." ".$variances[1]}))
                    {}
                    else
                    {
                        my $print_circos_links = "hsM ".$variances[1]." ".$variances[1]." hsM ".$not_linked_snp." ".$not_linked_snp." color=213,94,0\n";
                        $circos_links{$variances[1]." ".$not_linked_snp} = $print_circos_links;
                    }
                }
            }
            chomp $not_linked_SNPs_final;      
            chomp $linked_SNPs_final;
            chomp $linked_half_SNPs_final;
            
            my @final_var = split /\t/, $variance_all{$variance};
            my $final_var = $variance_all{$variance};
            
            if ($variance_detection ne "yes")
            {
                my $nucs_alt_tmp = $final_var[4];
                my $info_tmp = $final_var[7];
                my @nucs_alt_tmp = split /,/, $nucs_alt_tmp;
                my @info = split /;/, $info_tmp;
                my $AF_tmp = "";
                if ($info[0] =~ m/AF=(.*)/)
                {
                    $AF_tmp = $1;
                }
                my @AF = split /,/, $AF_tmp;
                my $nucs_alt_new = "";
                my $AF_new = "";
                my $w = '0';
                if (length($final_var[3]) > 1 || length($final_var[4]) > 1)
                {
                    $w = '1';
                }
    print OUTPUT5 $final_var." FINALVAR\n";
                foreach my $nucs_alt_tmp2 (@nucs_alt_tmp)
                {
                    if ($nucs_alt_tmp2 ne $final_var[3])
                    {
                        if ($nucs_alt_new eq "")
                        {
                            $nucs_alt_new = $nucs_alt_tmp2;
                            $AF_new = $AF[$w];
                            if (exists($variance_pos_to_nuc_to_freq{$final_var[1]}{$nucs_alt_tmp2}))
                            {
                                $AF_new = $variance_pos_to_nuc_to_freq{$final_var[1]}{$nucs_alt_tmp2};
                                print OUTPUT5 $final_var[1]." POS\n";
                                print OUTPUT5 $nucs_alt_tmp2." NUC\n";
                                print OUTPUT5 $AF_new." AF_NEW\n";
                            }
                        }
                        else
                        {
                            $nucs_alt_new .= ",".$nucs_alt_tmp2;
                            $AF_new .= ",".$AF[$w];
                        }
                    }
                    $w++;
                }
                $final_var = $final_var[0]."\t".$final_var[1]."\t".$final_var[2]."\t".$final_var[3]."\t".$nucs_alt_new."\t".$final_var[5]."\t".$final_var[6]."\tAF=".$AF_new.";".$info[1].";".$info[2].";".$info[3];
            }
            
            if ($NUMT ne "" || $NUMT_back ne "")
            {
                $final_NUMTs{$variance} = $final_var;
                $final_NUMTs_assemblies{$variance} = $read;
                $final_linked_SNPs_NUMTs{$variance} = $linked_SNPs_final;
                $final_linked_half_SNPs_NUMTs{$variance} = $linked_half_SNPs_final;
                $final_not_linked_SNPs_NUMTs{$variance} = $not_linked_SNPs_final;
                     
                foreach my $linked_snp (sort { $a <=> $b }keys %linked_SNPs)
                {
                    $all_NUMT_SNPs{$linked_snp} = undef;
                }
            }
            else
            {
                $final_heteroplasmies{$variance} = $final_var;
                $final_heteroplasmies_assemblies{$variance} = $read;
                $final_linked_SNPs{$variance} = $linked_SNPs_final;
                $final_linked_half_SNPs{$variance} = $linked_half_SNPs_final;
                $final_not_linked_SNPs{$variance} = $not_linked_SNPs_final;
                
                if ($circos_links ne "")
                {
                    my $a = $variances[1]-2;
                    my $b = $variances[1]+2;
                    my $print_line_mut = "hsM ".$a." ".$b." ".$variances[1]." color=213,94,0\n";
                    $circos_mutations{$variances[1]} = $print_line_mut;
                }
            }            
            $hp_deleted{$variance} = undef;
            $pos_prev = $variances[1];
            $hp_seed_assemble = "";
            if ($NUMT eq "vdwbvd" && $NUMT_back eq "" && $split_hp_options eq "" && $pos_of_last_hp_split_option > $position-($insert_size*1.5))
            {
                print OUTPUT5 "TRY_WITH_EXTRA_SPLITS\n";
                $split_hp_options = "yes";

                $hp_seed_assemble_last_chance_forward = "";
                $hp_seed_assemble_last_chance_back = "";
                $hp_cut_forward = "";
                $hp_cut_back = "";
                $first_contig_start = "";
                $last_150 = "";
                undef %accepted_SNPs;
                undef %accepted_SNPs_back;
                undef %accepted_SNPs_pair;
                undef %accepted_SNPs_pair_back;
                undef %linked_SNPs;
                undef %not_linked_SNPs;
                undef %linked_half_SNPs;
                $linked_SNPs{$variance} = undef;
         
                undef %large_variance_forward;
                undef %large_variance_back;
                undef %last_ref_seq_forward;
                undef %last_ref_seq_back;
                undef %last_ref_pos_forward;
                undef %last_ref_pos_back;
                $hp_seed_assemble = "yes"; 
                $seed{$variance} = $hp_seed_prev;
                $seed_input_new2 = $hp_seed_prev;
                $position{$variance} = length($hp_seed_prev);
                $position_back{$variance} = "0";
                delete $noforward{$variance};
                %SNPs = %SNPs_prev;
    
                $y = '1';
                goto REF2;
            }
            
            $NUMT = "";
            $NUMT_back = ""; 
            
            foreach my $hp_pos_tmp  (sort {$b <=> $a} keys %hp_splits)
            {
                my @array = split /\+/, $hp_splits{$hp_pos_tmp};
                my $hp_seed = $array[1];
                $hp_seed_assemble = "yes";
                undef %linked_SNPs;
                undef %not_linked_SNPs;
                undef %linked_half_SNPs;
                
                $seed{$hp_pos_tmp} = $hp_seed;
                $seed_input_new2 = $hp_seed;
                my @array2 = split /\+/, $hp_pos_tmp;
                $position{$hp_pos_tmp} = $array2[-1];
                $position_back{$hp_pos_tmp} = $array[0];
                
                my $all_SNPs_tmp = substr $array[2], 1;
                my @all_SNPs = split /,/, $all_SNPs_tmp;
                my $all_SNPs_tmp2 = substr $array[3], 1;
                my @all_SNPs2 = split /,/, $all_SNPs_tmp2;
                my $h = '0';
                foreach my $all_SNPs (@all_SNPs)
                {
                    $SNPs{$all_SNPs} = $all_SNPs2[$h];
                    $h++;
                }
                my $all_linked_SNPs_tmp = substr $array[4], 1;
                my @all_linked_SNPs = split /,/, $all_linked_SNPs_tmp;
                foreach my $all_linked_SNPs (@all_linked_SNPs)
                {
                    $linked_SNPs{$all_linked_SNPs} = undef;
                }
                my $all_half_linked_SNPs_tmp = substr $array[5], 1;
                my @all_half_linked_SNPs = split /,/, $all_half_linked_SNPs_tmp;
                foreach my $all_half_linked_SNPs (@all_half_linked_SNPs)
                {
                    $linked_half_SNPs{$all_half_linked_SNPs} = undef;
                }
                my $all_not_linked_SNPs_tmp = substr $array[6], 1;
                my @all_not_linked_SNPs = split /,/, $all_not_linked_SNPs_tmp;
                foreach my $all_not_linked_SNPs (@all_not_linked_SNPs)
                {
                    $not_linked_SNPs{$all_not_linked_SNPs} = undef;
                }
                my $all_noSNPs_tmp = substr $array[7], 1;
                my @all_noSNPs = split /,/, $all_noSNPs_tmp;
                my $all_noSNPs_tmp2 = substr $array[8], 1;
                my @all_noSNPs2 = split /,/, $all_noSNPs_tmp2;
                my $ff = '0';
                foreach my $all_noSNPs (@all_noSNPs)
                {
                    $noSNPs{$all_noSNPs} = $all_noSNPs2[$ff];
                    $ff++;
                }
                delete $hp_splits{$hp_pos_tmp};
                
                $hp_seed_assemble_last_chance_forward = "";
                $hp_seed_assemble_last_chance_back = "";
                $hp_cut_forward = "";
                $hp_cut_back = "";
                $first_contig_start = "";
                $last_150 = "";
                undef %accepted_SNPs;
                undef %accepted_SNPs_back;
                undef %accepted_SNPs_pair;
                undef %accepted_SNPs_pair_back;
    
                $y = '1';
                goto REF2;
            }                                
            next HP;
        }

        $pos_tmp = $variances[1];
        my $AF_tmp = $variances[7];
        my $AF_tmp2 = "";
        print OUTPUT5 $AF_tmp." AF_TMP\n";
        if ($AF_tmp =~ m/AF=(\d+\.\d+).*/)
        {
            $AF_tmp2 = $1;
            print OUTPUT5 $AF_tmp2." AF_TMP2\n";
        }
        my $ref_tmp = $variances[3];
        my $ref_alt_tmp = $variances[4];
        if ($AF_tmp2 > 0.85)
        {
            $ref_tmp = $variances[4];
            $ref_alt_tmp = $variances[3];
        }

        my @ref_alt_tmp = split /,/, $ref_alt_tmp;
        undef %linked_half_SNPs;
        $split_hp_options = "";
        
        my $prev_SNP = "";
        my $end_pos;
        my $long_enough;
        my $longer;
        my $last_HP_SNP = $current_pos-1;
        print OUTPUT5 $current_pos." CURRENT_POS\n";
LONGER: foreach my $variance_tmp (sort { $b <=> $a } keys %variance_all_SNP)
        {
            if ($longer eq "not_linked2")
            {
                $current_pos = $variance_tmp+1;
                $longer = "last_chance";
            }
            elsif ($longer eq "not_linked")
            {
                if ($variance_tmp eq $last_HP_SNP)
                {
                    $longer = "not_linked2";
                }
                next LONGER;
            }
            if ($end_pos ne "")
            {
                $current_pos = $variance_tmp+1;
                if (($end_pos-$current_pos > $overlap*2 && $end_pos ne "end") || ($end_pos eq "end" && $pos_tmp-$current_pos+length($hashref2{$pos_tmp}) > $overlap*2))
                {
                    $long_enough = "yes";
                    last LONGER;
                }
                elsif ($longer eq "last_chance" && (($end_pos-$current_pos > $overlap+15 && $end_pos ne "end") || ($end_pos eq "end" && $pos_tmp-$current_pos+length($hashref2{$pos_tmp}) > $overlap+15)))
                {
                    $long_enough = "yes";
                    last LONGER;
                }
                elsif ($longer eq "last_chance")
                {
                }
                else
                {
                    last LONGER;
                }
            }
            if ($current_pos eq '1' && $variance_tmp eq $pos_tmp)
            {
                $end_pos = $prev_SNP-1;
                if ($prev_SNP eq "")
                {
                    $end_pos = $variance_tmp+60;
                }
                $long_enough = "yes";
                last LONGER;
            }
            elsif ($end_pos eq "" && $variance_tmp eq $pos_tmp)
            {     
                $end_pos = $prev_SNP-1;
                if ($prev_SNP eq "")
                {
                    $end_pos = "end";
                }
            }
            $prev_SNP = $variance_tmp;
        }
        if ($longer eq "last_chance" && $long_enough ne "yes")
        {
            $current_pos = $end_pos-$overlap-15;
            if ($current_pos < 1)
            {
                $current_pos = '1';
            }
            $long_enough = "yes"
        }
LONGER2:       
        if ($long_enough eq "yes")
        {
            if ($current_pos < $pos_tmp-($overlap*2))
            {
                $current_pos = $pos_tmp-($overlap*2);
                if ($current_pos < 0)
                {
                    $current_pos = '1';
                }
            }
            while (($current_pos <= $end_pos || $end_pos eq "end") && exists($hashref2{$current_pos}))
            {
                my $next_nuc;
                if ($current_pos eq $pos_tmp)
                {
                    $next_nuc = $ref_alt_tmp[0];
                    $SNPs{length($hp_seed)+1} = $ref_alt_tmp[0];
                    $SNP_to_assemble = length($hp_seed)+1;
                    
print OUTPUT5 $next_nuc." THE SNP1\n";
                }
                elsif (exists($HP_exclude{$current_pos}) && exists($variance_all_SNP{$current_pos}))
                {
                    $next_nuc = $variance_all_SNP{$current_pos};
print OUTPUT5 $next_nuc." THE SNP2\n"
                }
                elsif (exists($linked_SNPs{$current_pos}) && exists($linked_SNPs{$pos_tmp}) && $NUMT_prev eq "" && $NUMT_back_prev eq "")
                {
                    if (length($hp_seed) eq 0)
                    {
                        goto SKIP_DOT_HP;
                    }
                    if (length($hp_seed) > $overlap+16 && $current_pos > $pos_tmp)
                    {
                        last;
                    }
                    $next_nuc = "N";
                    $linked_half_SNPs{$current_pos} = undef;
                }
                elsif (exists($variance_all_SNP{$current_pos}))
                {
                    if (length($hp_seed) eq 0)
                    {
                        goto SKIP_DOT_HP;
                    }
                    if (exists($not_linked_SNPs_save{$current_pos}))
                    {
                        $next_nuc = substr $hashref2{$current_pos}, 0, 1;
                    }
                    else
                    {
                        $next_nuc = "N";
                        $linked_half_SNPs{$current_pos} = undef;
                    } 
                }
                elsif (exists($variance_all_homo{$current_pos}))
                {
                    my @variances_homo_tmp = split /\t/, $variance_all_homo{$current_pos};
                    $next_nuc = $variances_homo_tmp[4];
                } 
                else
                {
                    $next_nuc = substr $hashref2{$current_pos}, 0, 1;
                }             
                
                if ($current_pos > $pos_tmp+$overlap+5 && length($hp_seed) > ($overlap*2)+1)
                {
                    last;
                }
                elsif ($current_pos > $pos_tmp+6 && length($hp_seed) > ($overlap*2)+1)
                {
                    $hp_seed2 .= $next_nuc;
                }
                else
                {
                    $hp_seed .= $next_nuc;
                    $hp_seed2 .= $next_nuc;     
                }
SKIP_DOT_HP:                
                $current_pos++;
            }
        }
        elsif (exists($not_linked_SNPs_save{$pos_tmp}) && $longer eq "")
        {
           $longer = "not_linked";
           print OUTPUT5 "NOT_LINKED\n";
           goto LONGER; 
        }
        elsif (($end_pos-$current_pos > $overlap+15 && $end_pos ne "end") || ($end_pos eq "end" && $pos_tmp-$current_pos+length($hashref2{$pos_tmp}) > $overlap+15))
        {
            $long_enough = "yes";
            print OUTPUT5 "LONG_ENOUGH\n";
            goto LONGER2;
        }
        elsif ($longer eq "")
        {
            $longer = "last_chance";
            print OUTPUT5 "LAST_CHANCE\n";
            goto LONGER;
        }
        
        undef %large_variance_forward;
        undef %large_variance_back;
        undef %last_ref_seq_forward;
        undef %last_ref_seq_back;
        undef %last_ref_pos_forward;
        undef %last_ref_pos_back;
        $prev_current_pos = $current_pos;
        $current_pos = $pos_tmp+1;
        $hp_seed_assemble = "yes"; 
        $seed{$pos_tmp} = $hp_seed;
        $seed_input_new2 = $hp_seed;
        $position{$pos_tmp} = length($hp_seed);
        $position_back{$pos_tmp} = "0";
        $hp_splits = "";
        %SNPs_prev = %SNPs;
        print OUTPUT5 $hp_seed." SEQ_TEST\n"; 
        $w = '0';
        last HP;
    } 
    my $count_seed = '0';
    foreach my $count_seed2 (keys %seed)
    {
        $count_seed++;
    }
    if ($count_seed > 0)
    {
        foreach (keys %hp_deleted)
        {
            delete $variance_all{$_};
        }
        $hp_seed_assemble_last_chance_forward = "";
        $hp_seed_assemble_last_chance_back = "";
        $hp_cut_forward = "";
        $hp_cut_back = "";
        $first_contig_start = "";
        $last_150 = "";
        $pos_of_last_hp_split_option = "";
        $no_hp_one_turn = "";
        $no_hp_one_turn2 = "";
        $no_hp_one_turn2_back = "";
        undef %accepted_SNPs;
        undef %accepted_SNPs_back;
        undef %accepted_SNPs_pair;
        undef %accepted_SNPs_pair_back;
        undef %linked_SNPs;
        undef %not_linked_SNPs;
        
        if ($add_no_linkage ne "")
        {
            $not_linked_SNPs{$add_no_linkage} = undef;
        }
        $linked_SNPs{$pos_tmp} = undef;
        
        $y = '1';
        goto REF2;
    }
}
if ($heteroplasmy ne "")
{
    my @final_heteroplasmies = keys %final_heteroplasmies;
    my @final_NUMTs = keys %final_NUMTs;
    if (@final_NUMTs > 0)
    {
        open($file15, ">" .$output_file15) or die "Can't open Possible NUMTs file $output_file15, $!\n";
        open($file16, ">" .$output_file16) or die "Can't open Possible NUMTs assemblies file $output_file16, $!\n";
        open($file21, ">" .$output_file21) or die "Can't open Linkage table NUMTs file $output_file16, $!\n";
        my ($wday, $mon, $mday, $hour, $min, $sec, $year) = localtime;
        my @localtime = split / /, localtime;
        my %mon2num = qw(
        Jan 01  Feb 02  Mar 03  Apr 04  May 05  Jun 06
        Jul 07  Aug 08  Sep 09  Oct 10 Nov 11 Dec 12
        );
        my $month = $localtime[1];
        if (exists($mon2num{$localtime[1]}))
        {
           $month = $mon2num{$localtime[1]};
        }
        print $file15 "##fileformat=VCFv4.0\n";
        print $file15 "##fileDate=".$localtime[4].$month.$localtime[2]."\n";
        print $file15 "##reference=".$reference."\n";
        print $file15 "##INFO=<ID=AF,Number=1,Type=Float,Description=\"Allele Frequency\">\n";
        print $file15 "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Raw Depth\">\n";
        print $file15 "##INFO=<ID=FR,Number=1,Type=Flag,Description=\"Detected on the forward(F) and/or reverse(R) strand\">\n";
        print $file15 "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n";
    }
    my $final_count_hp = '0';
    my $final_count_homo = '0';
    foreach my $variance (sort { $a <=> $b } keys %final_heteroplasmies)
    {
        print $file13 $final_heteroplasmies{$variance}."\n";
        print $file14 ">".$variance."\n";
        print $file14 $final_heteroplasmies_assemblies{$variance}."\n";
        print $file20 "Position ".$variance."\n";
        print $file20 $final_linked_SNPs{$variance}." LINKED_SNPs\n";
        print $file20 $final_linked_half_SNPs{$variance}." PARTIALLY_LINKED_SNPs\n";
        print $file20 $final_not_linked_SNPs{$variance}." NOT_LINKED_SNPs\n\n";
        $final_count_hp++;
    }
    foreach my $variance (sort { $a <=> $b } keys %final_NUMTs)
    {
        print $file15 $final_NUMTs{$variance}."\n";
        print $file16 ">".$variance."\n";
        print $file16 $final_NUMTs_assemblies{$variance}."\n";
        print $file21 "Position ".$variance."\n";
        print $file21 $final_linked_SNPs_NUMTs{$variance}." LINKED_SNPs\n";
        print $file21 $final_linked_half_SNPs_NUMTs{$variance}." PARTIALLY_LINKED_SNPs\n";
        print $file21 $final_not_linked_SNPs_NUMTs{$variance}." NOT_LINKED_SNPs\n\n";
    }
    my $count_homo = keys %variance_all_homo;
    if ($count_homo > 0)
    {
        open($file19, ">" .$output_file19) or die "Can't open Homoplasmy file $output_file19, $!\n";
        my ($wday, $mon, $mday, $hour, $min, $sec, $year) = localtime;
        my @localtime = split / /, localtime;
        my %mon2num = qw(
        Jan 01  Feb 02  Mar 03  Apr 04  May 05  Jun 06
        Jul 07  Aug 08  Sep 09  Oct 10 Nov 11 Dec 12
        );
        my $month = $localtime[1];
        if (exists($mon2num{$localtime[1]}))
        {
           $month = $mon2num{$localtime[1]};
        }
        print $file19 "##fileformat=VCFv4.0\n";
        print $file19 "##fileDate=".$localtime[4].$month.$localtime[2]."\n";
        print $file19 "##reference=".$reference."\n";
        print $file19 "##INFO=<ID=AF,Number=1,Type=Float,Description=\"Allele Frequency\">\n";
        print $file19 "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Raw Depth\">\n";
        print $file19 "##INFO=<ID=FR,Number=1,Type=Flag,Description=\"Detected on the forward(F) and/or reverse(R) strand\">\n";
        print $file19 "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n";
        
        foreach my $variance (sort { $a <=> $b } keys %variance_all_homo)
        {
            print $file19 $variance_all_homo{$variance}."\n";
            $final_count_homo++;
        }
    }
    if ($circos_links ne "")
    {
        foreach my $circo_mut (sort { $a <=> $b } keys %circos_mutations)
        {
            print $file18 $circos_mutations{$circo_mut};
        }
        foreach my $circo_mut (sort { $a <=> $b } keys %circos_links)
        {
            print $file17 $circos_links{$circo_mut};
        }
        if ($circos_links eq "yes2")
        {
            foreach my $circo_half_link (sort { $a <=> $b } keys %circos_half_links)
            {
                print $file17 $circos_half_links{$circo_half_link};
            }
        }
    }
    print "\b" x length($progress_before);
    print ' ' x length($progress_before);
    print "\b" x length($progress_before);
    print "\n";
    print "\n\n\n----------------------------------Post NUMT assembly data metrics----------------------------------\n\n";
    print OUTPUT4"\n\n\n----------------------------------Post NUMT assembly data metrics----------------------------------\n\n";
    print   "Homoplasmic positions   : ".$final_count_homo."\n"; 
    print "\nHeteroplasmic positions : ".$final_count_hp."\n";
    print OUTPUT4   "Homoplasmic positions   : ".$final_count_homo."\n";
    print OUTPUT4 "\nHeteroplasmic positions : ".$final_count_hp."\n";
    print "\n-----------------------------------------------------------------------------------------------------\n\n";
    print OUTPUT4 "\n-----------------------------------------------------------------------------------------------------\n\n";
}
if ($save_reads ne "")
{                                  
    foreach my $add_read (keys %save_reads)
    {
        if ($save_reads eq "2")
        {
            my $chop_id = $add_read;
            chop($chop_id);
            my $add_read2 = $map_ids{$chop_id};
            print OUTPUT10 $add_read2."\/1\n";
            print OUTPUT11 $add_read2."\/2\n";
        }
        else
        {
            print OUTPUT10 ">".$add_read."\/1\n";
            print OUTPUT11 ">".$add_read."\/2\n";
        }
        if (exists($hash{$add_read}))
        {
            my @add_read = split /,/, $hash{$add_read};
            my $forward = $add_read[0];
            my $reverse = $add_read[1];
            if ($use_quality ne "")
            {
                $forward =~tr/1234/ACTG/;
                $reverse =~tr/1234/ACTG/;
            }
            print OUTPUT10 $forward."\n";
            print OUTPUT11 $reverse."\n";
        }
    }
}
close INPUT;
close OUTPUT4;
close OUTPUT5;
close OUTPUT6;
close OUTPUT7;
close OUTPUT10;
close OUTPUT11;
close OUTPUT12;

if ($batch_file ne "")
{
    goto BATCH;
}
EXIT:
close BATCH;
print "\nThank you for using NOVOPlasty!\n\n";
